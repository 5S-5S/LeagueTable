<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Continental Football - League Table Statistics</title>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <link rel="stylesheet" href="ContinentalEurope.css">
    <script>
        // Device detection and redirect logic
        (function() {
            // Check if user manually requested desktop version
            const urlParams = new URLSearchParams(window.location.search);
            const forceDesktop = urlParams.get('desktop') === 'true';

            if (forceDesktop) {
                return; // Stay on desktop version
            }

            // Mobile detection
            function isMobileDevice() {
                // Screen width detection
                const isSmallScreen = window.innerWidth <= 640;

                // Touch device detection
                const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

                // User agent detection (mobile-specific patterns)
                const mobileUserAgents = [
                    /Android/i,
                    /webOS/i,
                    /iPhone/i,
                    /iPad/i,
                    /iPod/i,
                    /BlackBerry/i,
                    /Windows Phone/i,
                    /Opera Mini/i,
                    /IEMobile/i,
                    /Mobile/i
                ];

                const isMobileUA = mobileUserAgents.some(pattern =>
                    pattern.test(navigator.userAgent)
                );

                // Return true if any mobile criteria are met
                return isSmallScreen || (hasTouchScreen && isMobileUA);
            }

            // Redirect to mobile version if mobile device detected
            if (isMobileDevice()) {
                window.location.href = 'ContinentalEuropeMobile.html';
            }
        })();
    </script>
<body>
    <!-- Hamburger Menu Button -->
    <button id="hamburgerBtn" class="hamburger-btn" style="position: fixed; top: 1rem; left: 1rem; z-index: 1001; background: white; border: 1px solid #ccc; padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; display: flex; flex-direction: column; gap: 0.25rem;">
        <span class="hamburger-line" style="width: 1.5rem; height: 0.125rem; background: #374151; border-radius: 0.125rem;"></span>
        <span class="hamburger-line" style="width: 1.5rem; height: 0.125rem; background: #374151; border-radius: 0.125rem;"></span>
        <span class="hamburger-line" style="width: 1.5rem; height: 0.125rem; background: #374151; border-radius: 0.125rem;"></span>
    </button>

    <!-- Collapse Controls Arrow Button -->
    <button id="collapseControlsBtn" class="collapse-controls-btn" style="position: fixed; top: 1rem; right: 1rem; z-index: 1001; background: white; border: 1px solid #ccc; padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; display: flex; flex-direction: column; gap: 0.25rem;" title="Hide/Show Controls">
        <span style="width: 1.5rem; height: 0.875rem; display: flex; align-items: center; justify-content: center; font-size: 1rem;">‚ñº</span>
    </button>

    <!-- Sidebar Overlay -->
    <div id="menuOverlay" class="menu-overlay hidden"></div>

    <!-- Sidebar Menu -->
    <div id="sideMenu" class="side-menu">
        <div class="menu-header">
            <h2 class="text-xl font-bold text-gray-800">Navigation</h2>
            <button id="closeMenuBtn" class="close-btn">&times;</button>
        </div>
        <nav class="menu-nav">
            <!-- Home Section -->
            <div class="menu-section">
                <a href="index.html" class="menu-item">
                    <span class="menu-icon">üè†</span>
                    <span>Home Page</span>
                </a>
            </div>
            
            <!-- Football Section -->
            <div class="menu-section">
                <h3 class="menu-section-title">Football</h3>
                <a href="DomesticEurope.html" class="menu-item" data-page="domestic">
                    <span class="menu-icon">‚öΩ</span>
                    <span>Domestic Football - Top 5 Leagues</span>
                </a>
                <a href="#" id="continentalFootballLink" class="menu-item active" data-page="continental">
                    <span class="menu-icon">üèÜ</span>
                    <span>Continental Football - Champions League</span>
                </a>
                <div class="menu-item disabled">
                    <span class="menu-icon">üåç</span>
                    <span>International Football - Coming Soon</span>
                </div>
            </div>

            <!-- Other Sports Section -->
            <div class="menu-section">
                <h3 class="menu-section-title">Other Sports</h3>
                <div class="menu-item disabled">
                    <span class="menu-icon">üèà</span>
                    <span>NFL - Coming Soon</span>
                </div>
                <div class="menu-item disabled">
                    <span class="menu-icon">üèÄ</span>
                    <span>NBA - Coming Soon</span>
                </div>
            </div>

            <!-- Support Section -->
            <div class="menu-section">
                <a href="qa.html" class="menu-item">
                    <span class="menu-icon">‚ùì</span>
                    <span>Q&A</span>
                </a>
                <a href="contact.html" class="menu-item">
                    <span class="menu-icon">üìß</span>
                    <span>Contact & Support</span>
                </a>
            </div>
        </nav>
    </div>

    <div class="league-table-container">
        <div class="main-card">
            <!-- Header -->
            <div class="header">
                <div class="header-content">
                    <div>
                        <h1 class="text-4xl font-bold mb-2">Continental Football Filters</h1>
                        <p class="text-lg opacity-90" id="lastDataUpdate">Last Data Update: Loading...</p>
                    </div>
                    <div class="dark-mode-toggle">
                        <input type="checkbox" id="darkModeToggle" class="toggle-checkbox">
                        <label for="darkModeToggle" class="toggle-label">
                            <span class="toggle-button"></span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Controls Section -->
            <div id="controlsSection" class="controls-section hidden">
                
                <!-- Tab Container -->
                <div class="tab-container">
                    <button class="tab-button active" id="leagueFiltersTab" data-mobile-text="Tables & H2H">League Tables & Head to Head Stats</button>
                    <button class="tab-button" id="teamSeasonsTab" data-mobile-text="Team Seasons">Team Seasons</button>
                    <button class="tab-button" id="lastTimeWhenTab" data-mobile-text="Last Time">The Last Time When...</button>
                    <button class="tab-button" id="teamStreaksTab" data-mobile-text="Streaks">Team Streaks</button>
                </div>

                <!-- League Filters Tab Content -->
                <div id="leagueFiltersContent" class="tab-content active">
                    <!-- Description -->
                    <div class="mb-6 p-4 border border-gray-200 rounded-lg collapsible-control">
                        <p class="text-gray-700 text-sm leading-relaxed">
                            Filter and analyze stats for the major continental competitions. Select prior seasons, custom date ranges, competition stages, and specific teams to find and filter league standings and head-to-head records to filter with. 
                        </p>
                    </div>

                    <!-- League Selection -->
                    <div class="mb-8 collapsible-control">
                        <label class="block text-sm font-semibold text-gray-700 mb-4">Select Competition:</label>
                        <div class="league-buttons" id="leagueButtons">
                            <!-- League buttons will be populated here -->
                        </div>
                    </div>
                
                <!-- Filters -->
                <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-6 collapsible-control">
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <span class="icon-search mr-2"></span>Season
                        </label>
                        <select id="seasonSelect" class="form-input">
                            <option value="">Select Season</option>
                        </select>
                    </div>
                    
                    <!-- Competition Stage Filter (only visible when season is selected) -->
                    <div id="competitionStageContainer">
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <span class="icon-trophy mr-2">üèÜ</span>Stage
                        </label>
                        <select id="competitionStageSelect" class="form-input">
                            <option value="">All</option>
                            <option value="group-stage">League/Group Stage</option>
                            <option value="knockout-stage">Knock-Out Stage</option>
                            <option value="Final">Final</option>
                            <option value="Semi-Finals">Semi-Finals</option>
                            <option value="Quarter-Finals">Quarter-Finals</option>
                            <option value="Round Of 16">Round Of 16</option>
                            <option value="Play-Offs">Play-Offs</option>
                            <option value="2. Round">2. Round</option>
                            <option value="1. Round">1. Round</option>
                        </select>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <span class="icon-calendar mr-2"></span>Start Date (MM/DD/YYYY)
                        </label>
                        <input type="date" id="dateFrom" class="form-input">
                    </div>
                    
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <span class="icon-calendar mr-2"></span>End Date (MM/DD/YYYY)
                        </label>
                        <input type="date" id="dateTo" class="form-input">
                    </div>
                    
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <span class="icon-calendar mr-2"></span>Day of Week
                        </label>
                        <select id="dayOfWeekSelect" class="form-input">
                            <option value="">All Days</option>
                            <option value="0">Sunday</option>
                            <option value="1">Monday</option>
                            <option value="2">Tuesday</option>
                            <option value="3">Wednesday</option>
                            <option value="4">Thursday</option>
                            <option value="5">Friday</option>
                            <option value="6">Saturday</option>
                        </select>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <span class="icon-search mr-2"></span>Team 1
                        </label>
                        <div class="combobox-container" id="team1ComboboxContainer">
                            <input type="text" id="team1ComboboxInput" class="combobox-input" placeholder="All Teams" autocomplete="off">
                            <span class="combobox-arrow">‚ñº</span>
                            <div class="combobox-dropdown" id="team1ComboboxDropdown"></div>
                        </div>
                        <select id="team1Select" class="form-input" style="display: none;">
                            <option value="">All Teams</option>
                        </select>
                    </div>

                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <span class="icon-search mr-2"></span>Team 2
                        </label>
                        <div class="combobox-container" id="team2ComboboxContainer">
                            <input type="text" id="team2ComboboxInput" class="combobox-input" placeholder="No Team" autocomplete="off">
                            <span class="combobox-arrow">‚ñº</span>
                            <div class="combobox-dropdown" id="team2ComboboxDropdown"></div>
                        </div>
                        <select id="team2Select" class="form-input" style="display: none;">
                            <option value="">No Team</option>
                        </select>
                    </div>
                </div>
                
                <!-- Match Type and Action Buttons -->
                <div class="flex flex-wrap items-center justify-between gap-4 collapsible-control">
                    <div class="flex items-center gap-6">
                        <span class="text-sm font-semibold text-gray-700">Match Results:</span>

                        <label class="flex items-center cursor-pointer">
                            <div id="homeCheckbox" class="checkbox checked"></div>
                            <span class="icon-home mr-1"></span>
                            <span class="text-sm font-medium">Home</span>
                        </label>

                        <label class="flex items-center cursor-pointer">
                            <div id="awayCheckbox" class="checkbox checked"></div>
                            <span class="icon-plane mr-1"></span>
                            <span class="text-sm font-medium">Away</span>
                        </label>

                        <label class="flex items-center cursor-pointer">
                            <div id="deductionsCheckbox" class="checkbox checked"></div>
                            <span class="icon-alert mr-1"></span>
                            <span class="text-sm font-medium">Point Deductions</span>
                        </label>

                        <label class="flex items-center cursor-pointer">
                            <div id="threePointCheckbox" class="checkbox checked"></div>
                            <span class="text-sm font-medium">3 Points for all Wins</span>
                        </label>
                    </div>

                    <div class="flex gap-3">
                        <button id="reloadGistsBtn" class="btn btn-blue">
                            <span class="icon-link"></span>Reload Data
                        </button>
                        <button id="resetBtn" class="btn btn-secondary">Reset</button>
                    </div>
                </div>

                <!-- Exclude Options -->
                <div class="flex items-center gap-6 mt-4 collapsible-control">
                    <span class="text-sm font-semibold text-gray-700">Exclude:</span>

                    <label class="flex items-center cursor-pointer">
                        <div id="excludeQualifiersCheckbox" class="checkbox"></div>
                        <span class="text-sm font-medium">Exclude Qualifiers</span>
                    </label>

                    <label class="flex items-center cursor-pointer">
                        <div id="excludeMainStageCheckbox" class="checkbox"></div>
                        <span class="text-sm font-medium">Exclude Main Stage</span>
                    </label>
                </div>
                </div>

                <!-- Team Seasons Tab Content -->
                <div id="teamSeasonsContent" class="tab-content">
                    <!-- Description -->
                    <div class="mb-6 p-4 bg-green-50 border border-green-200 rounded-lg collapsible-control">
                        <p class="text-gray-700 text-sm leading-relaxed">
                            Select a competition and team below to view a list of their seasons. You can find out how many times a team finished in a particular place or even find something like a list of every 2nd place team. Note: only seasons where teams qualified for group or knockout stages are included.
                        </p>
                    </div>

                    <!-- League Selection for Team Seasons -->
                    <div class="mb-8 collapsible-control">
                        <label class="block text-sm font-semibold text-gray-700 mb-4">Select Competition:</label>
                        <div class="league-buttons" id="teamSeasonsLeagueButtons">
                            <!-- League buttons will be populated here -->
                        </div>
                    </div>

                    <!-- Team Selection -->
                    <div class="mb-8 collapsible-control">
                        <label class="block text-sm font-semibold text-gray-700 mb-2">Select Team:</label>
                        <div class="combobox-container" id="teamSeasonsComboboxContainer">
                            <input type="text" id="teamSeasonsComboboxInput" class="combobox-input" placeholder="Choose a team..." autocomplete="off">
                            <span class="combobox-arrow">‚ñº</span>
                            <div class="combobox-dropdown" id="teamSeasonsComboboxDropdown"></div>
                        </div>
                        <select id="teamSeasonsTeamSelect" class="form-input w-full" style="display: none;">
                            <option value="">Choose a team...</option>
                        </select>
                    </div>

                    <!-- Season Selection (only for Ligue 1 and Premier League) -->
                    <div id="teamSeasonsSeasonContainer" class="mb-8 hidden collapsible-control">
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <span class="icon-search mr-2"></span>Season
                        </label>
                        <select id="teamSeasonsSeasonSelect" class="form-input w-full">
                            <option value="">Select Season</option>
                        </select>
                    </div>

                    <!-- Progression Filter -->
                    <div id="teamSeasonsPositionContainer" class="mb-8 collapsible-control">
                        <label class="block text-sm font-semibold text-gray-700 mb-2">Filter by Progression:</label>
                        <select id="teamSeasonsPositionSelect" class="form-input w-full">
                            <option value="">All Progressions</option>
                            <option value="Champions">Champions</option>
                            <option value="Final">Final</option>
                            <option value="Semi-Finals">Semi-Finals</option>
                            <option value="Quarter-Finals">Quarter-Finals</option>
                            <option value="Round Of 16">Round Of 16</option>
                            <option value="Play-Offs">Play-Offs</option>
                            <option value="Group Stage">Group Stage</option>
                            <option value="2. Round">2. Round</option>
                            <option value="1. Round">1. Round</option>
                        </select>
                        
                        <!-- Include Better Results Checkbox -->
                        <div id="includeBetterResultsContainer" class="mt-3 flex items-center gap-2 hidden">
                            <label class="flex items-center cursor-pointer">
                                <div id="includeBetterResultsCheckbox" class="checkbox"></div>
                                <span class="text-sm font-medium text-gray-700 ml-2">Include better results</span>
                            </label>
                        </div>
                        
                        <div id="teamSeasonsPositionInfo" class="mt-2 text-sm text-gray-600"></div>
                    </div>

                    <!-- Team History Table -->
                    <div id="teamHistoryTable" class="mt-8 hidden">
                        <div class="league-table">
                            <div class="text-center py-4 bg-blue-50 border-b relative">
                                <!-- Back Arrow for Team History -->
                                <div id="teamHistoryBackArrow" class="absolute left-4 top-1/2 transform -translate-y-1/2 hidden">
                                    <button class="flex items-center text-blue-600 hover:text-blue-800 transition-colors cursor-pointer" onclick="goBackToLeagueTables()">
                                        <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
                                        </svg>
                                        <span class="text-sm font-medium">Back</span>
                                    </button>
                                </div>
                                <h2 class="text-xl font-semibold text-blue-800 mb-1">üèÜ Team History</h2>
                                <p class="text-sm text-blue-600 font-medium" id="teamHistoryTitle"></p>
                            </div>
                            <table>
                                <thead>
                                    <tr id="teamHistoryHeader">
                                        <!-- Team history headers will be populated -->
                                    </tr>
                                </thead>
                                <tbody id="teamHistoryBody">
                                    <!-- Team history rows will be populated -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Last Time When Tab Content -->
                <div id="lastTimeWhenContent" class="tab-content">
                    <!-- Description -->
                    <div class="mb-6 p-4 border border-gray-200 rounded-lg collapsible-control">
                        <p class="text-gray-700 text-sm leading-relaxed">
                            This tool allows you to find out the last time a team won, drew, or lost against an opponent. At home or away. Or in a particular stage. On the day of the week too, if you so choose.
                        </p>
                    </div>
                    
                    <!-- League Selection -->
                    <div class="mb-8 collapsible-control">
                        <label class="block text-sm font-semibold text-gray-700 mb-4">Select Competition:</label>
                        <div class="league-buttons" id="lastTimeLeagueButtons">
                            <!-- League buttons will be populated here -->
                        </div>
                    </div>

                    <!-- Stage Selection -->
                    <div class="mb-8 collapsible-control">
                        <label class="block text-sm font-semibold text-gray-700 mb-2">Competition Stage:</label>
                        <select id="lastTimeStageSelect" class="form-input max-w-xs">
                            <option value="">All</option>
                            <option value="League/Group Stage">League/Group Stage</option>
                            <option value="Knock-Out Stage">Knock-Out Stage</option>
                            <option value="Final">Final</option>
                            <option value="Semi-Finals">Semi-Finals</option>
                            <option value="Quarter-Finals">Quarter-Finals</option>
                            <option value="Round Of 16">Round Of 16</option>
                            <option value="Play-Offs">Play-Offs</option>
                            <option value="2. Round">2. Round</option>
                            <option value="1. Round">1. Round</option>
                        </select>
                    </div>
                    
                    <!-- Controls -->
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-6 collapsible-control">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">Day of Week</label>
                            <select id="lastTimeDayOfWeekSelect" class="form-input">
                                <option value="">All Days</option>
                                <option value="0">Sunday</option>
                                <option value="1">Monday</option>
                                <option value="2">Tuesday</option>
                                <option value="3">Wednesday</option>
                                <option value="4">Thursday</option>
                                <option value="5">Friday</option>
                                <option value="6">Saturday</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">Location</label>
                            <select id="lastTimeLocationSelect" class="form-input">
                                <option value="">Both Home and Away</option>
                                <option value="home">Home</option>
                                <option value="away">Away</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">Team 1</label>
                            <div class="combobox-container" id="lastTimeTeam1ComboboxContainer">
                                <input type="text" id="lastTimeTeam1ComboboxInput" class="combobox-input" placeholder="Select Team 1" autocomplete="off">
                                <span class="combobox-arrow">‚ñº</span>
                                <div class="combobox-dropdown" id="lastTimeTeam1ComboboxDropdown"></div>
                            </div>
                            <select id="lastTimeTeam1Select" class="form-input" style="display: none;">
                                <option value="">Select Team 1</option>
                            </select>
                        </div>

                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">Team 2</label>
                            <div class="combobox-container" id="lastTimeTeam2ComboboxContainer">
                                <input type="text" id="lastTimeTeam2ComboboxInput" class="combobox-input" placeholder="Select Team 2" autocomplete="off">
                                <span class="combobox-arrow">‚ñº</span>
                                <div class="combobox-dropdown" id="lastTimeTeam2ComboboxDropdown"></div>
                            </div>
                            <select id="lastTimeTeam2Select" class="form-input" style="display: none;">
                                <option value="">Select Team 2</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Results Display -->
                    <div id="lastTimeResults" class="hidden">
                        <h3 class="text-xl font-bold text-gray-700 mb-6 text-center">Days Since Last Match Results</h3>
                        
                        <!-- Team 1 Won at Home -->
                        <div id="team1HomeWinSection" class="mb-8 hidden">
                            <h4 id="team1HomeWinTitle" class="text-lg font-semibold text-green-700 mb-3">Team 1 Won (at Home)</h4>
                            <div class="league-table">
                                <table>
                                    <thead>
                                        <tr id="team1HomeWinHeader">
                                            <th class="px-3 py-4 text-center font-bold text-sm">Date</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Home Team</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Home Score</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Away Team</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Away Score</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Result</th>
                                        </tr>
                                    </thead>
                                    <tbody id="team1HomeWinBody"></tbody>
                                </table>
                            </div>
                            <p id="team1HomeWinDays" class="text-center text-sm text-gray-600 mt-2"></p>
                        </div>

                        <!-- Team 1 Won Away -->
                        <div id="team1AwayWinSection" class="mb-8 hidden">
                            <h4 id="team1AwayWinTitle" class="text-lg font-semibold text-green-700 mb-3">Team 1 Won (Away)</h4>
                            <div class="league-table">
                                <table>
                                    <thead>
                                        <tr id="team1AwayWinHeader">
                                            <th class="px-3 py-4 text-center font-bold text-sm">Date</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Home Team</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Home Score</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Away Team</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Away Score</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Result</th>
                                        </tr>
                                    </thead>
                                    <tbody id="team1AwayWinBody"></tbody>
                                </table>
                            </div>
                            <p id="team1AwayWinDays" class="text-center text-sm text-gray-600 mt-2"></p>
                        </div>

                        <!-- Team 1 Drew at Home -->
                        <div id="team1HomeDrawSection" class="mb-8 hidden">
                            <h4 id="team1HomeDrawTitle" class="text-lg font-semibold text-gray-600 mb-3">Team 1 Drew (at Home)</h4>
                            <div class="league-table">
                                <table>
                                    <thead>
                                        <tr id="team1HomeDrawHeader">
                                            <th class="px-3 py-4 text-center font-bold text-sm">Date</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Home Team</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Home Score</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Away Team</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Away Score</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Result</th>
                                        </tr>
                                    </thead>
                                    <tbody id="team1HomeDrawBody"></tbody>
                                </table>
                            </div>
                            <p id="team1HomeDrawDays" class="text-center text-sm text-gray-600 mt-2"></p>
                        </div>

                        <!-- Team 1 Drew Away -->
                        <div id="team1AwayDrawSection" class="mb-8 hidden">
                            <h4 id="team1AwayDrawTitle" class="text-lg font-semibold text-gray-600 mb-3">Team 1 Drew (Away)</h4>
                            <div class="league-table">
                                <table>
                                    <thead>
                                        <tr id="team1AwayDrawHeader">
                                            <th class="px-3 py-4 text-center font-bold text-sm">Date</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Home Team</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Home Score</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Away Team</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Away Score</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Result</th>
                                        </tr>
                                    </thead>
                                    <tbody id="team1AwayDrawBody"></tbody>
                                </table>
                            </div>
                            <p id="team1AwayDrawDays" class="text-center text-sm text-gray-600 mt-2"></p>
                        </div>

                        <!-- Team 1 Lost at Home -->
                        <div id="team1HomeLossSection" class="mb-8 hidden">
                            <h4 id="team1HomeLossTitle" class="text-lg font-semibold text-red-600 mb-3">Team 1 Lost (at Home)</h4>
                            <div class="league-table">
                                <table>
                                    <thead>
                                        <tr id="team1HomeLossHeader">
                                            <th class="px-3 py-4 text-center font-bold text-sm">Date</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Home Team</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Home Score</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Away Team</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Away Score</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Result</th>
                                        </tr>
                                    </thead>
                                    <tbody id="team1HomeLossBody"></tbody>
                                </table>
                            </div>
                            <p id="team1HomeLossDays" class="text-center text-sm text-gray-600 mt-2"></p>
                        </div>

                        <!-- Team 1 Lost Away -->
                        <div id="team1AwayLossSection" class="mb-8 hidden">
                            <h4 id="team1AwayLossTitle" class="text-lg font-semibold text-red-600 mb-3">Team 1 Lost (Away)</h4>
                            <div class="league-table">
                                <table>
                                    <thead>
                                        <tr id="team1AwayLossHeader">
                                            <th class="px-3 py-4 text-center font-bold text-sm">Date</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Home Team</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Home Score</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Away Team</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Away Score</th>
                                            <th class="px-3 py-4 text-center font-bold text-sm">Result</th>
                                        </tr>
                                    </thead>
                                    <tbody id="team1AwayLossBody"></tbody>
                                </table>
                            </div>
                            <p id="team1AwayLossDays" class="text-center text-sm text-gray-600 mt-2"></p>
                        </div>
                    </div>
                </div>

                <!-- Team Streaks Tab Content -->
                <div id="teamStreaksContent" class="tab-content">
                    <!-- Description -->
                    <div class="mb-6 p-4 border border-gray-200 rounded-lg collapsible-control">
                        <p class="text-gray-700 text-sm leading-relaxed">
                            Discover active streaks between clubs and find out the last time your club defeated their rival. Filter between league, location, and streak type.
                        </p>
                    </div>

                    <!-- League Selection -->
                    <div class="mb-8 collapsible-control">
                        <label class="block text-sm font-semibold text-gray-700 mb-4">Select Competition:</label>
                        <div class="league-buttons" id="teamStreaksLeagueButtons">
                            <!-- League buttons will be populated here -->
                        </div>
                    </div>

                    <!-- Stage Selection -->
                    <div class="mb-8 collapsible-control">
                        <label class="block text-sm font-semibold text-gray-700 mb-2">Competition Stage:</label>
                        <select id="teamStreaksStageSelect" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-green-500 focus:outline-none">
                            <option value="">All</option>
                            <option value="League/Group Stage">League/Group Stage</option>
                            <option value="Knock-Out Stage">Knock-Out Stage</option>
                            <option value="Final">Final</option>
                            <option value="Semi-Finals">Semi-Finals</option>
                            <option value="Quarter-Finals">Quarter-Finals</option>
                            <option value="Round Of 16">Round Of 16</option>
                            <option value="Play-Offs">Play-Offs</option>
                            <option value="2. Round">2. Round</option>
                            <option value="1. Round">1. Round</option>
                        </select>
                    </div>

                    <!-- Status Selection -->
                    <div class="mb-8 collapsible-control">
                        <label class="block text-sm font-semibold text-gray-700 mb-2">Status:</label>
                        <select id="teamStreaksStatusSelect" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-green-500 focus:outline-none">
                            <option value="active">Active Streak</option>
                            <option value="historic">Historic Streaks</option>
                        </select>
                    </div>
                    <!-- Location Selection -->
                    <div class="mb-8 collapsible-control">
                        <label class="block text-sm font-semibold text-gray-700 mb-2">Location:</label>
                        <select id="teamStreaksLocationSelect" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-green-500 focus:outline-none">
                            <option value="both">Both Home and Away</option>
                            <option value="home">Home</option>
                            <option value="away">Away</option>
                        </select>
                    </div>

                    <!-- Streak Type Selection -->
                    <div class="mb-8 collapsible-control">
                        <label class="block text-sm font-semibold text-gray-700 mb-2">Streak Type:</label>
                        <select id="teamStreaksTypeSelect" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-green-500 focus:outline-none">
                            <option value="winning">Winning Streak (Wins Only)</option>
                            <option value="unbeaten">Unbeaten Streak (Wins + Draws)</option>
                            <option value="draw">Draw Streak (Draws Only)</option>
                            <option value="winless">Winless Streak (Draws + Losses)</option>
                            <option value="losing">Losing Streak (Losses Only)</option>
                        </select>
                    </div>

                    <!-- Team Selection -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8 collapsible-control">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">Team 1:</label>
                            <div class="combobox-container" id="teamStreaksTeam1ComboboxContainer">
                                <input type="text" id="teamStreaksTeam1ComboboxInput" class="combobox-input" placeholder="Select Team 1" autocomplete="off">
                                <span class="combobox-arrow">‚ñº</span>
                                <div class="combobox-dropdown" id="teamStreaksTeam1ComboboxDropdown"></div>
                            </div>
                            <select id="teamStreaksTeam1Select" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-green-500 focus:outline-none" style="display: none;">
                                <option value="">Select Team 1</option>
                            </select>
                        </div>

                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">Team 2 (Optional):</label>
                            <div class="combobox-container" id="teamStreaksTeam2ComboboxContainer">
                                <input type="text" id="teamStreaksTeam2ComboboxInput" class="combobox-input" placeholder="Select Team 2" autocomplete="off">
                                <span class="combobox-arrow">‚ñº</span>
                                <div class="combobox-dropdown" id="teamStreaksTeam2ComboboxDropdown"></div>
                            </div>
                            <select id="teamStreaksTeam2Select" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-green-500 focus:outline-none" style="display: none;">
                                <option value="">Select Team 2</option>
                            </select>
                        </div>
                    </div>

                    <!-- Results will be populated here -->
                    <div id="teamStreaksResults" class="hidden">
                        <!-- Team streaks content will be populated here -->
                    </div>
                </div>
            </div>

            <!-- Table Info -->
            <div id="tableInfo" class="text-center py-4 bg-white border-b hidden">
                <span class="text-lg font-semibold text-gray-700" id="tableInfoText"></span>
            </div>

            <!-- Head-to-Head Section -->
            <div id="h2hSection" class="mt-8 mx-8 p-8 bg-white border-b rounded-xl hidden">
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center gap-6">
                        <h3 class="text-lg font-semibold text-gray-700">Head-to-Head Record</h3>

                        <label class="flex items-center cursor-pointer">
                            <div id="h2hHomeCheckbox" class="checkbox checked"></div>
                            <span class="icon-home mr-1"></span>
                            <span class="text-sm font-medium">Home</span>
                        </label>

                        <label class="flex items-center cursor-pointer">
                            <div id="h2hAwayCheckbox" class="checkbox checked"></div>
                            <span class="icon-plane mr-1"></span>
                            <span class="text-sm font-medium">Away</span>
                        </label>

                        <label class="flex items-center cursor-pointer">
                            <div id="h2hPenaltyCheckbox" class="checkbox"></div>
                            <span class="mr-1">‚öΩ</span>
                            <span class="text-sm font-medium">Penalty Shootouts</span>
                        </label>
                    </div>
                    <div class="flex items-center gap-4">
                        <label class="text-sm font-medium text-gray-700">Competition Stage</label>
                        <select id="h2hStageSelect" class="px-3 py-1 border border-gray-300 rounded focus:border-green-500 focus:outline-none text-sm">
                            <option value="">All</option>
                            <option value="League/Group Stage">League/Group Stage</option>
                            <option value="Knock-Out Stage">Knock-Out Stage</option>
                            <option value="Final">Final</option>
                            <option value="Semi-Finals">Semi-Finals</option>
                            <option value="Quarter-Finals">Quarter-Finals</option>
                            <option value="Round Of 16">Round Of 16</option>
                            <option value="Play-Offs">Play-Offs</option>
                            <option value="2. Round">2. Round</option>
                            <option value="1. Round">1. Round</option>
                        </select>
                        <span class="text-sm text-gray-600" id="h2hMatchCount"></span>
                    </div>
                </div>
                <div class="flex flex-col sm:flex-row sm:items-center sm:justify-end mb-4 gap-2">
                    <label class="text-sm font-medium text-gray-700">Most Recent Head-to-Head</label>
                    <input type="text" id="recentH2HSelect" placeholder="Enter number or 'All'" class="px-2 py-1 border border-gray-300 rounded-full focus:border-green-500 focus:outline-none text-xs w-32 text-center">
                </div>
                <div id="h2hVisualizations">
                    <!-- H2H visualizations will be populated here -->
                </div>
            </div>
            
            <!-- Table Section -->
            <div class="table-section">

                <div id="errorState" class="text-center text-black hidden">
                    <div class="icon-loading w-16 h-16 mx-auto mb-4" style="font-size: 4rem;"></div>
                    <div class="text-2xl mb-4">Loading Data</div>
                    <div class="text-lg mb-6 text-black" id="errorMessage"></div>
                    <button id="retryBtn" class="px-6 py-3 bg-white bg-opacity-20 hover:bg-opacity-30 rounded-lg transition-all">
                        Try Again
                    </button>
                </div>

                <div id="tableContainer" class="hidden">
                    <div class="league-table">
                        <table>
                            <thead>
                                <tr id="tableHeader">
                                    <!-- Headers will be populated -->
                                </tr>
                            </thead>
                            <tbody id="tableBody">
                                <!-- Rows will be populated -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Head-to-Head Matches Table -->
                <div id="h2hMatchesTable" class="mt-8 hidden">
                    <div class="league-table">
                        <div class="text-center py-4 bg-white border-b">
                            <h2 class="text-xl font-semibold text-gray-700 mb-1">Head-to-Head Match History</h2>
                            <p class="text-sm text-gray-600" id="h2hTableTitle"></p>
                        </div>
                        <table>
                            <thead>
                                <tr id="h2hTableHeader">
                                    <!-- H2H headers will be populated -->
                                </tr>
                            </thead>
                            <tbody id="h2hTableBody">
                                <!-- H2H rows will be populated -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Match History Section (Single Team) -->
                <div id="matchHistorySection" class="mt-8 mx-8 p-8 bg-white border-b rounded-xl hidden">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center gap-6">
                            <h3 class="text-lg font-semibold text-gray-700">Match History</h3>
                            
                            <label class="flex items-center cursor-pointer">
                                <div id="matchHistoryHomeCheckbox" class="checkbox checked"></div>
                                <span class="icon-home mr-1"></span>
                                <span class="text-sm font-medium">Home</span>
                            </label>
                            
                            <label class="flex items-center cursor-pointer">
                                <div id="matchHistoryAwayCheckbox" class="checkbox checked"></div>
                                <span class="icon-plane mr-1"></span>
                                <span class="text-sm font-medium">Away</span>
                            </label>
                            
                            <label class="flex items-center cursor-pointer">
                                <div id="matchHistoryPenaltyCheckbox" class="checkbox"></div>
                                <span class="mr-1">‚öΩ</span>
                                <span class="text-sm font-medium">Penalty Shootouts</span>
                            </label>
                        </div>
                        <div class="flex items-center gap-4">
                            <label class="text-sm font-medium text-gray-700">Competition Stage</label>
                            <select id="matchHistoryStageSelect" class="px-3 py-1 border border-gray-300 rounded focus:border-green-500 focus:outline-none text-sm">
                                <option value="">All</option>
                                <option value="League/Group Stage">League/Group Stage</option>
                                <option value="Knock-Out Stage">Knock-Out Stage</option>
                                <option value="Final">Final</option>
                                <option value="Semi-Finals">Semi-Finals</option>
                                <option value="Quarter-Finals">Quarter-Finals</option>
                                <option value="Round Of 16">Round Of 16</option>
                                <option value="Play-Offs">Play-Offs</option>
                                <option value="2. Round">2. Round</option>
                                <option value="1. Round">1. Round</option>
                            </select>
                            <span class="text-sm text-gray-600" id="matchHistoryMatchCount"></span>
                        </div>
                    </div>
                    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-end mb-4 gap-2">
                        <label class="text-sm font-medium text-gray-700">Most Recent Matches</label>
                        <input type="text" id="recentMatchesSelect" placeholder="Enter number or 'All'" class="px-2 py-1 border border-gray-300 rounded-full focus:border-green-500 focus:outline-none text-xs w-32 text-center">
                    </div>
                    <div id="matchHistoryVisualizations" class="mb-8">
                        <!-- Team Record visualizations will be populated here -->
                    </div>
                    <div id="matchHistoryTable" class="mt-4">
                        <div class="league-table">
                            <div class="text-center py-4 bg-white border-b">
                                <h2 class="text-xl font-semibold text-gray-700 mb-1">Match History</h2>
                                <p class="text-sm text-gray-600" id="matchHistoryTableTitle"></p>
                            </div>
                            <table>
                                <thead>
                                    <tr id="matchHistoryTableHeader">
                                        <!-- Headers will be populated -->
                                    </tr>
                                </thead>
                                <tbody id="matchHistoryTableBody">
                                    <!-- Rows will be populated -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <script>
        // Pre-configured Gist URLs (Single Base64 Encoded)
        // Updated GIST URLs with single base64 encoding (encoded with new user-provided URLs)
        // Main Champions League data URLs
        const MAIN_GIST_URLS = [
            'aHR0cHM6Ly9naXN0LmdpdGh1YnVzZXJjb250ZW50LmNvbS81Uy01Uy82MWI1NzlmYTljMzM5MzNmYjRiNzg3YzZhOWQzODhlYy9yYXcvNGJkNTM0ZjA2OWFjNGZlNmEwMzljM2MzZTE2OGQyMjliYTRiMmY2MS9jaGFtcGlvbnNsZWFndWUuY3N2',
            'aHR0cHM6Ly9naXN0LmdpdGh1YnVzZXJjb250ZW50LmNvbS81Uy01Uy9iMWU1NTcwZTk4NWQ3ZmNhNGRlYWJjYzhhMDA0ZTllMC9yYXcvYmY0Y2UyNzIwNjk5NThlM2E3OWQzM2RjNjA0NDE3NTAyOTAzY2MyMy9jaGFtcGlvbnNsZWFndWUyNTI2LmNzdg=='
        ];
        
        // Qualifier data URLs
        const QUALIFIER_GIST_URLS = [
            'aHR0cHM6Ly9naXN0LmdpdGh1YnVzZXJjb250ZW50LmNvbS81Uy01Uy9iYmMyMGMzMmQyNWNjZGMwZmVkZjI1YmM4N2Q0NDY2ZS9yYXcvOWE2ZWNjYTdjOGRiY2UyMTA4MGYzOGFhMTM2MDI2MTU0OTZhZGFmNy9jbHF1YWxpZmllcnMuY3N2'
        ];
        
        // Combined URLs for loading
        const GIST_URLS = [...MAIN_GIST_URLS, ...QUALIFIER_GIST_URLS];
        
        // League code mapping for filtering data
        const LEAGUE_CODES = {
            'champions-league': 'C1',
            'europa-league': 'E1',
            'conference-league': 'C2'
        };
        
        // Function to identify if a match is from qualifier data
        function isQualifierMatch(row, sourceUrl) {
            // Check if the data came from a qualifier URL
            return QUALIFIER_GIST_URLS.some(url => sourceUrl === url);
        }
        
        // Function to process qualifier matches by adding "Qualification " prefix
        function processQualifierData(data, sourceUrl) {
            if (isQualifierMatch(data[0], sourceUrl)) {
                return data.map(row => ({
                    ...row,
                    CompetitionPhase: row.CompetitionPhase ? `Qualification ${row.CompetitionPhase}` : 'Qualification',
                    isQualifier: true
                }));
            }
            return data.map(row => ({ ...row, isQualifier: false }));
        }

        // Application state
        const state = {
            data: [],
            teams: [],
            error: '',
            
            // Filter states
            dateFrom: '',
            dateTo: '',
            selectedDayOfWeek: '',
            selectedTeam1: '',
            selectedTeam2: '',
            selectedSeason: '',
            competitionStage: '',
            homeFilter: true,
            awayFilter: true,
            pointDeductionsEnabled: true,
            threePointSystem: true,
            excludeQualifiers: false,
            excludeMainStage: false,
            selectedLeague: 'champions-league',
            selectedSeason: 'all-european-cup-seasons-1955-2025',
            sortConfig: { key: null, direction: null },
            teamHistorySortConfig: { key: null, direction: null },
            recentH2HCount: 'All',
            h2hStage: '',
            matchHistoryStage: '',
            matchHistoryHomeFilter: true,
            matchHistoryAwayFilter: true,
            matchHistoryPenaltyFilter: false,
            recentMatchesCount: 'All',
            matchHistorySortConfig: { key: null, direction: null },
            h2hPenaltyFilter: false,
            
            // H2H sort config
            h2hSortConfig: { key: 'date', direction: 'desc' },
            
            // Last Time When state
            lastTimeTeam1: '',
            lastTimeTeam2: '',
            lastTimeDayOfWeek: '',
            lastTimeLocation: '',
            lastTimeStage: '',
            
            // Team Seasons state
            teamSeasonsSelectedLeague: 'serie-a',
            teamSeasonsSelectedTeam: '',
            teamSeasonsSelectedSeason: '',
            teamSeasonsSelectedPosition: '',
            includeBetterResults: false,
            controlsCollapsed: false,

            // Previous League Tables state (for back navigation)
            previousLeagueTablesState: null,
            
            // Team Streaks state
            teamStreaksStage: '',
            
            // Historic Streaks sort state
            historicStreaksSortConfig: { key: null, direction: null },
            lastHistoricStreaksParams: null
        };

        // Ranking overrides for historic seasons
        function getRankingOverrides() {
            return [
                // Italy
                ["Pro Vercelli", "I1", "1930-31", 10, 1],

                // Germany
                ["1. FC K√∂ln", "D1", "1968-69", 13],

                // Spain
                ["Girona FC", "SP1", "2024-25", 16],

                // England
                ["Liverpool FC", "E0", "1974-75", 2],

                // France
                // Add ranking overrides here as needed
                ["FC Metz", "F1", "2023-24", 16]


            ];
        }

        // Apply ranking overrides for historic seasons
        function applyRankingOverrides(tableArray, selectedLeague, selectedSeason) {
            // Only apply overrides for historic season filters
            if (!selectedSeason) return tableArray;
            
            const leagueMapping = {
                'champions-league': 'C1',
                'europa-league': 'E1',
                'conference-league': 'C2'
            };
            
            const selectedDiv = leagueMapping[selectedLeague];
            const overrides = getRankingOverrides().filter(override => 
                override[1] === selectedDiv && override[2] === selectedSeason
            );
            
            if (overrides.length === 0) return tableArray;
            
            // Create a copy of the array to work with
            let result = [...tableArray];
            
            // Separate teams with overrides from those without
            const teamsWithOverrides = [];
            const teamsWithoutOverrides = [];
            
            overrides.forEach(override => {
                const [teamName, , , overridePosition, subOrder] = override;
                const teamIndex = result.findIndex(team => team.team === teamName);
                if (teamIndex !== -1) {
                    const team = result[teamIndex];
                    team.sharedPosition = parseInt(overridePosition);
                    team.subOrder = subOrder || 1;
                    teamsWithOverrides.push(team);
                }
            });
            
            // Get teams without overrides
            result.forEach(team => {
                const hasOverride = teamsWithOverrides.some(overrideTeam => overrideTeam.team === team.team);
                if (!hasOverride) {
                    teamsWithoutOverrides.push(team);
                }
            });
            
            // Sort teams with overrides by position, then by sub-order
            teamsWithOverrides.sort((a, b) => {
                if (a.sharedPosition !== b.sharedPosition) return a.sharedPosition - b.sharedPosition;
                return a.subOrder - b.subOrder;
            });
            
            // Build final result by filling positions
            const finalResult = [];
            const overridePositions = new Set(teamsWithOverrides.map(t => t.sharedPosition));
            
            let nonOverrideIndex = 0;
            for (let position = 1; position <= tableArray.length; position++) {
                if (overridePositions.has(position)) {
                    // Fill with override teams at this position
                    const overrideTeamsAtThisPosition = teamsWithOverrides.filter(t => t.sharedPosition === position);
                    finalResult.push(...overrideTeamsAtThisPosition);
                } else {
                    // Fill with next non-override team
                    if (nonOverrideIndex < teamsWithoutOverrides.length) {
                        finalResult.push(teamsWithoutOverrides[nonOverrideIndex]);
                        nonOverrideIndex++;
                    }
                }
            }
            
            return finalResult;
        }

        // Team colors for head-to-head visualizations
        function getTeamColors() {
            return {
                // Premier League
                'premier-league': [
                    ['Liverpool FC', '#D10022', 550],                    
                    ['Arsenal FC', '#EF0107', 555],
                    ['Everton FC', '#0052CC', 560],                    
                    ['Manchester United', '#D9020D', 543],
                    ['Aston Villa', '#670E36', 559],
                    ['Manchester City', '#84BBFF', 750],
                    ['Chelsea FC', '#004793', 544],
                    ['Tottenham Hotspur', '#001C58', 552],
                    ['Newcastle United', '#000000', 546],
                    ['Sunderland AFC', '#EB172C', 547],
                    ['West Bromwich Albion', '#000080', 748],
                    ['Wolverhampton Wanderers', '#FDB913', 749],
                    ['Blackburn Rovers', '#009ee0', 557],
                    ['Bolton Wanderers', '#263c7e', 554],
                    ['Sheffield Wednesday', '#4681cf', 745],
                    ['West Ham United', '#660033', 553],
                    ['Derby County', '#000000', 542],
                    ['Sheffield United', '#EC2227', 2309], 
                    ['Leeds United', '#FFE100', 541],
                    ['Burnley FC', '#660808', 3185],                    
                    ['Nottingham Forest', '#C8102E', 743],
                    ['Middlesbrough FC', '#FF0000', 548],
                    ['Stoke City', '#FF0033', 2807],
                    ['Leicester City', '#0053A0', 549],
                    ['Birmingham City', '#0000FF', 2244],
                    ['Preston North End', '#002156', 2249],     
                    ['Southampton FC', '#FF0033', 545],
                    ['Huddersfield Town', '#0072CE', 3017],                    
                    ['Portsmouth FC', '#0754ED', 2220],
                    ['Coventry City', '#059DD9', 2240],
                    ['Blackpool FC', '#FF8C00', 2873],
                    ['Ipswich Town', '#3a64a3', 556],
                    ['Fulham FC', '#000000', 558],
                    ['Charlton Athletic', '#D6011D', 551],
                    ['Notts County', '#000000', 3106],
                    ['Norwich City', '#009900', 744],
                    ['Queens Park Rangers', '#0066FF', 746],
                    ['Crystal Palace', '#1B458F', 2242],
                    ['Bury FC', '#032AF0', 2238],
                    ['Cardiff City', '#0070B5', 3182],
                    ['Luton Town', '#2E1C94', 3123],
                    ['Wimbledon FC', '#0000FF', 37530],
                    ['Watford FC', '#FFF71C', 747],
                    ['Oldham Athletic', '#004A97', 2897],
                    ['Grimsby Town', '#000000', 3180],
                    ['Bradford City', '#990033', 2241],
                    ['Brighton & Hove Albion', '#0054A6', 3050],
                    ['Brentford FC', '#FF0000', 3271],
                    ['Bristol City', '#E21A23', 3277],
                    ['Swansea City', '#000000', 3183],
                    ['AFC Bournemouth', '#BF0C10', 2248],
                    ['Wigan Athletic', '#1d59af', 3116],
                    ['Hull City', '#F5A12D', 3111],
                    ['Bradford Park Avenue', '#FB090B', 4195],
                    ['Accrington FC', '#FF0000', 0],
                    ['Reading FC', '#0000FF', 3285],
                    ['Oxford United', '#FFFF00', 3272],
                    ['Millwall FC', '#00194A', 2250],
                    ['Northampton Town', '#990000', 3184],
                    ['Carlisle United', '#1F47BF', 3118],
                    ['Darwen', '#FF0000', 4245],
                    ['Barnsley FC', '#D71921', 3181],
                    ['Swindon Town', '#FF0000', 2237],
                    ['Leyton Orient', '#FF0000', 3121],
                    ['Glossop North End', '#002156', 4243]
                ],
                
                // Serie A
                'serie-a': [
                    ['Juventus', '#000000', 511],
                    ['Inter', '#010E80', 507],
                    ['AC Milan', '#FB090B', 514],
                    ['AS Roma', '#8E1F2F', 520],
                    ['ACF Fiorentina', '#482E92', 3021],
                    ['Lazio Roma', '#87D8F7', 505],
                    ['SSC Napoli', '#12A0D7', 732],
                    ['Torino FC', '#8A1E03', 734],
                    ['Bologna FC', '#1A2F48', 503],
                    ['Sampdoria', '#1B5497', 731],
                    ['Atalanta', '#1E71B8', 504],
                    ['Udinese Calcio', '#000000', 517],
                    ['Genoa CFC', '#05232F', 735],
                    ['Cagliari Calcio', '#002350', 733],
                    ['Parma Calcio 1913', '#1B4094', 516],
                    ['Hellas Verona', '#FFE74A', 519],
                    ['Palermo FC', '#F7B7D3', 2831],
                    ['L.R. Vicenza', '#FF0003', 2219],
                    ['SSC Bari', '#F03030', 2734],
                    ['US Triestina', '#FF0000', 2837],
                    ['Brescia Calcio', '#007FFF', 513],
                    ['Chievo Verona', '#F0F027', 510],
                    ['SPAL 2013 Ferrara', '#0470C2', 2833],
                    ['AS Livorno', '#853138', 2841],
                    ['Calcio Padova', '#FF0000', 2821],
                    ['Calcio Catania', '#E03636', 2826],
                    ['US Lecce', '#E80000', 515],
                    ['Empoli FC', '#175EEB', 2729],
                    ['Ascoli Calcio', '#030000', 2757],
                    ['US Alessandria 1912', '#808080', 2836],
                    ['Modena FC', '#1616CC', 2727],
                    ['Sassuolo Calcio', '#099902', 5843],
                    ['AC Perugia', '#D91515', 508],
                    ['Como 1907', '#007FFF', 2726],
                    ['Novara Calcio', '#007FFF', 2839],
                    ['Aurora Pro Patria', '#122AFF', 2838],
                    ['Venezia FC', '#FF8000', 512],
                    ['Foggia Calcio', '#BD0B0B', 2211],
                    ['Cesena FC', '#080808', 2824],
                    ['ACN Siena 1904', '#000000', 2843],
                    ['Reggina 1914', '#6B1111', 2728],
                    ['US Avellino', '#0C6912', 2825],
                    ['Lucchese', '#D13636', 2740],
                    ['Piacenza Calcio', '#FF0000', 506],
                    ['Pro Vercelli', '#000000', 2848],
                    ['US Cremonese', '#FF0000', 2822],
                    ['Mantova 1911 SSD', '#FF0000', 2832],
                    ['Pisa SC', '#100778', 2210],
                    ['US Catanzaro', '#FFE226', 2827],
                    ['AS Varese 1910', '#FF0000', 2830],
                    ['US Salernitana 1919', '#831D1C', 2820],
                    ['AC Liguria', '#FB090B', 0],
                    ['ACR Messina', '#C70808', 2834],
                    ['Delfino Pescara', '#59A9E6', 2823],
                    ['Casale', '#030303', 2849],
                    ['AC Monza', '#FF0000', 3012],
                    ['Spezia Calcio', '#6C93BA', 3128],
                    ['Sampierdarenese', '#515EE8', 2845],
                    ['Calcio Lecco 1912', '#0E0EC7', 2835],
                    ['FC Crotone', '#D43333', 3980],
                    ['Frosinone Calcio', '#FFDD00', 5633],
                    ['AC Reggiana', '#821D1C', 2789],
                    ['Legnano', '#C1C4E0', 2840],
                    ['Benevento Calcio', '#F0CA0E', 4180],
                    ['Ternana Calcio', '#E01D1D', 2829],
                    ['AC Carpi', '#DE1616', 4820],
                    ['AC Ancona', '#FB090B', 2262],
                    ['US Pistoiese', '#BD6615', 2828],
                    ['ACD Treviso', '#D4EFFC', 5225]
                ],
                
                // La Liga
                'la-liga': [
                    ['Real Madrid', '#FEBE10', 532],
                    ['FC Barcelona', '#A60042', 530],
                    ['Atl√©tico Madrid', '#212B61', 737],
                    ['Athletic Club', '#FF0000', 528],
                    ['Valencia CF', '#000000', 531],
                    ['Sevilla FC', '#FF0000', 529],
                    ['Espanyol Barcelona', '#007FC8', 525],
                    ['Real Sociedad', '#0000FF', 527],
                    ['Real Betis', '#00954C', 540],
                    ['RC Celta', '#99CCFF', 536],
                    ['Real Zaragoza', '#ff0000', 526],
                    ['Deportivo La Coru√±a', '#57175E', 523],
                    ['Real Valladolid', '#921B88', 524],                    
                    ['CA Osasuna', '#0A346F', 738],
                    ['Sporting Gij√≥n', '#FF0000', 739],
                    ['Racing Santander', '#009900', 2287],
                    ['Real Oviedo', '#0066FF', 2193],
                    ['M√°laga CF', '#3399FF', 539],
                    ['RCD Mallorca', '#FF0000', 521],
                    ['Villarreal CF', '#FFE135', 538],
                    ['UD Las Palmas', '#FFFF00', 522],
                    ['Granada CF', '#FF0000', 3192],
                    ['Rayo Vallecano', '#FF0000', 537],
                    ['Getafe CF', '#0000FF', 3689],
                    ['Elche CF', '#00CC33', 3190],
                    ['CD Alav√©s', '#048FD9', 534],
                    ['H√©rcules CF', '#242EFC', 2870],
                    ['Levante UD', '#0000CC', 2809],
                    ['C√°diz CF', '#FFFF00', 3188],
                    ['CD Tenerife', '#0000FF', 533],
                    ['Real Murcia', '#EB0707', 3140],
                    ['CE Sabadell', '#100DDB', 3191],
                    ['UD Salamanca', '#000000', 3754],
                    ['CD Castell√≥n', '#F6D70D', 3189],
                    ['CD Logro√±√©s', '#FF0000', 2887],
                    ['Burgos CF', '#000000', 3015],
                    ['C√≥rdoba CF', '#009933', 3078],
                    ['Albacete', '#000000', 2394],
                    ['UD Almer√≠a', '#EE1119', 3194],
                    ['SD Eibar', '#E01212', 3569],
                    ['Girona FC', '#FF0000', 5264],
                    ['Pontevedra CF', '#FF0000', 3193],
                    ['SD Compostela', '#66CCFF', 2731],
                    ['CD Legan√©s', '#0000FF', 3668],
                    ['Recreativo Huelva', '#205081', 2448],
                    ['Arenas de Getxo', '#000000', 742],
                    ['CD Numancia', '#FF0000', 2308],
                    ['Gimn√†stic de Tarragona', '#DD2430', 3199],
                    ['CD Alcoyano', '#2596BE', 6336],
                    ['Real Ja√©n', '#9900CC', 2776],
                    ['CF Extremadura', '#800000', 2305],
                    ['M√©rida AD', '#000000', 3186],
                    ['Real Uni√≥n', '#000000', 741],
                    ['AD Almer√≠a', '#EE1119', 0],
                    ['SD Huesca', '#CF122D', 9659],
                    ['CE Europa', '#2596BE', 3200],
                    ['Lleida Esportiu', '#76B5C5', 3112],
                    ['Xerez CD', '#0033FF', 2813],
                    ['CD Condal', '#1E81B0', 3195],
                    ['Atl√©tico Tetu√°n', '#FF0000', 3197],
                    ['Cultural Leonesa', '#FF0000', 3196]
                ],
                
                // Bundesliga
                'bundesliga': [
                    ['Bayern M√ºnchen', '#DB072D', 222],
                    ['Borussia Dortmund', '#FDE100', 210],
                    ['Werder Bremen', '#00924A', 202],
                    ['VfB Stuttgart', '#FF0000', 215],
                    ['Bor. M√∂nchengladbach', '#000000', 221],
                    ['Hamburger SV', '#014495', 211],
                    ['Eintracht Frankfurt', '#FF0000', 205],
                    ['FC Schalke 04', '#025FAC', 206],
                    ['Bayer Leverkusen', '#FF0000', 236],
                    ['1. FC K√∂ln', '#ED1C23', 213],
                    ['1. FC Kaiserslautern', '#F50505', 214],
                    ['Hertha BSC', '#004CFF', 209],
                    ['VfL Bochum', '#2B579E', 229],
                    ['VfL Wolfsburg', '#0C4011', 246],
                    ['1. FC N√ºrnberg', '#990000', 212],                    
                    ['Hannover 96', '#009932', 218],
                    ['MSV Duisburg', '#3C4E99', 216],
                    ['SC Freiburg', '#FF0000', 245],
                    ['Fortuna D√ºsseldorf', '#FF0000', 223],
                    ['Karlsruher SC', '#0033CC', 208],
                    ['Eintracht Braunschweig', '#025FAC', 217],
                    ['TSV 1860 M√ºnchen', '#5D9AF5', 204],
                    ['1. FSV Mainz 05', '#FF0000', 337],
                    ['1899 Hoffenheim', '#0033CC', 442],
                    ['Arminia Bielefeld', '#0000FF', 228],
                    ['RB Leipzig', '#DD0741', 13247],
                    ['FC Augsburg', '#BB3532', 342],
                    ['KFC Uerdingen 05', '#004FED', 233],
                    ['Hansa Rostock', '#0033CC', 243],
                    ['FC St. Pauli', '#8B4513', 234],
                    ['1. FC Union Berlin', '#E40019', 330],
                    ['Waldhof Mannheim', '#004292', 338],
                    ['Kickers Offenbach', '#FF0000', 226],
                    ['Rot-Weiss Essen', '#FF0000', 224],
                    ['Energie Cottbus', '#FF0000', 249],
                    ['Alemannia Aachen', '#FFFF00', 225],
                    ['SG Wattenscheid 09', '#000000', 241],
                    ['1. FC Saarbr√ºcken', '#0033FF', 203],
                    ['Dynamo Dresden', '#FFFF00', 242],
                    ['Rot-Wei√ü Oberhausen', '#E72D33', 336],
                    ['SV Darmstadt 98', '#6796C6', 235],
                    ['Wuppertaler SV', '#FF0000', 230],
                    ['Borussia Neunkirchen', '#000000', 219],
                    ['FC 08 Homburg', '#0C4011', 238],
                    ['SpVgg Unterhaching', '#BA1111', 248],
                    ['Stuttgarter Kickers', '#0BB1DB', 240],
                    ['FC Ingolstadt 04', '#FF0000', 4856],
                    ['1. FC Heidenheim 1846', '#003B79', 4497],
                    ['SC Paderborn 07', '#2B429C', 422],
                    ['TeBe Berlin', '#5B1A73', 356],
                    ['SpVgg Greuther F√ºrth', '#009933', 331],
                    ['SSV Ulm 1846', '#1F1D1D', 368],
                    ['Fortuna K√∂ln', '#E80000', 231],
                    ['Preu√üen M√ºnster', '#000000', 207],
                    ['Holstein Kiel', '#0F5787', 385],
                    ['Blau-Wei√ü 90 Berlin', '#1709DB', 239],
                    ['1. FC Lok Leipzig', '#1F357F', 244],
                    ['SV Tasmania Berlin', '#0000FF', 688]
                ],
                
                // Ligue 1
                'ligue-1': [
                    ['Olympique Marseille', '#099FFF', 576],
                    ['AS Monaco', '#FF0000', 562],
                    ['Girondins Bordeaux', '#000979', 565],
                    ['AS Saint-√âtienne', '#40B848', 757],
                    ['Olympique Lyonnais', '#003781', 567],
                    ['Lille OSC', '#F20505', 577],
                    ['Paris Saint-Germain', '#00093F', 563],
                    ['OGC Nice', '#ED1C24', 774],
                    ['Stade Rennais', '#E13327', 570],
                    ['FC Nantes', '#FCD405', 574],
                    ['FC Sochaux', '#034A97', 564],
                    ['RC Lens', '#FFDF00', 568],
                    ['RC Strasbourg', '#009FE3', 752],
                    ['FC Metz', '#6E0F12', 569],
                    ['Stade de Reims', '#EE2223', 776],
                    ['Montpellier HSC', '#344575', 572],
                    ['AJ Auxerre', '#1C4F9C', 571],   
                    ['Toulouse FC', '#8D42D4', 755],  
                    ['N√Æmes Olympique', '#E40613', 784],    
                    ['SC Bastia', '#0053A1', 566],    
                    ['Racing Club de France', '#78ACE4', 772],
                    ['Valenciennes FC', '#D91920', 3036],                    
                    ['Angers SCO', '#000000', 2234],                    
                    ['AS Nancy Lorraine', '#FF0000', 783],
                    ['CS Sedan', '#008006', 578],
                    ['Havre AC', '#11A4D9', 760],
                    ['AS Cannes', '#F4141C', 753],
                    ['FC Rouen 1899', '#FF0000', 773],
                    ['Stade Brestois 29', '#ED1C24', 3306],
                    ['SM Caen', '#26355D', 754],
                    ['FC Lorient', '#F58113', 575],
                    ['Toulouse FC (old)', '#EA0046', 69609],
                    ['SC S√®te', '#2D7A09', 771],
                    ['FC Nancy', '#123163', 9704],
                    ['Stade Fran√ßais', '#EB5195', 769],
                    ['Stade Lavallois', '#EC6608', 756],
                    ['ESTAC Troyes', '#006EB2', 573],
                    ['EA Guingamp', '#ED1C24', 561],
                    ['Red Star FC', '#32D181', 775],
                    ['AC Ajaccio', '#E3272C', 2410],
                    ['SC Toulon', '#FFCC00', 3035],
                    ['CO Roubaix-Tourcoing', '#003781', 779],
                    ['Olympique Lillois Lille', '#FF0000', 768],
                    ['Excelsior Roubaix', '#000000', 3348],
                    ['SC Fives Lille', '#24216A', 4027],
                    ['Le Mans FC', '#BE081A', 3401],
                    ['FC Antibes', '#003781', 7419],
                    ['Dijon FCO', '#D3072A', 5121],
                    ['FC Mulhouse', '#3300FF', 770],
                    ['Thonon √âvian GGFC', '#123163', 5726],
                    ['Tours FC', '#099FFF', 3307],
                    ['Olympique Al√®s', '#003781', 3098],
                    ['Grenoble Foot 38', '#014898', 2236],
                    ['Limoges FC', '#FF0000', 5753],
                    ['Paris FC', '#00093F', 6723],
                    ['Angoul√™me CFC', '#003781', 3995],
                    ['Clermont Foot 63', '#C50C46', 4383],
                    ['FC Martigues', '#FF0000', 2316],
                    ['Amiens SC', '#000000', 3349],
                    ['RC Roubaix (old)', '#000000', 761],
                    ['Troyes AF', '#00A0E4', 69591],
                    ['SC N√Æmes', '#FF0000', 70035],
                    ['Chamois Niortais', '#005CB9', 4130],
                    ['SR Colmar', '#32D181', 7418],
                    ['CA Paris (old)', '#FF0000', 767],
                    ['Lyon OU', '#FF0000', 69513],
                    ['FC Gueugnon', '#FFEE00', 751],
                    ['Gaz√©lec FC Ajaccio', '#FF0000', 4325],
                    ['AS B√©ziers (old)', '#FF0000', 70137],
                    ['FC Istres', '#8D42D4', 3518],
                    ['LB Ch√¢teauroux', '#00458E', 3269],
                    ['US Boulogne', '#E2001A', 9329],
                    ['Avenir Club Avignonnais', '#000000', 6936],
                    ['AS Aix-en-Provence', '#3D84FF', 7416],
                    ['AC Arles-Avignon', '#0033FF', 11030],
                    ['Club Francais Paris', '#FF0000', 759],
                    ['Hy√®res FC', '#9C824A', 7420]
                ],
                
                // Champions League - Additional teams not in domestic leagues
                'champions-league': [
                    ['SL Benfica', '#E83030', 811],
                    ['FC Porto', '#00428C', 808],
                    ['AFC Ajax', '#D2122E', 1426],
                    ['Dinamo Kiev', '#176FC1', 1365],
                    ['PSV Eindhoven', '#F00000', 1425],
                    ['Celtic FC', '#018749', 1287],
                    ['RSC Anderlecht', '#E0AA00', 1229],
                    ['Galatasaray', '#A90432', 795],
                    ['Olympiakos Piraeus', '#D0061F', 1400],
                    ['Crvena Zvezda', '#EB1926', 989],
                    ['Rangers FC', '#1B458F', 1285],
                    ['Shakhtar Donetsk', '#F0612C', 1364],
                    ['Panathinaikos', '#007841', 1399],
                    ['Feyenoord', '#FF0000', 1423],
                    ['Club Brugge KV', '#0078BF', 1248],
                    ['AC Sparta Praha', '#000000', 1381],
                    ['Spartak Moskva', '#FF0000', 1410],
                    ['CSKA Sofia', '#F10000', 835],
                    ['Sporting CP', '#008057', 809],
                    ['FC Basel 1893', '#FF1433', 606],
                    ['IFK G√∂teborg', '#214A99', 1326],
                    ['FC Steaua Bucure≈üti', '#132E52', 1136],
                    ['CSKA Moskva', '#E01B22', 1413],
                    ['Rosenborg BK', '#000000', 1268],
                    ['Austria Wien', '#441678', 586],
                    ['Standard Li√®ge', '#988344', 1237],
                    ['Rapid Wien', '#0079FC', 583],
                    ['Zenit St. Petersburg', '#0097DB', 1415],
                    ['FK P≈ô√≠bram', '#0079FC', 1395],
                    ['FC Dinamo Bucure≈üti', '#FF0000', 1134],
                    ['Fenerbah√ße', '#E3001E', 798],
                    ['G√≥rnik Zabrze', '#25419A', 1159],
                    ['Be≈üikta≈ü', '#000000', 794],
                    ['√öjpest FC', '#660066', 1212],
                    ['Malm√∂ FF', '#81C0FF', 1328],
                    ['BFC Dynamo', '#821515', 470],
                    ['Hajduk Split', '#21409A', 1198],
                    ['Legia Warszawa', '#08610E', 1155],
                    ['Spartak Trnava', '#F70505', 1314],
                    ['Partizan', '#000000', 991],
                    ['AEK Athen', '#FFFF00', 1401],
                    ['FC K√∏benhavn', '#375197', 1347],
                    ['Dinamo Zagreb', '#1D3A8D', 1199],
                    ['Budapesti Vasas', '##000CC', 1208],
                    ['RB Salzburg', '#E41349', 788],
                    ['FC Z√ºrich', '#00BFFF', 614],
                    ['BSC Young Boys', '#FFD940', 615],
                    ['Ferencv√°rosi TC', '#006600', 1211],
                    ['Grasshopper Club Z√ºrich', '#0064B9', 609],
                    ['Lokomotiv Moskva', '#C6453D', 1409],
                    ['Omonia Nikosia', '#147800', 1258],
                    ['Budapest Honv√©d', '#FF0000', 1213],
                    ['Sturm Graz', '#000000', 584],
                    ['Trabzonspor', '#681938', 800],
                    ['Linfield FC', '#0810F5', 874],
                    ['APOEL Nikosia', '#2E3A90', 1257],
                    ['FC Wacker Innsbruck', '#00703C', 585],
                    ['Slovan Bratislava', '#00A6FF', 1312],
                    ['Gy≈ëri ETO FC', '#009933', 1220],
                    ['Servette FC', '#870E26', 613],
                    ['Aarhus GF', '#000094', 1345],
                    ['1. FC Frankfurt (Oder)', '#FF0000', 687],
                    ['Lech Pozna≈Ñ', '#004B92', 1154],
                    ['Jeunesse Esch', '#000000', 826],
                    ['Br√∏ndby IF', '#072F67', 1338],
                    ['HJK Helsinki', '#004899', 862],
                    ['Erzgebirge Aue', '#9900CC', 424],
                    ['Aberdeen FC', '#FF0000', 1290],
                    ['Ruch Chorz√≥w', '#0000FF', 1151],
                    ['BATE Borisov', '#233D92', 1059],
                    ['Dnipro Dnipropetrovsk', '#00418E', 1370],
                    ['Ban√≠k Ostrava', '#DDA35A', 1386],
                    ['CFR Cluj', '#CC0000', 4947],
                    ['Boavista', '#000000', 810],
                    ['Widzew ≈Å√≥d≈∫', '#FF0000', 1153],
                    ['Levski Sofia', '#216BFF', 833],
                    ['Dundee United', '#FF6600', 1293],
                    ['MTK Budapest', '#0033FF', 1209],
                    ['Wiener Sport-Club', '#000000', 792],
                    ['Vojvodina', '#FF0000', 992],
                    ['FC Kuusysi (old)', '#00418E', 7685],
                    ['Sporting Braga', '#E80C0C', 816],
                    ['FC Ararat', '#FF0000', 1058],
                    ['Dundee FC', '#000066', 1296],
                    ['FC Carl Zeiss Jena', '#0F59FA', 372],
                    ['Glentoran FC', '#37C200', 879],
                    ['Viktoria Plze≈à', '#0000FF', 3093],
                    ['FC Universitatea Craiova', '#000000', 1140],
                    ['Lillestr√∏m SK', '#FFFF00', 1270],
                    ['DWS Amsterdam', '#0033A1', 1452],
                    ['Vejle BK', '#FA0808', 1344],
                    ['Sliema Wanderers', '#000000', 920],
                    ['Arge»ô Pite»ôti', '#482E92', 1137],
                    ['Dinamo Minsk', '#3399FF', 1061],
                    ['Neuch√¢tel Xamax FCS', '#FF0000', 612],
                    ['√Ötvidabergs FF', '#008ECB', 3157],
                    ['Rubin Kazan', '#7F2A3D', 3100],
                    ['KF Tiran√´', '#FF0000', 1115],
                    ['Esbjerg fB', '#0072BC', 1354],
                    ['AZ Alkmaar', '#FF0000', 1435],
                    ['IFK Norrk√∂ping', '#9A8348', 1322],
                    ['FK Partizani', '#FF0000', 1117],
                    ['Hibernian FC', '#006633', 1294],
                    ['IFK Malm√∂', '#FFDE21', 7723],
                    ['KAA Gent', '#0033CC', 1230],
                    ['Lokomotiv Sofia', '#B30909', 841],
                    ['Aalborg BK', '#FF0000', 1348],
                    ['Maccabi Haifa', '#14A11D', 1179],
                    ['NK Maribor', '#9900CC', 1375],
                    ['KV Mechelen', '#FF0000', 1241],
                    ['Bohemians Praha 1905', '#317A2B', 1349],
                    ['1. FC Magdeburg', '#3300FF', 427],
                    ['Sparta Rotterdam', '#FF0D0D', 1433],
                    ['Polonia Bytom', '#0015FF', 1171],
                    ['Waterford FC', '#1A01F4', 906],
                    ['√çA Akranes', '#EEFF00', 967],
                    ['Dundalk FC', '#CC282D', 892],
                    ['Valur Reykjav√≠k', '#5752EB', 970],
                    ['KSK Beveren', '#0000FF', 1244],
                    ['FC Unirea', '#0000CC', 7747],
                    ['Wis≈Ça Krak√≥w', '#0022FF', 1152],
                    ['KB K√∏benhavn', '#0C09D9', 1353],
                    ['FC Reipas Lahti (old)', '#E7CD78', 3158],
                    ['KRC Genk', '#0000FF', 1232],
                    ['Inter Bratislava', '#FCFC19', 1310],
                    ['Lyngby BK', '#0E2B89', 1342],
                    ['Zorya Lugansk', '#000000', 7787],
                    ['FC Sion', '#EC1F00', 605],
                    ['MFK V√≠tkovice', '#003396', 1390],
                    ['B 1903 K√∏benhavn', '#000000', 1351],
                    ['FC Sheriff', '#FFFF00', 1132],
                    ['Hvidovre IF', '#FF0000', 1359],
                    ['Petrolul Ploie≈üti', '#FFFF00', 1141],
                    ['Djurg√•rdens IF', '#33B9F2', 2259],
                    ['Slavia Praha', '#B80707', 1380],
                    ['PFC Ludogorets Razgrad', '#006738', 15547],
                    ['Zbrojovka Brno', '#155196', 2403],
                    ['B 1913 Odense', '#005493', 1361],
                    ['FC Twente', '#FF0000', 1430],
                    ['RWDM Brussels', '#000000', 1236],
                    ['FC Petr≈æalka', '#119923', 1316],
                    ['Anorthosis Famagusta', '#0055A5', 1256],
                    ['Lyn Oslo', '#005493', 2253],
                    ['FK Sarajevo', '#590000', 1052],
                    ['Hapoel Tel Aviv', '#FF0000', 1178],
                    ['Gwardia Warszawa', '#FF0000', 1172],
                    ['Kilmarnock FC', '#0000FF', 1288],
                    ['FC Hradec Kr√°lov√©', '#000000', 1397],
                    ['FC La Chaux-de-Fonds', '#00008B', 3201],
                    ['FK Krasnodar', '#158C43', 4601],
                    ['FK Rostov', '#F2E10B', 3095],
                    ['Helsingborgs IF', '#FF0000', 1321],
                    ['Bohemian FC', '#FF0000', 889],
                    ['Qarabaƒü FK', '#0F00E6', 1112],
                    ['Viking FK', '#203060', 1274],
                    ['Hibernians FC', '#00753B', 924],
                    ['Rapid Bucure≈üti', '#000000', 1135],
                    ['Spartak Plovdiv', '#FF0000', 855],
                    ['AB Gladsaxe', '#0BB363', 2252],
                    ['Halmstads BK', '#4169E1', 1325],
                    ['FC Thun Berner Oberland', '#E2001A', 619],
                    ['FK Astana', '#FFFF00', 13033],
                    ['sc Heerenveen', '#0000CC', 1424],
                    ['PAOK Saloniki', '#000000', 1404],
                    ['√ñsters IF', '#3373C4', 1331],
                    ['AIK Solna', '#001B3A', 1324],
                    ['Fredrikstad FK', '#FF0000', 3203],
                    ['Shamrock Rovers', '#16D900', 896],
                    ['Maccabi Tel Aviv', '#123163', 1181],
                    ['Union Saint-Gilloise', '#001B3A', 1251],
                    ['AE L√°rissa', '#610909', 1408],
                    ['Dinamo Tbilisi', '#321FFF', 1225],
                    ['FK Vllaznia', '#000000', 1116],
                    ['Torpedo Moskva', '#000000', 1414],
                    ['Zag≈Çƒôbie Lubin', '#ED7300', 1158],
                    ['KA Akureyri', '#FFF200', 976],
                    ['Botev Plovdiv', '#FFFF00', 837],
                    ['Apollon Limassol', '#2E3A90', 1261],
                    ['Szombierki Bytom', '#0DA30D', 1164],
                    ['FC Differdange 03', '#FF0000', 827],
                    ['≈ÅKS ≈Å√≥d≈∫', '#FF0000', 1156],
                    ['Heart of Midlothian', '#660000', 1286],
                    ['Molde FK', '#3366FF', 1271],
                    ['ƒ∞stanbul Ba≈üak≈üehir', '#FF5704', 6504],
                    ['Derry City', '#FF0202', 890],
                    ['Royal Antwerp FC', '#FF0000', 3056],
                    ['TPS Turku', '#000000', 867],
                    ['Haka Valkeakoski', '#000000', 861],
                    ['Drumcondra Dublin', '#FFDE21', 903],
                    ['Hamrun Spartans', '#FF0000', 921],
                    ['Spora Luxemburg', '#000000', 825],
                    ['Valletta FC', '#EF1D26', 917],
                    ['Floriana FC', '#0BB363', 918],
                    ['Flamurtari Vlor√´', '#000000', 1119],
                    ['Athlone Town', '#1C01FF', 909],
                    ['Willem II', '#BC1919', 1429],
                    ['V√•lerenga IF', '#0033FF', 1279],
                    ['FC Midtjylland', '#FF0D00', 1355],
                    ['UTA Arad', '#FF0000', 3046],
                    ['Fram Reykjav√≠k', '#FF0000', 968],
                    ['FK Bod√∏/Glimt', '#F9DD00', 1273],
                    ['Paphos FC', '#161747', 3567],
                    ['Csepel SC', '#FF0000', 3205],
                    ['√çBV Vestmannaeyjar', '#000000', 971],
                    ['Skeid Fotball', '#000000', 1282],
                    ['FC Aarau', '#000000', 610],
                    ['FC Admira Wacker', '#000000', 588],
                    ['Etar Veliko Tarnovo', '#000000', 856],
                    ['PFC Beroe', '#000000', 846],
                    ['≈ölƒÖsk Wroc≈Çaw', '#000000', 1162],
                    ['Glenavon FC', '#000000', 875],
                    ['Rot-Weiss Essen', '#000000', 224],
                    ['St Patrick\'s Athletic', '#000000', 893],
                    ['FC Lausanne-Sport', '#006EB7', 608],
                    ['Lisburn Distillery', '#000000', 3202],
                    ['FC Blau Wei√ü Linz', '#253087', 3724],
                    ['FC Dinamo City', '#2B24FF', 1120],
                    ['Skonto FC', '#FF0000', 1064],
                    ['Lierse SK (old)', '#FFFF00', 1231],
                    ['Bursaspor', '#009933', 2317],
                    ['B 1909 Odense', '#FF0000', 3187],
                    ['Odense BK', '#005493', 1346],
                    ['Progr√®s Niedercorn', '#F7FF00', 829],
                    ['Kuopion PS', '#000000', 870],
                    ['OPS Oulu', '#FF0000', 11503],
                    ['FC Nordsj√¶lland', '#A70037', 3282],
                    ['Aris Bonnevoie', '#000000', 828],
                    ['Olympiakos Nikosia', '#000000', 1267],
                    ['FC Utrecht', '#FF0000', 1432],
                    ['Cork City', '#1E7C47', 891],
                    ['Roda JC Kerkrade', '#FFDD00', 1427],
                    ['Chemnitzer FC', '#008DCD', 340],
                    ['LASK', '#000000', 786],
                    ['≈Ωeljezniƒçar Sarajevo', '#1A488F', 1051],
                    ['√ñrgryte IS', '#A50044', 1323],
                    ['FKS Stal Mielec', '#008BCF', 1163],
                    ['SG Sachsen Leipzig', '#000000', 429],
                    ['Moss FK', '#F5F50E', 1281],
                    ['Beitar Jerusalem', '#FFFF00', 1180],
                    ['Pezoporikos Larnaca', '#0BB363', 1265],
                    ['Tavriya Simferopol (1958-2014)', '#0088FF', 1372],
                    ['Ilves Tampere', '#FFFF00', 869],
                    ['FC Luzern', '#154281', 611],
                    ['Cork Celtic', '#154281', 908],
                    ['Cork Hibernians', '#154281', 907],
                    ['K√∏ge BK', '#154281', 1358],
                    ['Shelbourne FC', '#154281', 888],
                    ['Str√∏msgodset IF', '#154281', 1275],
                    ['KF Elbasani', '#154281', 1127],
                    ['Sligo Rovers', '#154281', 901],
                    ['Vardar Skopje', '#154281', 885],
                    ['Helsingfors IFK', '#154281', 3204],
                    ['Ards FC', '#154281', 3206],
                    ['HPS Helsinki', '#154281', 3207],
                    ['Olimpija Ljubljana', '#154281', 1377],
                    ['V√≠kingur Reykjav√≠k', '#154281', 972],
                    ['O≈£elul Gala≈£i', '#154281', 1145],
                    ['IK Start', '#154281', 1283],
                    ['FK ≈Ωalgiris', '#024C26', 1003],
                    ['Coleraine FC', '#122DE0', 880],
                    ['FC VSS Ko≈°ice', '#000000', 1311],
                    ['Limerick FC (1937-2007)', '#0000FF', 905],
                    ['AEL Limassol', '#2E3A90', 2418],
                    ['Debreceni VSC', '##F0000', 1210],
                    ['KPV Kokkola', '#000000', 3159],
                    ['M≈†K ≈Ωilina', '#FBE200', 2408],
                    ['EPA Larnaca', '#017947', 1263],
                    ['Crusaders FC', '#000000', 876],
                    ['Portadown FC', '#000000', 877],
                    ['Rabat Ajax', '#000000', 922],
                    ['KR Reykjav√≠k', '#000000', 966],
                    ['Keflav√≠k √çF', '#375197', 973],
                    ['Stade Dudelange', '#37A8BF', 3952],
                    ['Union Luxembourg', '#0096FA', 3080],
                    ['The New Saints', '#0BB363', 930],
                    ['FBK Kaunas', '#0BB363', 1002],
                    ['F91 Dudelange', '#F2D21D', 822],
                    ['Pyunik FC', '#A50034', 2406],
                    ['Hapoel Be\'er Sheva', '#FF0000', 1184],
                    ['Lincoln Red Imps', '#FF0000', 8375],
                    ['FCI Levadia', '#006600', 2421],
                    ['Neft√ßi PFK', '#CC9933', 1111],
                    ['FK Aktobe', '#E30707', 3504],
                    ['PFC Litex Lovech', '#F54E00', 849],
                    ['FC Zimbru', '#00FF00', 1130],
                    ['FK Kairat', '#FFEA00', 2426],
                    ['K√ç Klaksv√≠k', '#005999', 978],
                    ['FH Hafnarfj√∂r√∞ur', '#000000', 969],
                    ['Zrinjski Mostar', '#EE3338', 3581],
                    ['KF Sk√´nderbeu', '#7F5F1E', 1123],
                    ['FK Ventspils', '#FFD400', 1067],
                    ['KF Shk√´ndija 79', '#000000', 5114],
                    ['Feh√©rv√°r FC', '#990000', 1218],
                    ['Brei√∞ablik', '#216633', 4875],
                    ['FK Ekranas', '#005999', 1004],
                    ['Grazer AK', '#FF0000', 579],
                    ['Rak√≥w Czƒôstochowa', '#C70000', 5455],
                    ['Torpedo Kutaisi', '#069C22', 1223],
                    ['ND Gorica', '#0066FF', 1376],
                    ['Tampere United', '#FFFF00', 2405],
                    ['FC Flora', '#009900', 956],
                    ['IF Elfsborg', '#000000', 1336],
                    ['FK Rabotniƒçki', '#FF0000', 3127],
                    ['FK RFS', '#034694', 1088],
                    ['Drita Gjilan', '#034694', 8403],
                    ['FC Alashkert', '#333333', 18924],
                    ['HB T√≥rshavn', '#FF0000', 982],
                    ['Shakter Karaganda', '#000000', 3507],
                    ['Barry Town United', '#1D428A', 931],
                    ['NK Dom≈æale', '#FFFF33', 3492],
                    ['Birkirkara FC', '#FF0000', 916],
                    ['NK Celje', '#004793', 1379],
                    ['≈†iroki Brijeg', '#1D4B8F', 2430],
                    ['KF Shkupi', '#0000FF', 883],
                    ['FK Slaviya Mozyr', '#FF0000', 1060],
                    ['HNK Rijeka', '#DDBE80', 1201],
                    ['Inter Club d\'Escaldes', '#0534FE', 3972],
                    ['Borac Banja Luka', '#C4A662', 3578],
                    ['FK Buduƒánost Podgorica', '#C4A662', 4939],
                    ['B36 T√≥rshavn', '#000000', 984],
                    ['FC Santa Coloma', '#000000', 1472],
                    ['BK H√§cken', '#000000', 4055],
                    ['Ironi Kiryat Shmona', '#0000FF', 10236],
                    ['FK Baku', '#D90B0B', 3534],
                    ['Slovan Liberec', '#0B89C6', 1382],
                    ['N≈† Mura', '#000000', 23203],
                    ['Polonia Warszawa', '#FF0000', 1149],
                    ['Drogheda United', '#990033', 895],
                    ['KF Feronikeli', '#0BB363', 24261],
                    ['FK Rudar Pljevlja', '#005999', 3424],
                    ['MyPa-47', '#0BB363', 864],
                    ['FK Obiliƒá', '#0BB363', 993],
                    ['AS Trenƒç√≠n', '#0BB363', 2401],
                    ['V√≠kingur', '#0BB363', 11423],
                    ['KF Ballkani', '#0BB363', 28070],
                    ['FC Milsami', '#0BB363', 13295],
                    ['FK Zhenis', '#0BB363', 2407],
                    ['JK N√µmme Kalju', '#0BB363', 11158],
                    ['Budapest Honv√©d', '#FF0000', 1213],
                    ['Aris Limassol', '#2E3A90', 3042],
                    ['Dinamo Brest', '#003866', 3243],
                    ['Jagiellonia Bia≈Çystok', '#FFD500', 4839],
                    ['Shirak FC', '#FF6600', 1055],
                    ['FC Urartu', '#04053D', 3446],
                    ['Floriana FC', '#04053D', 918],
                    ['FC Prishtina', '#3931A8', 8401],
                    ['FC Jazz Pori', '#04053D', 863],
                    ['≈ûamaxƒ± FK', '#04053D', 2374],
                    ['FK Modriƒça', '#04053D', 3586],
                    ['FK Kuk√´si', '#FF6600', 18183],
                    ['Egnatia Rrogozhine', '#000000', 5085],
                    ['SK Brann', '#FF0000', 1269],
                    ['Zalaegerszegi TE', '#0000FF', 2409],
                    ['FK Mogren Budva', '#005999', 3170],
                    ['Stab√¶k IF', '#000000', 1272],
                    ['Dunaferr SE', '#FF0000', 1207],
                    ['CS Petrocub', '#000000', 22057],
                    ['FK Mlad√° Boleslav', '#084064', 4318],
                    ['FC Zestafoni', '#313163', 7818],
                    ['FK S≈´duva', '#DD3333', 2419],
                    ['Metalist Kharkiv', '#009900', 1374],
                    ['FC Noah', '#000000', 30664],
                    ['Leotar Trebinje', '#008DCD', 3074],
                    ['Dinamo Batumi', '#008DCD', 1228],
                    ['FK Panevƒó≈æys', '#008DCD', 23603],
                    ['Belshina Bobruisk', '#FF0000', 1063],
                    ['Sileks Kratovo', '#0055A0', 887],
                    ['EB/Streymur', '#0055A0', 3570],
                    ['WIT Georgia', '#008700', 1226],
                    ['FK LiepƒÅjas Metalurgs', '#FF0000', 1066],
                    ['Cwmbran Town', '#FF0000', 933],
                    ['Kalmar FF', '#FF0000', 1334],
                    ['NK Zagreb', '#FF0000', 1202],
                    ['FC Koper', '##0000FF', 2328],
                    ['NK Brotnjo', '#FF0000', 1049],
                    ['Dacia Chi≈üinƒÉu', '#FFFF00', 3091],
                    ['Dinamo Moskva', '#0D6ECD', 1412],
                    ['FK Gomel', '#009900', 2424],
                    ['FK Zeta', '#FF0000', 3173],
                    ['FC Ararat-Armenia', '#FF0000', 25815],
                    ['FC Timi≈üoara', '#5C2180', 1142],
                    ['Farul Constan»õa', '#0A38C4', 3014],
                    ['NS√ç Runav√≠k', '#FDF105', 988],
                    ['Sivasspor', '#FC0505', 5906],
                    ['Sioni Bolnisi', '#FFF799', 3447],
                    ['FC Viitorul Constan»õa', '#025FAC', 15259],
                    ['Llanelli Town', '#08610E', 4980],
                    ['Riga FC', '#2B579E', 21471],
                    ['FC Lugano', '#000000', 616],
                    ['UE Santa Coloma', '#F9F09C', 12478],
                    ['MFK Ru≈æomberok', '#EB7D07', 1318],
                    ['Shamkir FK', '#FF0000', 1108],
                    ['Kapaz PFK', '#FECB00', 1114],
                    ['Europa FC', '#099902', 21174],
                    ['FC Iberia 1999', '#FF0000', 19746],
                    ['FK Sutjeska', '#0054A6', 3407],
                    ['SP Tre Penne', '#0054A6', 4089],
                    ['AEK Larnaca', '#017947', 3072],
                    ['FK Pobeda', '#FF0000', 884],
                    ['FK Spartaks', '#FF0000', 15350],
                    ['Hapoel Haifa', '#FF0000', 1182],
                    ['FC Vaslui', '#00CC33', 5638],
                    ['Metalurgi Rustavi', '#FF0000', 3213],
                    ['Tobyl Kostanay', '#FDF105', 3410],
                    ['UE Sant Juli√†', '#45A80F', 1471],
                    ['SP Tre Fiori', '#FDF105', 4092],
                    ['CS FOLA Esch', '#FF0000', 5299],
                    ['FC TVMK', '#025FAC', 935],
                    ['FC St. Gallen', '#008141', 607],
                    ['FC Tiraspol', '#FFFF00', 4392],
                    ['Piast Gliwice', '#FF0000', 5472],
                    ['Vit√≥ria Guimar√£es', '#000000', 815],
                    ['Irtysh Pavlodar', '#001CD4', 3445],
                    ['FK Ordabasy', '#00238A', 3505],
                    ['SK Dnipro-1', '#00418E', 25702],
                    ['SJK Sein√§joki', '#9C824A', 13584],
                    ['Khazar Lankaran', '#00954C', 5139],
                    ['Swift Hesperange', '#FF0000', 3088],
                    ['Silkeborg IF', '#0090B2', 1343],
                    ['CS Grevenmacher', '#2737E6', 832],
                    ['Connah\'s Quay Nomads', '#FF0000', 3552],
                    ['FK Deƒçiƒá Tuzi', '#090DF0', 7849],
                    ['Astra Giurgiu', '#FF0000', 3541],
                    ['FC Struga', '#000000', 25917],
                    ['Hammarby IF', '#1A7812', 1335],
                    ['FC Su√∞uroy', '#0054A6', 980],
                    ['Lokomotiva Zagreb', '#0054A6', 11193],
                    ['Valmiera FC', '#0054A6', 1091],
                    ['Ulisses FC', '#FF0000', 3502],
                    ['Inter Turku', '#000000', 3225],
                    ['FK Teplice', '#F2DB08', 1385],
                    ['Norma Tallinn', '#009900', 949],
                    ['Shakhter Soligorsk', '#FFFF00', 1062],
                    ['Kareda Kaunas', '#000000', 1037],
                    ['Larne FC', '#FF0000', 3563],
                    ['SP La Fiorita', '#0054A6', 4090],
                    ['FC Lusitanos', '#048147', 3973],
                    ['Cliftonville FC', '#FF0000', 882],
                    ['Atl√©tic Escaldes', '#007FFF', 5110],
                    ['FCI Tallinn', '#009900', 13799],
                    ['FK LiepƒÅja', '#00954C', 22788],
                    ['Dila Gori', '#FF0000', 3572],
                    ['Dnepr Mogilev', '#F9D518', 3099],
                    ['Lantana Tallinn', '#000000', 957],
                    ['SS Folgore/Falciano', '#FF0000', 4091],
                    ['KF Trep√ßa\'89', '#000000', 24565],
                    ['V√°c FC', '#FF0000', 1215],
                    ['Makedonija GP', '#FF0000', 6018],
                    ['Pa√ßos de Ferreira', '#FF0000', 2712],
                    ['UMF Stjarnan', '#5C2180', 5625],
                    ['KF Teuta Durr√´s', '#0067B1', 1125],
                    ['OFK Titograd', '##D42D4', 7846],
                    ['SV Zulte Waregem', '#009900', 5620],
                    ['Motherwell FC', '#660033', 1291],
                    ['FK Renova', '#0080FF', 6020],
                    ['FC R√†nger‚Äôs', '#FDF105', 3975],
                    ['FK Yerevan', '#00009C', 9631],
                    ['TSC Baƒçka Topola', '#0D80BF', 28340],
                    ['FC Samtredia', '#0000FF', 10101],
                    ['Lokomotiv Plovdiv', '#8A0707', 838],
                    ['Herf√∏lge BK', '#0033FF', 1339],
                    ['Spartak Vladikavkaz', '#FF0000', 1418],
                    ['Marsaxlokk FC', '#0000FF', 3441],
                    ['Araks Ararat', '#00009C', 1056],
                    ['IFK Mariehamn', '#0000FF', 5493],
                    ['FC Daugava', '#0000FF', 4389],

                    ['G√ç G√∏ta', '#0033FF', 981],
                    ['B68 Toftir', '#000000', 979],
                    ['SS Murata', '#000000', 4093],
                    ['SS Virtus', '#099902', 4094],
                    ['Bangor City', '#FF0000', 2428],
                    ['Rhyl FC', '#0033FF', 3557],
                    ['Avenir Beggen', '#005999', 823]
                ]
            };
        }

        // Get team color for H2H visualization
        function getTeamColor(teamName, league) {
            const teamColors = getTeamColors();
            
            // For Champions League, search across all leagues
            if (league === 'champions-league') {
                const allLeagues = ['champions-league', 'premier-league', 'la-liga', 'serie-a', 'bundesliga', 'ligue-1'];
                for (const searchLeague of allLeagues) {
                    const leagueColors = teamColors[searchLeague] || [];
                    const teamColorEntry = leagueColors.find(([name, color]) => name === teamName);
                    if (teamColorEntry) return teamColorEntry[1];
                }
                return null;
            }
            
            const leagueColors = teamColors[league] || [];
            const teamColorEntry = leagueColors.find(([name, color]) => name === teamName);
            return teamColorEntry ? teamColorEntry[1] : null;
        }

        // Get team logo number
        function getTeamLogoNumber(teamName, league) {
            const teamColors = getTeamColors();
            
            // For Champions League, search across all leagues
            if (league === 'champions-league') {
                const allLeagues = ['champions-league', 'premier-league', 'la-liga', 'serie-a', 'bundesliga', 'ligue-1'];
                for (const searchLeague of allLeagues) {
                    const leagueColors = teamColors[searchLeague] || [];
                    const teamColorEntry = leagueColors.find(([name, color, logoNum]) => name === teamName);
                    if (teamColorEntry) return teamColorEntry[2];
                }
                return null;
            }
            
            const leagueColors = teamColors[league] || [];
            const teamColorEntry = leagueColors.find(([name, color, logoNum]) => name === teamName);
            return teamColorEntry ? teamColorEntry[2] : null;
        }

        // Get team logo URL
        function getTeamLogoUrl(teamName, league) {
            const logoNumber = getTeamLogoNumber(teamName, league);
            return logoNumber ? `https://s.hs-data.com/bilder/wappen/mittel/${logoNumber}.gif?fallback=png` : null;
        }

        // Get contrasting text color (white or black) based on background color
        function getContrastColor(hexColor) {
            // Remove # if present
            const hex = hexColor.replace('#', '');
            
            // Convert to RGB
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Calculate luminance
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            
            // Return black for light colors, white for dark colors
            return luminance > 0.5 ? '#000000' : '#FFFFFF';
        }

        // Stripped Champions data - entries that should be hidden when position filtering is involved
        const strippedChampions = [
            ["Juventus", "I1", "2004-05", 1],
            ["Olympique Marseille", "F1", "1992-93", 1],
            ["Arminia Bielefeld", "E1", "1971-72", 18]

            // Add more entries as needed: [teamName, leagueDiv, season, position]
        ];

        // Check if an entry should be filtered out due to stripped champion rules
        function isStrippedChampion(teamName, leagueDiv, season, position, hasTeamFilter, hasPositionFilter) {
            // Only apply filtering when position is involved in the filter
            if (!hasPositionFilter) {
                return false; // Show everything when no position filter is active
            }

            // Check if this entry matches any stripped champion record
            return strippedChampions.some(([team, league, seasonStr, pos]) => {
                return team === teamName && 
                       league === leagueDiv && 
                       seasonStr === season && 
                       pos === position;
            });
        }

        // Point deductions data
        const pointDeductions = [
            // Champions League point deductions
            { team: 'AC Milan', points: 2, startDate: '1994-07-01', endDate: '1995-06-30', league: 'C1' },
            
            // Other leagues (kept for reference)
            { team: 'M√°laga CF', points: 3, startDate: '1979-07-01', endDate: '1980-06-30', league: 'SP1' }
        ];

        // Season mappings
        const seasons = {
            'champions-league': {
                '2025-26': { start: '2025-07-01', end: '2026-06-30' },
                '2024-25': { start: '2024-07-01', end: '2025-06-30' },
                '2023-24': { start: '2023-07-01', end: '2024-06-30' },
                '2022-23': { start: '2022-07-01', end: '2023-06-30' },
                '2021-22': { start: '2021-07-01', end: '2022-06-30' },
                '2020-21': { start: '2020-10-20', end: '2021-06-30' },
                '2019-20': { start: '2019-07-01', end: '2020-08-23' },
                '2018-19': { start: '2018-07-01', end: '2019-06-30' },
                '2017-18': { start: '2017-07-01', end: '2018-06-30' },
                '2016-17': { start: '2016-07-01', end: '2017-06-30' },
                '2015-16': { start: '2015-07-01', end: '2016-06-30' },
                '2014-15': { start: '2014-07-01', end: '2015-06-30' },
                '2013-14': { start: '2013-07-01', end: '2014-06-30' },
                '2012-13': { start: '2012-07-01', end: '2013-06-30' },
                '2011-12': { start: '2011-07-01', end: '2012-06-30' },
                '2010-11': { start: '2010-07-01', end: '2011-06-30' },
                '2009-10': { start: '2009-07-01', end: '2010-06-30' },
                '2008-09': { start: '2008-07-01', end: '2009-06-30' },
                '2007-08': { start: '2007-07-01', end: '2008-06-30' },
                '2006-07': { start: '2006-07-01', end: '2007-06-30' },
                '2005-06': { start: '2005-07-01', end: '2006-06-30' },
                '2004-05': { start: '2004-07-01', end: '2005-06-30' },
                '2003-04': { start: '2003-07-01', end: '2004-06-30' },
                '2002-03': { start: '2002-07-01', end: '2003-06-30' },
                '2001-02': { start: '2001-07-01', end: '2002-06-30' },
                '2000-01': { start: '2000-07-01', end: '2001-06-30' },
                '1999-00': { start: '1999-07-01', end: '2000-06-30' },
                '1998-99': { start: '1998-07-01', end: '1999-06-30' },
                '1997-98': { start: '1997-07-01', end: '1998-06-30' },
                '1996-97': { start: '1996-07-01', end: '1997-06-30' },
                '1995-96': { start: '1995-07-01', end: '1996-06-30' },
                '1994-95': { start: '1994-07-01', end: '1995-06-30' },
                '1993-94': { start: '1993-07-01', end: '1994-06-30' },
                '1992-93': { start: '1992-07-01', end: '1993-06-30' }
            },
            'europa-league': {
                // Europa League seasons will be added when we have data
            },
            'conference-league': {
                // Conference League seasons will be added when we have data
            }
        };

        // Generate seasons for all leagues
        function generateSeasons() {
            // Champions League / European Cup seasons - comprehensive historical coverage from 1955
            // Using July 1 to June 30 pattern to match domestic league seasons
            // Skip years that have custom date ranges defined above
            for (let year = 1955; year <= 2025; year++) {
                const seasonName = `${year}-${(year + 1).toString().slice(2)}`;
                // Skip 2019-20 and 2020-21 as they have custom date ranges defined above
                if (seasonName === '2019-20' || seasonName === '2020-21') {
                    continue;
                }
                seasons['champions-league'][seasonName] = {
                    start: `${year}-07-01`,
                    end: `${year + 1}-06-30`
                };
            }

            // Europa League seasons - will be populated when we have Europa League data
            // Starting from 1971 (when UEFA Cup began)
            for (let year = 1971; year <= 2025; year++) {
                const seasonName = `${year}-${(year + 1).toString().slice(2)}`;
                if (!seasons['europa-league']) seasons['europa-league'] = {};
                seasons['europa-league'][seasonName] = {
                    start: `${year}-07-01`,
                    end: `${year + 1}-06-30`
                };
            }

            // Conference League seasons - starting from 2021
            for (let year = 2021; year <= 2025; year++) {
                const seasonName = `${year}-${(year + 1).toString().slice(2)}`;
                if (!seasons['conference-league']) seasons['conference-league'] = {};
                seasons['conference-league'][seasonName] = {
                    start: `${year}-07-01`,
                    end: `${year + 1}-06-30`
                };
            }
        }

        // Initialize seasons
        generateSeasons();

        // DOM elements
        const elements = {
            lastDataUpdate: document.getElementById('lastDataUpdate'),
            controlsSection: document.getElementById('controlsSection'),
            reloadGistsBtn: document.getElementById('reloadGistsBtn'),
            errorState: document.getElementById('errorState'),
            errorMessage: document.getElementById('errorMessage'),
            tableContainer: document.getElementById('tableContainer'),
            tableInfo: document.getElementById('tableInfo'),
            tableInfoText: document.getElementById('tableInfoText'),
            tableHeader: document.getElementById('tableHeader'),
            tableBody: document.getElementById('tableBody'),
            leagueButtons: document.getElementById('leagueButtons'),
            seasonSelect: document.getElementById('seasonSelect'),
            competitionStageContainer: document.getElementById('competitionStageContainer'),
            competitionStageSelect: document.getElementById('competitionStageSelect'),
            dateFrom: document.getElementById('dateFrom'),
            dateTo: document.getElementById('dateTo'),
            dayOfWeekSelect: document.getElementById('dayOfWeekSelect'),
            team1Select: document.getElementById('team1Select'),
            team2Select: document.getElementById('team2Select'),
            team1ComboboxContainer: document.getElementById('team1ComboboxContainer'),
            team1ComboboxInput: document.getElementById('team1ComboboxInput'),
            team1ComboboxDropdown: document.getElementById('team1ComboboxDropdown'),
            team2ComboboxContainer: document.getElementById('team2ComboboxContainer'),
            team2ComboboxInput: document.getElementById('team2ComboboxInput'),
            team2ComboboxDropdown: document.getElementById('team2ComboboxDropdown'),
            teamSeasonsComboboxContainer: document.getElementById('teamSeasonsComboboxContainer'),
            teamSeasonsComboboxInput: document.getElementById('teamSeasonsComboboxInput'),
            teamSeasonsComboboxDropdown: document.getElementById('teamSeasonsComboboxDropdown'),
            lastTimeTeam1ComboboxContainer: document.getElementById('lastTimeTeam1ComboboxContainer'),
            lastTimeTeam1ComboboxInput: document.getElementById('lastTimeTeam1ComboboxInput'),
            lastTimeTeam1ComboboxDropdown: document.getElementById('lastTimeTeam1ComboboxDropdown'),
            lastTimeTeam2ComboboxContainer: document.getElementById('lastTimeTeam2ComboboxContainer'),
            lastTimeTeam2ComboboxInput: document.getElementById('lastTimeTeam2ComboboxInput'),
            lastTimeTeam2ComboboxDropdown: document.getElementById('lastTimeTeam2ComboboxDropdown'),
            teamStreaksTeam1ComboboxContainer: document.getElementById('teamStreaksTeam1ComboboxContainer'),
            teamStreaksTeam1ComboboxInput: document.getElementById('teamStreaksTeam1ComboboxInput'),
            teamStreaksTeam1ComboboxDropdown: document.getElementById('teamStreaksTeam1ComboboxDropdown'),
            teamStreaksTeam2ComboboxContainer: document.getElementById('teamStreaksTeam2ComboboxContainer'),
            teamStreaksTeam2ComboboxInput: document.getElementById('teamStreaksTeam2ComboboxInput'),
            teamStreaksTeam2ComboboxDropdown: document.getElementById('teamStreaksTeam2ComboboxDropdown'),
            homeCheckbox: document.getElementById('homeCheckbox'),
            awayCheckbox: document.getElementById('awayCheckbox'),
            deductionsCheckbox: document.getElementById('deductionsCheckbox'),
            threePointCheckbox: document.getElementById('threePointCheckbox'),
            excludeQualifiersCheckbox: document.getElementById('excludeQualifiersCheckbox'),
            excludeMainStageCheckbox: document.getElementById('excludeMainStageCheckbox'),
            resetBtn: document.getElementById('resetBtn'),
            retryBtn: document.getElementById('retryBtn'),
            matchHistorySection: document.getElementById('matchHistorySection'),
            matchHistoryHomeCheckbox: document.getElementById('matchHistoryHomeCheckbox'),
            matchHistoryAwayCheckbox: document.getElementById('matchHistoryAwayCheckbox'),
            matchHistoryPenaltyCheckbox: document.getElementById('matchHistoryPenaltyCheckbox'),
            matchHistoryStageSelect: document.getElementById('matchHistoryStageSelect'),
            matchHistoryMatchCount: document.getElementById('matchHistoryMatchCount'),
            matchHistoryTable: document.getElementById('matchHistoryTable'),
            matchHistoryTableTitle: document.getElementById('matchHistoryTableTitle'),
            matchHistoryTableHeader: document.getElementById('matchHistoryTableHeader'),
            matchHistoryTableBody: document.getElementById('matchHistoryTableBody'),
            recentMatchesSelect: document.getElementById('recentMatchesSelect'),
            matchHistoryVisualizations: document.getElementById('matchHistoryVisualizations'),
            h2hSection: document.getElementById('h2hSection'),
            h2hHomeCheckbox: document.getElementById('h2hHomeCheckbox'),
            h2hAwayCheckbox: document.getElementById('h2hAwayCheckbox'),
            h2hPenaltyCheckbox: document.getElementById('h2hPenaltyCheckbox'),
            h2hStageSelect: document.getElementById('h2hStageSelect'),
            recentH2HSelect: document.getElementById('recentH2HSelect'),
            h2hMatchCount: document.getElementById('h2hMatchCount'),
            h2hVisualizations: document.getElementById('h2hVisualizations'),
            h2hMatchesTable: document.getElementById('h2hMatchesTable'),
            h2hTableTitle: document.getElementById('h2hTableTitle'),
            h2hTableHeader: document.getElementById('h2hTableHeader'),
            h2hTableBody: document.getElementById('h2hTableBody'),
            lastTimeLeagueButtons: document.getElementById('lastTimeLeagueButtons'),
            lastTimeDayOfWeekSelect: document.getElementById('lastTimeDayOfWeekSelect'),
            lastTimeLocationSelect: document.getElementById('lastTimeLocationSelect'),
            lastTimeStageSelect: document.getElementById('lastTimeStageSelect'),
            lastTimeTeam1Select: document.getElementById('lastTimeTeam1Select'),
            lastTimeTeam2Select: document.getElementById('lastTimeTeam2Select'),
            lastTimeResults: document.getElementById('lastTimeResults'),
            // Table sections
            team1HomeWinSection: document.getElementById('team1HomeWinSection'),
            team1AwayWinSection: document.getElementById('team1AwayWinSection'),
            team1HomeDrawSection: document.getElementById('team1HomeDrawSection'),
            team1AwayDrawSection: document.getElementById('team1AwayDrawSection'),
            team1HomeLossSection: document.getElementById('team1HomeLossSection'),
            team1AwayLossSection: document.getElementById('team1AwayLossSection'),
            // Table bodies
            team1HomeWinBody: document.getElementById('team1HomeWinBody'),
            team1AwayWinBody: document.getElementById('team1AwayWinBody'),
            team1HomeDrawBody: document.getElementById('team1HomeDrawBody'),
            team1AwayDrawBody: document.getElementById('team1AwayDrawBody'),
            team1HomeLossBody: document.getElementById('team1HomeLossBody'),
            team1AwayLossBody: document.getElementById('team1AwayLossBody'),
            // Day counters
            team1HomeWinDays: document.getElementById('team1HomeWinDays'),
            team1AwayWinDays: document.getElementById('team1AwayWinDays'),
            team1HomeDrawDays: document.getElementById('team1HomeDrawDays'),
            team1AwayDrawDays: document.getElementById('team1AwayDrawDays'),
            team1HomeLossDays: document.getElementById('team1HomeLossDays'),
            team1AwayLossDays: document.getElementById('team1AwayLossDays'),
            // Titles
            team1HomeWinTitle: document.getElementById('team1HomeWinTitle'),
            team1AwayWinTitle: document.getElementById('team1AwayWinTitle'),
            team1HomeDrawTitle: document.getElementById('team1HomeDrawTitle'),
            team1AwayDrawTitle: document.getElementById('team1AwayDrawTitle'),
            team1HomeLossTitle: document.getElementById('team1HomeLossTitle'),
            team1AwayLossTitle: document.getElementById('team1AwayLossTitle'),
            teamHistoryTable: document.getElementById('teamHistoryTable'),
            teamHistoryTitle: document.getElementById('teamHistoryTitle'),
            teamHistoryHeader: document.getElementById('teamHistoryHeader'),
            teamHistoryBody: document.getElementById('teamHistoryBody'),
            teamHistoryBackArrow: document.getElementById('teamHistoryBackArrow'),
            teamSeasonsLeagueButtons: document.getElementById('teamSeasonsLeagueButtons'),
            teamSeasonsTeamSelect: document.getElementById('teamSeasonsTeamSelect'),
            teamSeasonsSeasonContainer: document.getElementById('teamSeasonsSeasonContainer'),
            teamSeasonsSeasonSelect: document.getElementById('teamSeasonsSeasonSelect'),
            teamSeasonsPositionContainer: document.getElementById('teamSeasonsPositionContainer'),
            teamSeasonsPositionSelect: document.getElementById('teamSeasonsPositionSelect'),
            includeBetterResultsContainer: document.getElementById('includeBetterResultsContainer'),
            includeBetterResultsCheckbox: document.getElementById('includeBetterResultsCheckbox'),
            teamSeasonsPositionInfo: document.getElementById('teamSeasonsPositionInfo'),
            collapseControlsBtn: document.getElementById('collapseControlsBtn'),
            // Team Streaks elements
            teamStreaksLeagueButtons: document.getElementById('teamStreaksLeagueButtons'),
            teamStreaksStageSelect: document.getElementById('teamStreaksStageSelect'),
            teamStreaksStatusSelect: document.getElementById('teamStreaksStatusSelect'),
            teamStreaksLocationSelect: document.getElementById('teamStreaksLocationSelect'),
            teamStreaksTypeSelect: document.getElementById('teamStreaksTypeSelect'),
            teamStreaksTeam1Select: document.getElementById('teamStreaksTeam1Select'),
            teamStreaksTeam2Select: document.getElementById('teamStreaksTeam2Select'),
            teamStreaksResults: document.getElementById('teamStreaksResults')
        };

        // Create Team Streaks league buttons
        function createTeamStreaksLeagueButtons() {
            const leagues = [
                { id: 'champions-league', name: 'üá™üá∫ Champions League' },
                // { id: 'europa-league', name: 'üá™üá∫ Europa League' },
                // { id: 'conference-league', name: 'üá™üá∫ Conference League' }
            ];

            const leagueButtonsHTML = leagues.map(league => `
                <label class="league-button ${state.selectedLeague === league.id ? 'active' : ''}" data-league="${league.id}">
                    <div class="radio-dot ${state.selectedLeague === league.id ? 'active' : ''}"></div>
                    <span class="text-sm font-medium ${state.selectedLeague === league.id ? 'text-green-700' : 'text-gray-700'}">
                        ${league.name}
                    </span>
                </label>
            `).join('');
            
            elements.teamStreaksLeagueButtons.innerHTML = leagueButtonsHTML;
        }

        // Update Team Streaks team dropdowns
        function updateTeamStreaksSelects() {
            const leagueTeams = getLeagueTeams(state.selectedLeague);
            
            const teamOptions = ['<option value="">Select Team</option>']
                .concat(leagueTeams.map(team => `<option value="${team}">${team}</option>`))
                .join('');
            
            elements.teamStreaksTeam1Select.innerHTML = teamOptions;
            elements.teamStreaksTeam2Select.innerHTML = '<option value="">Select Team 2 (Optional)</option>' + 
                leagueTeams.map(team => `<option value="${team}">${team}</option>`).join('');
        }

        // Handle Team Streaks league change
        async function handleTeamStreaksLeagueChange(newLeague) {
            state.selectedLeague = newLeague;

            // Reset Team Streaks state when changing leagues
            elements.teamStreaksTeam1Select.value = '';
            elements.teamStreaksTeam2Select.value = '';
            elements.teamStreaksStageSelect.value = '';
            elements.teamStreaksStatusSelect.value = 'active';
            elements.teamStreaksLocationSelect.value = 'both';
            elements.teamStreaksTypeSelect.value = 'winning';
            elements.teamStreaksResults.classList.add('hidden');
            state.teamStreaksStage = '';
            state.historicStreaksSortConfig = { key: null, direction: null };

            // Load league data if not already loaded
            if (!state.loadedLeagues || !state.loadedLeagues.has(newLeague)) {
                await loadLeagueDataForDevice(newLeague);
            } else {
                // If already loaded, just filter/update UI
                filterDataForCurrentLeague(newLeague);
            }

            createTeamStreaksLeagueButtons();
            updateTeamStreaksSelects();
        }

        // Handle Team Streaks status change
        function handleTeamStreaksStatusChange(status) {
            calculateTeamStreaks();
        }
        // Handle Team Streaks location change
        function handleTeamStreaksLocationChange(location) {
            calculateTeamStreaks();
        }

        // Handle Team Streaks type change
        function handleTeamStreaksTypeChange(type) {
            calculateTeamStreaks();
        }

        // Handle Team Streaks Team 1 selection
        function handleTeamStreaksTeam1Change(team) {
            calculateTeamStreaks();
        }

        // Handle Team Streaks Team 2 selection  
        function handleTeamStreaksTeam2Change(team) {
            calculateTeamStreaks();
        }

        // Handle Team Streaks stage change
        function handleTeamStreaksChange() {
            calculateTeamStreaks();
        }

        // Calculate and display team streaks
        function calculateTeamStreaks() {
            const team1 = elements.teamStreaksTeam1Select.value;
            const team2 = elements.teamStreaksTeam2Select.value;
            const status = elements.teamStreaksStatusSelect.value;
            const location = elements.teamStreaksLocationSelect.value;
            const streakType = elements.teamStreaksTypeSelect.value;
            const stage = state.teamStreaksStage;
            
            if (!team1) {
                elements.teamStreaksResults.classList.add('hidden');
                return;
            }
            
            // Handle different status modes
            if (status === 'active') {
                calculateActiveStreaks(team1, team2, location, streakType, stage);
            } else if (status === 'historic') {
                calculateHistoricStreaks(team1, team2, location, streakType, stage);
            }
        }
        
        // Calculate active streaks (original logic)
        function calculateActiveStreaks(team1, team2, location, streakType, stage) {

            // Use all Champions League data (no division filtering needed)
            let matches = state.data;
            
            // Apply qualifier exclusion filter if enabled
            if (state.excludeQualifiers) {
                matches = matches.filter(row => !row.isQualifier);
            }
            
            // Apply main stage exclusion filter if enabled
            if (state.excludeMainStage) {
                matches = matches.filter(row => row.isQualifier);
            }
            
            // Filter by teams
            if (team2) {
                // Two teams selected - head-to-head matches only
                matches = matches.filter(row => 
                    (row.HomeTeam === team1 && row.AwayTeam === team2) ||
                    (row.HomeTeam === team2 && row.AwayTeam === team1)
                );
            } else {
                // One team selected - matches against all opponents
                matches = matches.filter(row => 
                    row.HomeTeam === team1 || row.AwayTeam === team1
                );
            }

            // Filter by location
            if (location === 'home') {
                matches = matches.filter(row => row.HomeTeam === team1);
            } else if (location === 'away') {
                matches = matches.filter(row => row.AwayTeam === team1);
            }
            // 'both' requires no additional filtering

            // Filter by stage
            if (stage !== '') {
                matches = matches.filter(row => matchesStageCategory(row.CompetitionPhase, stage));
            }

            // Sort matches by date (most recent first)
            matches.sort((a, b) => new Date(b.dateObj) - new Date(a.dateObj));

            // Calculate streak based on type
            const streak = calculateStreak(matches, team1, streakType);
            
            // Display results
            displayStreakResults(streak, team1, team2, streakType, location);
        }
        
        // Calculate historic streaks - find all streaks of 3+ games throughout history
        function calculateHistoricStreaks(team1, team2, location, streakType, stage) {
            // Check if data is loaded
            if (!state.data || state.data.length === 0) {
                elements.teamStreaksResults.innerHTML = `
                    <div class="text-center py-8">
                        <p class="text-gray-600">Loading data...</p>
                    </div>
                `;
                elements.teamStreaksResults.classList.remove('hidden');
                return;
            }
            
            // Reset sort config when parameters change (except when called from sort handler)
            const currentParams = `${team1}-${team2}-${location}-${streakType}`;
            if (!state.lastHistoricStreaksParams || state.lastHistoricStreaksParams !== currentParams) {
                state.historicStreaksSortConfig = { key: null, direction: null };
                state.lastHistoricStreaksParams = currentParams;
            }
            
            // Use all Champions League data (no division filtering needed)
            let matches = state.data;
            
            // Apply qualifier exclusion filter if enabled
            if (state.excludeQualifiers) {
                matches = matches.filter(row => !row.isQualifier);
            }
            
            // Apply main stage exclusion filter if enabled
            if (state.excludeMainStage) {
                matches = matches.filter(row => row.isQualifier);
            }
            
            // Filter by teams
            if (team2) {
                // Two teams selected - head-to-head matches only
                matches = matches.filter(row => 
                    (row.HomeTeam === team1 && row.AwayTeam === team2) ||
                    (row.HomeTeam === team2 && row.AwayTeam === team1)
                );
            } else {
                // One team selected - matches against all opponents
                matches = matches.filter(row => 
                    row.HomeTeam === team1 || row.AwayTeam === team1
                );
            }

            // Filter by location
            if (location === 'home') {
                matches = matches.filter(row => row.HomeTeam === team1);
            } else if (location === 'away') {
                matches = matches.filter(row => row.AwayTeam === team1);
            }

            // Filter by stage
            if (stage !== '') {
                matches = matches.filter(row => matchesStageCategory(row.CompetitionPhase, stage));
            }

            // Sort matches by date (oldest first for historic analysis)
            matches.sort((a, b) => new Date(a.dateObj) - new Date(b.dateObj));

            // Find all historic streaks
            const allStreaks = findAllHistoricStreaks(matches, team1, streakType);
            
            // Filter streaks to only include those with 3+ games
            const significantStreaks = allStreaks.filter(streak => streak.count >= 3);
            
            // Display results
            displayHistoricStreaksResults(significantStreaks, team1, team2, streakType, location);
        }
        
        // Find all historic streaks throughout the data
        function findAllHistoricStreaks(matches, team, streakType) {
            if (matches.length === 0) return [];
            
            const allStreaks = [];
            let currentStreak = [];
            
            for (const match of matches) {
                const isHome = match.HomeTeam === team;
                const teamScore = isHome ? parseInt(match.FTHG) || 0 : parseInt(match.FTAG) || 0;
                const opponentScore = isHome ? parseInt(match.FTAG) || 0 : parseInt(match.FTHG) || 0;
                
                let result;
                if (teamScore > opponentScore) {
                    result = 'win';
                } else if (teamScore === opponentScore) {
                    result = 'draw';
                } else {
                    result = 'loss';
                }

                // Check if this match continues the current streak
                const continuesStreak = checkStreakContinuation(result, streakType);
                
                if (continuesStreak) {
                    currentStreak.push({
                        ...match,
                        result: result,
                        teamScore: teamScore,
                        opponentScore: opponentScore,
                        isHome: isHome
                    });
                } else {
                    // Current streak ends, save it if it exists
                    if (currentStreak.length > 0) {
                        const startDate = currentStreak[0].dateObj;
                        const endDate = match.dateObj; // Use the match that broke the streak as the end date
                        const lengthInDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
                        
                        allStreaks.push({
                            matches: [...currentStreak],
                            count: currentStreak.length,
                            startDate: startDate,
                            endDate: endDate,
                            lengthInDays: lengthInDays,
                            streakType: streakType
                        });
                    }
                    
                    // Reset current streak since this match doesn't continue it
                    currentStreak = [];
                }
            }
            
            // Don't forget the last streak if it exists
            if (currentStreak.length > 0) {
                const startDate = currentStreak[0].dateObj;
                const endDate = currentStreak[currentStreak.length - 1].dateObj;
                const lengthInDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
                
                allStreaks.push({
                    matches: [...currentStreak],
                    count: currentStreak.length,
                    startDate: startDate,
                    endDate: endDate,
                    lengthInDays: lengthInDays,
                    streakType: streakType
                });
            }
            
            return allStreaks;
        }
        
        // Get sort icon for historic streaks columns
        function getSortIcon(columnKey) {
            if (state.historicStreaksSortConfig.key !== columnKey) {
                return ' ‚ÜïÔ∏è'; // Up-down arrows when not sorted (sortable indicator)
            }
            
            switch (state.historicStreaksSortConfig.direction) {
                case 'desc': return ' ‚Üì';
                case 'asc': return ' ‚Üë';
                default: return ' ‚ÜïÔ∏è';
            }
        }
        
        // Handle historic streaks table sorting
        function handleHistoricStreaksSort(columnKey) {
            // Determine next sort direction (tri-state: desc ‚Üí asc ‚Üí reset)
            let nextDirection;
            if (state.historicStreaksSortConfig.key !== columnKey || state.historicStreaksSortConfig.direction === null) {
                nextDirection = 'desc'; // First click: descending (largest/most recent first)
            } else if (state.historicStreaksSortConfig.direction === 'desc') {
                nextDirection = 'asc';  // Second click: ascending (smallest/oldest first)
            } else {
                nextDirection = null;   // Third click: reset to original order
            }
            
            // Update sort config
            state.historicStreaksSortConfig.key = nextDirection ? columnKey : null;
            state.historicStreaksSortConfig.direction = nextDirection;
            
            // Re-trigger the calculation to refresh the display with new sorting
            calculateTeamStreaks();
        }
        
        // Display historic streaks results in table format
        function displayHistoricStreaksResults(streaks, team1, team2, streakType, location) {
            if (streaks.length === 0) {
                elements.teamStreaksResults.innerHTML = `
                    <div class="text-center py-8">
                        <p class="text-gray-600">No historic ${streakType.replace('-', ' ')} streaks of 3+ games found for the selected criteria.</p>
                    </div>
                `;
                elements.teamStreaksResults.classList.remove('hidden');
                return;
            }

            // Apply custom sorting if requested, otherwise use default sorting
            if (state.historicStreaksSortConfig.key && state.historicStreaksSortConfig.direction) {
                const sortKey = state.historicStreaksSortConfig.key;
                const sortDirection = state.historicStreaksSortConfig.direction;
                
                streaks.sort((a, b) => {
                    let aVal = a[sortKey];
                    let bVal = b[sortKey];
                    
                    // Handle date sorting
                    if (sortKey === 'startDate' || sortKey === 'endDate') {
                        aVal = new Date(aVal);
                        bVal = new Date(bVal);
                    }
                    
                    // Sort based on direction
                    if (sortDirection === 'desc') {
                        return bVal > aVal ? 1 : bVal < aVal ? -1 : 0;
                    } else {
                        return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                    }
                });
            } else {
                // Default sorting: by count (longest first), then by end date (most recent first)
                streaks.sort((a, b) => {
                    if (b.count !== a.count) return b.count - a.count;
                    return new Date(b.endDate) - new Date(a.endDate);
                });
            }

            // Create title
            const streakName = getStreakDisplayName(streakType);
            const locationText = location === 'both' ? '' : ` (${location.charAt(0).toUpperCase() + location.slice(1)})`;
            const team1Color = getTeamColor(team1, state.selectedLeague);
            const team2Color = team2 ? getTeamColor(team2, state.selectedLeague) : null;
            
            let title;
            if (team2) {
                title = `Historic ${streakName}s${locationText}: <span style="color: ${team1Color || '#374151'}; font-weight: bold;">${team1}</span> vs <span style="color: ${team2Color || '#374151'}; font-weight: bold;">${team2}</span>`;
            } else {
                title = `<span style="color: ${team1Color || '#374151'}; font-weight: bold;">${team1}</span>'s Historic ${streakName}s${locationText}`;
            }

            // Create table headers based on mode (single team vs head-to-head)
            let tableHeaders;
            if (team2) {
                // Head-to-head mode
                tableHeaders = `
                    <th class="text-center">Team 1</th>
                    <th class="text-center">Team 2</th>
                    <th class="text-center cursor-pointer" onclick="handleHistoricStreaksSort('startDate')">Start Date ${getSortIcon('startDate')}</th>
                    <th class="text-center cursor-pointer" onclick="handleHistoricStreaksSort('endDate')">End Date ${getSortIcon('endDate')}</th>
                    <th class="text-center cursor-pointer" onclick="handleHistoricStreaksSort('count')">Count ${getSortIcon('count')}</th>
                    <th class="text-center cursor-pointer" onclick="handleHistoricStreaksSort('lengthInDays')">Length (Days) ${getSortIcon('lengthInDays')}</th>
                `;
            } else {
                // Single team mode - adjust header based on location
                let teamColumnHeader;
                if (location === 'home') {
                    teamColumnHeader = 'Home Team';
                } else if (location === 'away') {
                    teamColumnHeader = 'Away Team';
                } else {
                    teamColumnHeader = 'Team';
                }
                
                tableHeaders = `
                    <th class="text-center">${teamColumnHeader}</th>
                    <th class="text-center cursor-pointer" onclick="handleHistoricStreaksSort('startDate')">Start Date ${getSortIcon('startDate')}</th>
                    <th class="text-center cursor-pointer" onclick="handleHistoricStreaksSort('endDate')">End Date ${getSortIcon('endDate')}</th>
                    <th class="text-center cursor-pointer" onclick="handleHistoricStreaksSort('count')">Count ${getSortIcon('count')}</th>
                    <th class="text-center cursor-pointer" onclick="handleHistoricStreaksSort('lengthInDays')">Length (Days) ${getSortIcon('lengthInDays')}</th>
                `;
            }

            // Create table rows
            const tableRows = streaks.map(streak => {
                const startDateStr = streak.startDate.toLocaleDateString('en-US');
                const endDateStr = streak.endDate.toLocaleDateString('en-US');
                
                if (team2) {
                    // Head-to-head mode
                    const team1Logo = getTeamLogoUrl(team1, state.selectedLeague);
                    const team2Logo = getTeamLogoUrl(team2, state.selectedLeague);
                    
                    return `
                        <tr>
                            <td class="text-center">
                                <div class="flex items-center justify-center">
                                    ${team1Logo ? `<img src="${team1Logo}" alt="${team1}" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                    <span class="team1-highlight" style="color: ${team1Color || '#374151'}; font-weight: bold;">${team1}</span>
                                </div>
                            </td>
                            <td class="text-center">
                                <div class="flex items-center justify-center">
                                    ${team2Logo ? `<img src="${team2Logo}" alt="${team2}" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                    <span class="team2-highlight" style="color: ${team2Color || '#374151'}; font-weight: bold;">${team2}</span>
                                </div>
                            </td>
                            <td class="text-center">${startDateStr}</td>
                            <td class="text-center">${endDateStr}</td>
                            <td class="text-center font-bold">${streak.count}</td>
                            <td class="text-center">${streak.lengthInDays}</td>
                        </tr>
                    `;
                } else {
                    // Single team mode - show team name with logo
                    const teamName = team1;
                    const teamLogo = getTeamLogoUrl(teamName, state.selectedLeague);
                    const teamColor = getTeamColor(teamName, state.selectedLeague);
                    
                    return `
                        <tr>
                            <td class="text-center">
                                <div class="flex items-center justify-center">
                                    ${teamLogo ? `<img src="${teamLogo}" alt="${teamName}" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                    <span class="team1-highlight" style="color: ${teamColor || '#374151'}; font-weight: bold;">${teamName}</span>
                                </div>
                            </td>
                            <td class="text-center">${startDateStr}</td>
                            <td class="text-center">${endDateStr}</td>
                            <td class="text-center font-bold">${streak.count}</td>
                            <td class="text-center">${streak.lengthInDays}</td>
                        </tr>
                    `;
                }
            }).join('');

            const tableHTML = `
                <div class="league-table">
                    <div class="text-center py-4 bg-white border-b">
                        <h2 class="text-xl font-semibold text-gray-700 mb-1">${title}</h2>
                        <p class="text-sm text-gray-600">${streaks.length} streak${streaks.length === 1 ? '' : 's'} of 3+ games found</p>
                    </div>
                    <table>
                        <thead>
                            <tr>
                                ${tableHeaders}
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                </div>
            `;

            elements.teamStreaksResults.innerHTML = tableHTML;
            elements.teamStreaksResults.classList.remove('hidden');
        }

        // Calculate streak based on type and team
        function calculateStreak(matches, team, streakType) {
            if (matches.length === 0) return [];

            const streak = [];
            
            for (const match of matches) {
                const isHome = match.HomeTeam === team;
                const teamScore = isHome ? parseInt(match.FTHG) || 0 : parseInt(match.FTAG) || 0;
                const opponentScore = isHome ? parseInt(match.FTAG) || 0 : parseInt(match.FTHG) || 0;
                
                let result;
                if (teamScore > opponentScore) {
                    result = 'win';
                } else if (teamScore === opponentScore) {
                    result = 'draw';
                } else {
                    result = 'loss';
                }

                // Check if this match continues the streak
                const continuesStreak = checkStreakContinuation(result, streakType);
                
                if (continuesStreak) {
                    streak.push({
                        ...match,
                        result: result,
                        teamScore: teamScore,
                        opponentScore: opponentScore,
                        isHome: isHome
                    });
                } else {
                    // Streak ends here
                    break;
                }
            }

            return streak;
        }

        // Check if a result continues the current streak type
        function checkStreakContinuation(result, streakType) {
            switch (streakType) {
                case 'winning':
                    return result === 'win';
                case 'unbeaten':
                    return result === 'win' || result === 'draw';
                case 'draw':
                    return result === 'draw';
                case 'winless':
                    return result === 'draw' || result === 'loss';
                case 'losing':
                    return result === 'loss';
                default:
                    return false;
            }
        }

        // Display streak results in table format
        function displayStreakResults(streak, team1, team2, streakType, location) {
            if (streak.length === 0) {
                elements.teamStreaksResults.innerHTML = `
                    <div class="text-center py-8">
                        <p class="text-gray-600">No current ${streakType.replace('-', ' ')} streak found for the selected criteria.</p>
                    </div>
                `;
                elements.teamStreaksResults.classList.remove('hidden');
                return;
            }

            // Find the opposite result match
            const oppositeMatch = findOppositeResultMatch(team1, team2, streakType, location);

            // Create title with team colors
            const streakLength = streak.length;
            const streakName = getStreakDisplayName(streakType);
            const locationText = location === 'both' ? '' : ` (${location.charAt(0).toUpperCase() + location.slice(1)})`;
            
            // Get team colors
            const team1Color = getTeamColor(team1, state.selectedLeague);
            const team2Color = team2 ? getTeamColor(team2, state.selectedLeague) : null;
            
            let title;
            if (team2) {
                // Two-team mode: Both teams with their colors
                title = `<span style="color: ${team1Color || '#374151'}; font-weight: bold;">${team1}</span>'s Current ${streakName}${locationText} vs <span style="color: ${team2Color || '#374151'}; font-weight: bold;">${team2}</span>: ${streakLength} ${streakLength === 1 ? 'match' : 'matches'}`;
            } else {
                // Single-team mode: Just Team 1 with color
                title = `<span style="color: ${team1Color || '#374151'}; font-weight: bold;">${team1}</span>'s Current ${streakName}${locationText}: ${streakLength} ${streakLength === 1 ? 'match' : 'matches'}`;
            }

            // Calculate days since streak started (oldest match in streak)
            const streakStartDate = streak[streak.length - 1].dateObj;
            const daysSinceStreakStart = Math.floor((new Date() - streakStartDate) / (1000 * 60 * 60 * 24));

            // Create main streak table
            let tableHTML = `
                <div class="league-table mb-4">
                    <div class="text-center py-4 bg-white border-b">
                        <h2 class="text-xl font-semibold text-gray-700 mb-1">${title}</h2>
                        <p class="text-sm text-gray-600">Most recent matches first</p>
                    </div>
                    <table>
                        <thead>
                            <tr>
                                <th class="text-center cursor-pointer">Date</th>
                                <th class="text-center cursor-pointer">Home Team</th>
                                <th class="text-center cursor-pointer">Home Score</th>
                                <th class="text-center cursor-pointer">Away Team</th>
                                <th class="text-center cursor-pointer">Away Score</th>
                                <th class="text-center cursor-pointer">Result</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${streak.map(match => createStreakTableRow(match, team1)).join('')}
                        </tbody>
                    </table>
                </div>
                <p class="text-center text-sm text-gray-600 mb-8">This streak started: ${daysSinceStreakStart} days ago</p>
            `;

            // Add opposite result table if found
            if (oppositeMatch) {
                const oppositeResultName = getOppositeResultDisplayName(streakType);
                
                // Create opposite title with team colors
                let oppositeTitle;
                if (team2) {
                    // Two-team mode: Both teams with their colors
                    oppositeTitle = `Last ${oppositeResultName} Result${locationText} (<span style="color: ${team1Color || '#374151'}; font-weight: bold;">${team1}</span> vs <span style="color: ${team2Color || '#374151'}; font-weight: bold;">${team2}</span>)`;
                } else {
                    // Single-team mode: Just Team 1 with color
                    oppositeTitle = `<span style="color: ${team1Color || '#374151'}; font-weight: bold;">${team1}</span>'s Last ${oppositeResultName} Result${locationText}`;
                }
                
                // Calculate days since opposite result
                const daysSinceOpposite = Math.floor((new Date() - oppositeMatch.dateObj) / (1000 * 60 * 60 * 24));

                tableHTML += `
                    <div class="league-table mb-4">
                        <div class="text-center py-4 bg-white border-b">
                            <h2 class="text-xl font-semibold text-gray-700 mb-1">${oppositeTitle}</h2>
                            <p class="text-sm text-gray-600">The match that ended the previous streak</p>
                        </div>
                        <table>
                            <thead>
                                <tr>
                                    <th class="text-center cursor-pointer">Date</th>
                                    <th class="text-center cursor-pointer">Home Team</th>
                                    <th class="text-center cursor-pointer">Home Score</th>
                                    <th class="text-center cursor-pointer">Away Team</th>
                                    <th class="text-center cursor-pointer">Away Score</th>
                                    <th class="text-center cursor-pointer">Result</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${createStreakTableRow(oppositeMatch, team1)}
                            </tbody>
                        </table>
                    </div>
                    <p class="text-center text-sm text-gray-600">The last time the opposite happened was: ${daysSinceOpposite} days ago</p>
                `;
            } else {
                tableHTML += `<p class="text-center text-sm text-gray-600">No previous opposite result found in available data</p>`;
            }

            elements.teamStreaksResults.innerHTML = tableHTML;
            elements.teamStreaksResults.classList.remove('hidden');
        }

        // Find the match where the opposite result occurred
        function findOppositeResultMatch(team1, team2, streakType, location) {
            // Use all Champions League data (no division filtering needed)
            let matches = state.data;
            
            // Apply qualifier exclusion filter if enabled
            if (state.excludeQualifiers) {
                matches = matches.filter(row => !row.isQualifier);
            }
            
            // Apply main stage exclusion filter if enabled
            if (state.excludeMainStage) {
                matches = matches.filter(row => row.isQualifier);
            }
            
            // Filter by teams
            if (team2) {
                matches = matches.filter(row => 
                    (row.HomeTeam === team1 && row.AwayTeam === team2) ||
                    (row.HomeTeam === team2 && row.AwayTeam === team1)
                );
            } else {
                matches = matches.filter(row => 
                    row.HomeTeam === team1 || row.AwayTeam === team1
                );
            }

            // Filter by location
            if (location === 'home') {
                matches = matches.filter(row => row.HomeTeam === team1);
            } else if (location === 'away') {
                matches = matches.filter(row => row.AwayTeam === team1);
            }

            // Sort matches by date (most recent first)
            matches.sort((a, b) => new Date(b.dateObj) - new Date(a.dateObj));

            // Find the first match that doesn't continue the current streak
            for (const match of matches) {
                const isHome = match.HomeTeam === team1;
                const teamScore = isHome ? parseInt(match.FTHG) || 0 : parseInt(match.FTAG) || 0;
                const opponentScore = isHome ? parseInt(match.FTAG) || 0 : parseInt(match.FTHG) || 0;
                
                let result;
                if (teamScore > opponentScore) {
                    result = 'win';
                } else if (teamScore === opponentScore) {
                    result = 'draw';
                } else {
                    result = 'loss';
                }

                // Check if this is an opposite result
                const isOppositeResult = checkOppositeResult(result, streakType);
                
                if (isOppositeResult) {
                    return match;
                }
            }

            return null;
        }

        // Check if a result is opposite to the current streak type
        function checkOppositeResult(result, streakType) {
            switch (streakType) {
                case 'winning':
                    return result === 'draw' || result === 'loss'; // Non-win
                case 'unbeaten':
                    return result === 'loss'; // Loss
                case 'draw':
                    return result === 'win' || result === 'loss'; // Non-draw
                case 'winless':
                    return result === 'win'; // Win
                case 'losing':
                    return result === 'draw' || result === 'win'; // Non-loss
                default:
                    return false;
            }
        }

        // Get display name for opposite result
        function getOppositeResultDisplayName(streakType) {
            switch (streakType) {
                case 'winning': return 'Non-Win (Draw/Loss)';
                case 'unbeaten': return 'Loss';
                case 'draw': return 'Non-Draw (Win/Loss)';
                case 'winless': return 'Win';
                case 'losing': return 'Non-Loss (Draw/Win)';
                default: return 'Opposite';
            }
        }

        // Get display name for streak type
        function getStreakDisplayName(streakType) {
            switch (streakType) {
                case 'winning': return 'Winning Streak';
                case 'unbeaten': return 'Unbeaten Streak';
                case 'draw': return 'Draw Streak';
                case 'winless': return 'Winless Streak';
                case 'losing': return 'Losing Streak';
                default: return 'Streak';
            }
        }

        // Create table row for streak display (similar to Head-to-Head format)
        function createStreakTableRow(match, focusTeam) {
            const homeScore = parseInt(match.FTHG) || 0;
            const awayScore = parseInt(match.FTAG) || 0;
            
            // Get team colors and logos
            const homeTeamColor = getTeamColor(match.HomeTeam, state.selectedLeague);
            const awayTeamColor = getTeamColor(match.AwayTeam, state.selectedLeague);
            const homeLogoUrl = getTeamLogoUrl(match.HomeTeam, state.selectedLeague);
            const awayLogoUrl = getTeamLogoUrl(match.AwayTeam, state.selectedLeague);
            
            // Determine winner and highlighting
            let homeScoreClass = '';
            let awayScoreClass = '';
            let resultStyle = '';
            let winnerTeam = '';
            
            if (homeScore > awayScore) {
                winnerTeam = match.HomeTeam;
                homeScoreClass = 'font-bold win-score';
                awayScoreClass = 'text-red-600 font-bold';
                resultStyle = homeTeamColor ?
                    `color: ${homeTeamColor} !important; font-weight: bold;` :
                    'color: #059669 !important; font-weight: bold;';
            } else if (awayScore > homeScore) {
                winnerTeam = match.AwayTeam;
                homeScoreClass = 'text-red-600 font-bold';
                awayScoreClass = 'font-bold win-score';
                resultStyle = awayTeamColor ?
                    `color: ${awayTeamColor} !important; font-weight: bold;` :
                    'color: #059669 !important; font-weight: bold;';
            } else {
                winnerTeam = 'Draw';
                homeScoreClass = 'text-gray-400 font-bold draw-score';
                awayScoreClass = 'text-gray-400 font-bold draw-score';
                resultStyle = 'color: #9ca3af !important; font-weight: bold;';
            }

            // Get selected teams for highlighting
            const team1 = elements.teamStreaksTeam1Select.value;
            const team2 = elements.teamStreaksTeam2Select.value;

            // Team highlighting based on selected teams (same as Head-to-Head)
            const isHomeTeam1 = match.HomeTeam === team1;
            const isHomeTeam2 = team2 && match.HomeTeam === team2;
            const isAwayTeam1 = match.AwayTeam === team1;
            const isAwayTeam2 = team2 && match.AwayTeam === team2;
            
            const homeTeamClass = isHomeTeam1 ? 'team1-highlight' : 
                                isHomeTeam2 ? 'team2-highlight' : '';
            const awayTeamClass = isAwayTeam1 ? 'team1-highlight' : 
                                isAwayTeam2 ? 'team2-highlight' : '';
            
            // Winner logo for result column
            const winnerLogoUrl = winnerTeam !== 'Draw' ? getTeamLogoUrl(winnerTeam, state.selectedLeague) : null;
            
            // Result highlighting for winner (if it's one of the selected teams)
            let resultClass = '';
            if (winnerTeam !== 'Draw') {
                if (winnerTeam === team1) {
                    resultClass = 'team1-highlight';
                } else if (team2 && winnerTeam === team2) {
                    resultClass = 'team2-highlight';
                }
            }
            
            // Team styling
            const homeTeamStyle = homeTeamColor ? `color: ${homeTeamColor} !important; font-weight: bold;` : 'font-weight: bold;';
            const awayTeamStyle = awayTeamColor ? `color: ${awayTeamColor} !important; font-weight: bold;` : 'font-weight: bold;';
            
            return `
                <tr class="border-b hover:bg-gray-50">
                    <td class="text-center text-sm">${match.dateObj.toLocaleDateString()}</td>
                    <td class="text-center">
                        <div class="flex items-center justify-center">
                            ${homeLogoUrl ? `<img src="${homeLogoUrl}" alt="${match.HomeTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                            <span class="${homeTeamClass}" style="${homeTeamStyle}">${match.HomeTeam}</span>
                        </div>
                    </td>
                    <td class="text-center text-lg ${homeScoreClass}" >${homeScore}</td>
                    <td class="text-center">
                        <div class="flex items-center justify-center">
                            ${awayLogoUrl ? `<img src="${awayLogoUrl}" alt="${match.AwayTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                            <span class="${awayTeamClass}" style="${awayTeamStyle}">${match.AwayTeam}</span>
                        </div>
                    </td>
                    <td class="text-center text-lg ${awayScoreClass}" >${awayScore}</td>
                    <td class="text-center">
                        <div class="flex items-center justify-center">
                            ${winnerLogoUrl ? `<img src="${winnerLogoUrl}" alt="${winnerTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                            <span class="${resultClass}" style="${resultStyle}">${winnerTeam}</span>
                        </div>
                    </td>
                </tr>
            `;
        }

        // Initialize the application
        function init() {
            setupEventListeners();
            createLeagueButtons();
            createTeamSeasonsLeagueButtons();
            populateRecentH2HOptions();
            updateCompetitionStageOptions(); // Set initial dropdown options
            updateUI();
            // Auto-load data on page load
            loadGistData();
        }

        // Decode base64 encoded URL with backward compatibility for double encoding
        function decodeSingleBase64Url(encodedUrl) {
            try {
                // Validate input
                if (!encodedUrl || typeof encodedUrl !== 'string') {
                    console.warn('Invalid encoded URL provided');
                    return null;
                }
                
                // Clean the input
                const cleanedInput = encodedUrl.trim().replace(/\s/g, '');
                
                // Try single decode first
                let decoded;
                try {
                    decoded = atob(cleanedInput);
                } catch (atobError) {
                    console.error('Base64 decode failed:', atobError.message);
                    return null;
                }
                
                // Check if the result is a valid URL (single encoding)
                if (decoded && decoded.startsWith('https://gist.githubusercontent.com')) {
                    // Successfully decoded single base64 URL
                    return decoded;
                }
                
                // If not a valid URL, try double decode (backward compatibility)
                try {
                    const doubleDecoded = atob(decoded);
                    if (doubleDecoded && doubleDecoded.startsWith('https://gist.githubusercontent.com')) {
                        // Successfully decoded double base64 URL
                        return doubleDecoded;
                    }
                } catch (error) {
                    // Ignore double decode errors
                }
                
                console.warn('Could not decode URL as single or double base64:', encodedUrl.substring(0, 50) + '...');
                return null;
                
            } catch (error) {
                console.error('Error in decodeSingleBase64Url:', error);
                console.error('Stack trace:', error.stack);
                return null;
            }
        }

        // Mobile device detection
        function isMobileDevice() {
            const userAgent = navigator.userAgent.toLowerCase();
            const screenWidth = window.innerWidth;
            
            // Check for explicit mobile indicators (excluding just 'chrome' to avoid false positives)
            const mobileKeywords = ['android', 'iphone', 'ipad', 'ipod', 'tablet', 'phone', 'mobile'];
            const hasMobileUA = mobileKeywords.some(keyword => userAgent.includes(keyword));
            
            // Check for small screen size (less than 768px typically indicates mobile/tablet)
            const hasSmallScreen = screenWidth < 768;
            
            // Touch device detection (more accurate for mobile)
            const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            // Only consider mobile if we have explicit mobile UA AND (small screen OR touch)
            return hasMobileUA && (hasSmallScreen || hasTouchScreen);
        }
        
        // Load data from GitHub Gists - now uses league-specific loading for all devices
        async function loadGistData() {
            // Using league-specific loading for optimal performance
            await loadLeagueDataForDevice(state.selectedLeague);
        }
        
        // Universal league-specific loading for all devices
        async function loadLeagueDataForDevice(leagueId) {
            // Loading data for league
            
            // Check if already loaded
            if (state.loadedLeagues && state.loadedLeagues.has(leagueId)) {
                // League already loaded, filtering existing data
                filterDataForCurrentLeague(leagueId);
                return;
            }
            
            // Initialize loadedLeagues if not exists
            if (!state.loadedLeagues) {
                state.loadedLeagues = new Set();
            }
            
            // Initialize allLeagueData to store all data if not exists
            if (!state.allLeagueData) {
                state.allLeagueData = [];
            }
            
            // Prevent double loading
            if (state.currentlyLoadingLeague === leagueId) {
                // League already loading, please wait
                return;
            }
            
            state.currentlyLoadingLeague = leagueId;
            state.error = '';
            
            // Show loading indicator
            const leagueName = getLeagueName(leagueId);
            state.error = `‚öΩ Loading ${leagueName} data...`;
            updateUI();
            
            try {
                // Load ALL gist URLs since each contains data for all leagues
                const gistUrls = GIST_URLS;
                
                // Fetching files (contains all leagues)
                const allData = [];
                
                for (let i = 0; i < gistUrls.length; i++) {
                    const encodedUrl = gistUrls[i];
                    
                    try {
                        const url = decodeSingleBase64Url(encodedUrl);
                        if (!url) {
                            console.warn(`Skipping invalid URL at index ${i}`);
                            continue;
                        }
                        
                        // Check for obviously malformed URLs
                        if (!url.startsWith('http')) {
                            console.warn(`Skipping malformed URL at index ${i}: ${url.substring(0, 50)}...`);
                            continue;
                        }
                        
                        // Fetching URL
                        
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 15000);
                        
                        const response = await fetch(url, { 
                            signal: controller.signal,
                            headers: { 'Accept': 'text/csv,text/plain,*/*' }
                        });
                        clearTimeout(timeoutId);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const text = await response.text();
                        if (!text || text.length === 0) {
                            throw new Error('Empty response from server');
                        }
                        
                        const parsed = Papa.parse(text, { 
                            header: true, 
                            dynamicTyping: false,
                            skipEmptyLines: true,
                            transformHeader: (header) => header.trim().replace(/\r/g, ''),
                            transform: (value) => typeof value === 'string' ? value.trim().replace(/\r/g, '') : value
                        });
                        
                        if (parsed.errors && parsed.errors.length > 0) {
                            console.warn('CSV parsing errors:', parsed.errors);
                        }
                        
                        if (parsed.data && parsed.data.length > 0) {
                            // Successfully parsed rows - process qualifier data
                            const processedData = processQualifierData(parsed.data, encodedUrl);
                            allData.push(...processedData);
                        }
                        
                        // Update progress
                        const progress = Math.round(((i + 1) / gistUrls.length) * 100);
                        state.error = `‚öΩ Loading data... ${progress}%`;
                        updateUI();
                        
                        // Small delay to keep UI responsive
                        await new Promise(resolve => setTimeout(resolve, 50));
                        
                    } catch (fileError) {
                        console.warn(`Failed to load file ${i}:`, fileError.message);
                    }
                }
                
                // Process all the raw data
                // Processing all league data
                const cleanedData = processRawData(allData);
                
                if (cleanedData.length === 0) {
                    throw new Error(`No valid match data found`);
                }
                
                // Store all data for future league switches
                state.allLeagueData = cleanedData;
                
                // Mark all leagues as loaded since we loaded everything
                state.loadedLeagues.add('serie-a');
                state.loadedLeagues.add('premier-league');
                state.loadedLeagues.add('la-liga');
                state.loadedLeagues.add('bundesliga');
                state.loadedLeagues.add('ligue-1');
                
                state.currentlyLoadingLeague = null;
                state.error = '';
                
                // Filter data for the requested league
                filterDataForCurrentLeague(leagueId);
                
                // All data loaded successfully
                updateLastDataUpdate();

            } catch (error) {
                console.error(`Error loading data:`, error);
                state.error = `Failed to load data: ${error.message}`;
                state.currentlyLoadingLeague = null;
                updateUI();
            }
        }
        
        // Get human-readable league name
        function getLeagueName(leagueId) {
            const leagueMap = {
                'champions-league': 'Champions League',
                'europa-league': 'Europa League',
                'conference-league': 'Conference League'
            };
            return leagueMap[leagueId] || leagueId;
        }
        
        // Filter existing data for current league (when switching between loaded leagues)
        function filterDataForCurrentLeague(leagueId) {
            if (!state.allLeagueData || state.allLeagueData.length === 0) return;
            
            const leagueCode = LEAGUE_CODES[leagueId];
            if (!leagueCode) {
                console.warn(`Unknown league ID: ${leagueId}`);
                return;
            }
            
            // Filter data for the specific league
            const filteredData = state.allLeagueData.filter(row => row.Div === leagueCode);
            
            // Filtered matches for league
            
            // Update state with filtered data
            state.data = filteredData;
            
            // Update teams list for this league
            const allTeams = [...new Set([
                ...filteredData.map(row => row.HomeTeam),
                ...filteredData.map(row => row.AwayTeam)
            ])].filter(team => team && team.length > 1).sort();
            
            state.teams = allTeams;
            
            // Update date range for this league
            if (filteredData.length > 0) {
                const dates = filteredData.map(row => row.dateObj);
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                
                state.dateFrom = minDate.toISOString().split('T')[0];
                state.dateTo = maxDate.toISOString().split('T')[0];
            }
            
            // Update the UI with filtered data
            updateUI();
            updateTeamSelects();
            updateTeamSeasonsTeamSelect();
            updateSeasonOptions();
            updateLastDataUpdate();
            updateTable();
        }
        
        // Chunked loading for desktop browsers (prevents stack overflow)
        async function loadGistDataChunked() {
            const gistUrls = GIST_URLS;
            
            state.error = '';
            // Starting chunked data load

            try {
                const allData = [];
                let loadedGists = 0;
                
                // Process files in smaller batches to prevent stack overflow
                const batchSize = 5; // Process 5 files at a time
                
                for (let batchStart = 0; batchStart < gistUrls.length; batchStart += batchSize) {
                    const batchEnd = Math.min(batchStart + batchSize, gistUrls.length);
                    // Processing batch
                    
                    // Process batch of files
                    for (let i = batchStart; i < batchEnd; i++) {
                    const encodedUrl = gistUrls[i];
                    // Processing URL
                    
                    const url = decodeSingleBase64Url(encodedUrl);
                    
                    // Skip if URL decoding failed
                    if (!url) {
                        console.warn(`Skipping invalid URL at index ${i}`);
                        continue;
                    }
                    
                    try {
                        // Fetching URL
                        
                        // Add timeout to fetch
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                        
                        const response = await fetch(url, { 
                            signal: controller.signal,
                            headers: {
                                'Accept': 'text/csv,text/plain,*/*'
                            }
                        });
                        clearTimeout(timeoutId);
                        if (!response.ok) {
                            if (response.status === 404) {
                                console.warn(`File not found (404) at index ${i}, skipping: ${url.substring(url.lastIndexOf('/') + 1)}`);
                                continue;
                            }
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const text = await response.text();
                        // Received CSV data
                        
                        if (!text || text.length === 0) {
                            throw new Error('Empty response from server');
                        }
                        
                        const parsed = Papa.parse(text, { 
                            header: true, 
                            dynamicTyping: false,
                            skipEmptyLines: true,
                            transformHeader: (header) => header.trim().replace(/\r/g, ''),
                            transform: (value) => typeof value === 'string' ? value.trim().replace(/\r/g, '') : value
                        });
                        
                        if (parsed.errors && parsed.errors.length > 0) {
                            console.warn('CSV parsing errors:', parsed.errors);
                        }
                        
                        if (parsed.data && parsed.data.length > 0) {
                            // Successfully parsed rows from file
                            
                            // Always use chunked processing for desktop stability
                            if (parsed.data.length > 500) {
                                // Process in chunks for all browsers
                                const chunkSize = 300;
                                for (let i = 0; i < parsed.data.length; i += chunkSize) {
                                    const chunk = parsed.data.slice(i, i + chunkSize);
                                    allData.push(...chunk);
                                    
                                    // Small delay to prevent stack overflow
                                    if (i + chunkSize < parsed.data.length) {
                                        await new Promise(resolve => setTimeout(resolve, 25));
                                    }
                                }
                            } else {
                                allData.push(...parsed.data);
                            }
                            loadedGists++;
                        } else {
                            console.warn('No data found in parsed CSV');
                        }
                    } catch (gistError) {
                        console.warn(`Failed to load ${url}:`, gistError.message);
                    }
                    
                    // Small delay between files within batch
                    if (i < batchEnd - 1) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    }
                    
                    // Delay between batches to prevent stack overflow  
                    if (batchEnd < gistUrls.length) {
                        const progress = Math.round((batchEnd / gistUrls.length) * 100);
                        state.error = `üîÑ Loading data... ${progress}% complete (${loadedGists} files processed)`;
                        updateUI();
                        // Batch complete
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                if (loadedGists === 0) {
                    throw new Error('No valid data could be loaded from any Gist');
                }
                
                // Clear loading message and show processing status
                state.error = '‚öôÔ∏è Processing data...';
                updateUI();
                
                // Process the data
                // Starting data processing
                const cleanedData = processRawData(allData);
                // Data processing completed
                
                if (cleanedData.length === 0) {
                    throw new Error('No valid match data found in the loaded Gists');
                }
                
                const allTeams = [...new Set([
                    ...cleanedData.map(row => row.HomeTeam), 
                    ...cleanedData.map(row => row.AwayTeam)
                ])]
                    .filter(team => team && team.length > 1)
                    .sort();
                
                const dates = cleanedData.map(row => row.dateObj);
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                
                state.data = cleanedData;
                state.teams = allTeams;
                state.dateFrom = minDate.toISOString().split('T')[0];
                state.dateTo = maxDate.toISOString().split('T')[0];
                state.error = ''; // Clear loading message
                
                // Data loaded successfully
                updateUI();
                updateTeamSelects();
                updateTeamSeasonsTeamSelect();
                updateSeasonOptions();
                updateTable();
                
            } catch (error) {
                console.error('Error loading Gist data:', error);
                state.error = error.message;
            } finally {
                updateUI();
            }
        }

        // Process raw CSV data
        function processRawData(allData) {
            const filtered = allData.filter(row => {
                    return row && 
                           row.HomeTeam && 
                           row.AwayTeam && 
                           row.Date &&
                           row.Div &&
                           typeof row.HomeTeam === 'string' &&
                           typeof row.AwayTeam === 'string' &&
                           row.HomeTeam.length > 0 &&
                           row.AwayTeam.length > 0 &&
                           row.Div.length > 0;
                });
            
            const processed = filtered.map(row => {
                    try {
                        let dateStr = String(row.Date).trim().replace(/\r/g, '');
                        let dateObj;
                        
                        if (dateStr.includes('/')) {
                            const parts = dateStr.split('/');
                            if (parts.length === 3) {
                                const day = parseInt(parts[0]);
                                const month = parseInt(parts[1]);
                                let year = parseInt(parts[2]);
                                
                                if (year < 100) {
                                    year = year <= 30 ? 2000 + year : 1900 + year;
                                }
                                
                                dateObj = new Date(year, month - 1, day);
                            }
                        } else if (dateStr.includes('-')) {
                            dateObj = new Date(dateStr);
                        }
                        
                        if (!dateObj || isNaN(dateObj.getTime())) {
                            return null;
                        }
                        
                        dateObj.setHours(0, 0, 0, 0);
                        
                        let homeGoals = 0;
                        let awayGoals = 0;
                        
                        if (row.FTHG !== undefined && row.FTHG !== null && row.FTHG !== '') {
                            homeGoals = parseInt(String(row.FTHG)) || 0;
                        }
                        if (row.FTAG !== undefined && row.FTAG !== null && row.FTAG !== '') {
                            awayGoals = parseInt(String(row.FTAG)) || 0;
                        }
                        
                        return {
                            ...row,
                            dateObj: dateObj,
                            HomeTeam: String(row.HomeTeam).trim().replace(/\r/g, ''),
                            AwayTeam: String(row.AwayTeam).trim().replace(/\r/g, ''),
                            FTHG: homeGoals,
                            FTAG: awayGoals,
                            Div: String(row.Div || '').trim().replace(/\r/g, '')
                        };
                    } catch (parseError) {
                        return null;
                    }
                })
                .filter(row => row !== null);

            // Deduplication logic (commented out - enable if duplicates appear in future)
            /*
            const uniqueMatches = new Map();

            processed.forEach(match => {
                // Try multiple deduplication strategies
                const keys = [
                    // Primary key: exact match with scores
                    `${match.dateObj.getTime()}-${match.HomeTeam}-${match.AwayTeam}-${match.FTHG || 0}-${match.FTAG || 0}`,
                    // Secondary key: match without scores (in case scores differ)
                    `${match.dateObj.getTime()}-${match.HomeTeam}-${match.AwayTeam}`,
                    // Tertiary key: date string format (in case timestamp differs)
                    `${match.dateObj.toISOString().split('T')[0]}-${match.HomeTeam}-${match.AwayTeam}-${match.FTHG || 0}-${match.FTAG || 0}`
                ];

                let isUnique = true;
                for (const key of keys) {
                    if (uniqueMatches.has(key)) {
                        isUnique = false;
                        // If duplicate found, prefer the one with more complete data
                        const existing = uniqueMatches.get(key);
                        if (match.CompetitionPhase && !existing.CompetitionPhase) {
                            uniqueMatches.set(key, match);
                        }
                        break;
                    }
                }

                if (isUnique) {
                    // Store under primary key
                    uniqueMatches.set(keys[0], match);
                }
            });

            return Array.from(uniqueMatches.values());
            */

            return processed;
        }

        // Create league selection buttons
        function createLeagueButtons() {
            const leagues = [
                { id: 'champions-league', name: 'üá™üá∫ Champions League' },
                // { id: 'europa-league', name: 'üá™üá∫ Europa League' },
                // { id: 'conference-league', name: 'üá™üá∫ Conference League' }
            ];

            const leagueButtonsHTML = leagues.map(league => `
                <label class="league-button ${state.selectedLeague === league.id ? 'active' : ''}" data-league="${league.id}">
                    <div class="radio-dot ${state.selectedLeague === league.id ? 'active' : ''}"></div>
                    <span class="text-sm font-medium ${state.selectedLeague === league.id ? 'text-green-700' : 'text-gray-700'}">
                        ${league.name}
                    </span>
                </label>
            `).join('');
            
            elements.leagueButtons.innerHTML = leagueButtonsHTML;
            elements.lastTimeLeagueButtons.innerHTML = leagueButtonsHTML;
        }

        // Populate Recent H2H dropdown options
        function populateRecentH2HOptions() {
            const options = [];
            for (let i = 2; i <= 20; i++) {
                options.push(`<option value="${i}">${i}</option>`);
            }
            options.push('<option value="All">All</option>');
            elements.recentH2HSelect.innerHTML = options.join('');
        }

        // Create league buttons for Team Seasons tab
        function createTeamSeasonsLeagueButtons() {
            const leagues = [
                { id: 'champions-league', name: 'üá™üá∫ Champions League' },
                // { id: 'europa-league', name: 'üá™üá∫ Europa League' },
                // { id: 'conference-league', name: 'üá™üá∫ Conference League' }
            ];

            const leagueButtonsHTML = leagues.map(league => `
                <label class="league-button ${state.teamSeasonsSelectedLeague === league.id ? 'active' : ''}" data-league="${league.id}">
                    <div class="radio-dot ${state.teamSeasonsSelectedLeague === league.id ? 'active' : ''}"></div>
                    <span class="text-sm font-medium ${state.teamSeasonsSelectedLeague === league.id ? 'text-green-700' : 'text-gray-700'}">
                        ${league.name}
                    </span>
                </label>
            `).join('');
            
            elements.teamSeasonsLeagueButtons.innerHTML = leagueButtonsHTML;
        }

        // Update team seasons team dropdown
        function updateTeamSeasonsTeamSelect() {
            const leagueTeams = getLeagueTeams(state.teamSeasonsSelectedLeague);
            
            const teamOptions = '<option value="">Choose a team...</option>' + 
                leagueTeams.map(team => `<option value="${team}">${team}</option>`).join('');
            
            elements.teamSeasonsTeamSelect.innerHTML = teamOptions;
            elements.teamSeasonsTeamSelect.value = state.teamSeasonsSelectedTeam;
        }

        // Update team seasons season select
        function updateTeamSeasonsSeasonSelect() {
            if (state.teamSeasonsSelectedLeague !== 'champions-league') {
                return; // No season dropdown for other European competitions yet
            }
            
            let seasonOptions = '<option value="">Select Season</option>';
            
            if (state.teamSeasonsSelectedLeague === 'champions-league') {
                // Only show Champions League eras
                seasonOptions += `
                    <option value="champions-league-era-1992-2025">Champions League Era (1992-2025)</option>
                    <option value="european-cup-era-1955-1992">European Cup Era (1955-1992)</option>
                    <option value="all-european-cup-seasons-1955-2025">All European Cup Seasons (1955-2025)</option>
                `;
            }
            
            elements.teamSeasonsSeasonSelect.innerHTML = seasonOptions;
            elements.teamSeasonsSeasonSelect.value = state.teamSeasonsSelectedSeason;
        }

        // Handle team seasons league change
        async function handleTeamSeasonsLeagueChange(newLeague) {
            state.teamSeasonsSelectedLeague = newLeague;
            state.teamSeasonsSelectedTeam = '';
            state.teamSeasonsSelectedSeason = '';
            state.teamSeasonsSelectedPosition = '';
            state.includeBetterResults = false;
            
            // Load league data if not already loaded
            if (!state.loadedLeagues || !state.loadedLeagues.has(newLeague)) {
                await loadLeagueDataForDevice(newLeague);
            } else {
                // If already loaded, just filter/update UI
                filterDataForCurrentLeague(newLeague);
            }
            
            createTeamSeasonsLeagueButtons();
            updateTeamSeasonsTeamSelect();
            updateTeamSeasonsSeasonSelect();
            updateTeamSeasonsProgressionSelect();
            
            // Clear the table and reset UI
            elements.teamHistoryTable.classList.add('hidden');
            elements.teamSeasonsPositionInfo.textContent = '';
            
            // Reset dropdown values
            elements.teamSeasonsTeamSelect.value = '';
            elements.teamSeasonsSeasonSelect.value = '';
            elements.teamSeasonsPositionSelect.value = '';
            elements.includeBetterResultsCheckbox.className = 'checkbox';
            elements.includeBetterResultsContainer.classList.add('hidden');
            elements.includeBetterResultsContainer.style.display = 'none';
            
            // Clear stored team history data and name
            window.currentTeamHistoryData = null;
            window.currentTeamHistoryName = null;
            
            // Show/hide season dropdown for Champions League
            if (newLeague === 'champions-league') {
                elements.teamSeasonsSeasonContainer.classList.remove('hidden');
            } else {
                elements.teamSeasonsSeasonContainer.classList.add('hidden');
            }
            
            // Hide team history table until team is selected
            elements.teamHistoryTable.classList.add('hidden');
        }

        // Toggle controls collapse
        function toggleControlsCollapse() {
            state.controlsCollapsed = !state.controlsCollapsed;
            updateControlsVisibility();
        }

        // Update controls visibility based on collapsed state
        function updateControlsVisibility() {
            // Update button appearance
            if (state.controlsCollapsed) {
                elements.collapseControlsBtn.querySelector('span').innerHTML = '‚ñ≤';
                elements.collapseControlsBtn.title = 'Show Controls';
            } else {
                elements.collapseControlsBtn.querySelector('span').innerHTML = '‚ñº';
                elements.collapseControlsBtn.title = 'Hide Controls';
            }

            // Use CSS approach - add/remove a body class that controls visibility via CSS
            if (state.controlsCollapsed) {
                document.body.classList.add('controls-collapsed');
            } else {
                document.body.classList.remove('controls-collapsed');
            }
        }

        // Helper function to get ordinal numbers (1st, 2nd, 3rd, etc.)
        function getOrdinal(num) {
            const suffixes = ["th", "st", "nd", "rd"];
            const v = num % 100;
            return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);
        }

        // Update team seasons progression select
        function updateTeamSeasonsProgressionSelect() {
            // Progression options are now static in HTML
            elements.teamSeasonsPositionSelect.value = state.teamSeasonsSelectedPosition;
        }

        // Handle team seasons season selection
        function handleTeamSeasonsSeasonChange(selectedSeason) {
            state.teamSeasonsSelectedSeason = selectedSeason;
            
            // If a team is already selected, refresh the team history with the new season filter
            if (state.teamSeasonsSelectedTeam) {
                showTeamHistory(state.teamSeasonsSelectedTeam, state.teamSeasonsSelectedLeague);
            }
        }

        // Handle team seasons position selection
        function handleTeamSeasonsPositionChange(selectedPosition) {
            state.teamSeasonsSelectedPosition = selectedPosition;

            if (state.teamSeasonsSelectedTeam) {
                // If a team is selected, refresh the team history with the new progression filter
                showTeamHistory(state.teamSeasonsSelectedTeam, state.teamSeasonsSelectedLeague);

                // Show/hide checkbox AFTER showTeamHistory runs: only visible when both team AND position are selected
                setTimeout(() => {
                    if (selectedPosition) {
                        // Team + position selected = show checkbox
                        elements.includeBetterResultsContainer.classList.remove('hidden');
                        elements.includeBetterResultsContainer.style.display = 'flex';
                    } else {
                        // Team but no position = hide checkbox
                        elements.includeBetterResultsContainer.classList.add('hidden');
                    }
                }, 100);
            } else if (selectedPosition) {
                // If no team selected but progression is selected, show all teams at that progression
                // Reset team selection to ensure clean progression-only view
                state.teamSeasonsSelectedTeam = '';
                elements.teamSeasonsTeamSelect.value = '';
                showAllTeamsAtProgression(selectedPosition, state.teamSeasonsSelectedLeague);
            } else {
                // Clear the table if no filters are selected
                elements.teamHistoryTable.classList.add('hidden');
                elements.teamSeasonsPositionInfo.textContent = '';
            }
        }

        // Show all teams that finished at a specific position
        function showAllTeamsAtPosition(position, league) {
            const selectedPos = parseInt(position);
            const leagueMapping = {
                'champions-league': 'C1',
                'europa-league': 'E1',
                'conference-league': 'C2'
            };
            
            const divCode = leagueMapping[league];
            if (!divCode) return;
            
            const availableSeasons = getAvailableSeasons(league);
            const allPositionData = [];
            
            // Process each season to build complete league tables
            availableSeasons.forEach(seasonFilter => {
                // Skip special seasons
                if (seasonFilter.includes('all-') || seasonFilter.includes('-era-') || seasonFilter.includes('french-division-1')) {
                    return;
                }
                
                // Get season date range
                const originalSelectedLeague = state.selectedLeague;
                state.selectedLeague = league;
                const seasonDates = getSeasonDateRange(seasonFilter);
                state.selectedLeague = originalSelectedLeague;
                
                if (!seasonDates) return;
                
                // Filter data for this season
                const seasonStart = new Date(seasonDates.start);
                seasonStart.setUTCHours(0, 0, 0, 0);
                const seasonEnd = new Date(seasonDates.end);
                seasonEnd.setUTCHours(23, 59, 59, 999);
                
                let seasonData = state.data.filter(match => 
                    match.Div === divCode &&
                    match.dateObj >= seasonStart &&
                    match.dateObj <= seasonEnd
                );
                
                // Apply qualifier exclusion filter if enabled
                if (state.excludeQualifiers) {
                    seasonData = seasonData.filter(row => !row.isQualifier);
                }
                
                // Apply main stage exclusion filter if enabled
                if (state.excludeMainStage) {
                    seasonData = seasonData.filter(row => row.isQualifier);
                }
                
                if (seasonData.length === 0) return;
                
                // Build complete league table for this season
                const teams = [...new Set([
                    ...seasonData.map(row => row.HomeTeam),
                    ...seasonData.map(row => row.AwayTeam)
                ])].filter(team => team && team.length > 1);
                
                const seasonTable = teams.map(team => {
                    const stats = { played: 0, won: 0, drawn: 0, lost: 0, goalsFor: 0, goalsAgainst: 0 };
                    
                    seasonData.forEach(match => {
                        if (match.HomeTeam === team || match.AwayTeam === team) {
                            const isHome = match.HomeTeam === team;
                            const teamScore = isHome ? match.FTHG : match.FTAG;
                            const opponentScore = isHome ? match.FTAG : match.FTHG;
                            
                            if (teamScore !== undefined && opponentScore !== undefined) {
                                stats.played++;
                                stats.goalsFor += teamScore;
                                stats.goalsAgainst += opponentScore;
                                
                                if (teamScore > opponentScore) stats.won++;
                                else if (teamScore === opponentScore) stats.drawn++;
                                else stats.lost++;
                            }
                        }
                    });
                    
                    const pointsPerWin = getHistoricalPointSystem(seasonFilter, league);
                    let teamPoints = stats.won * pointsPerWin + stats.drawn;
                    
                    // Apply point deductions for this team and season
                    if (seasonDates) {
                        const seasonStart = new Date(seasonDates.start);
                        const seasonEnd = new Date(seasonDates.end);
                        
                        pointDeductions.forEach(deduction => {
                            if (deduction.team === team && deduction.league === divCode) {
                                const deductionStart = new Date(deduction.startDate);
                                const deductionEnd = new Date(deduction.endDate);
                                
                                const hasOverlap = (seasonStart <= deductionEnd) && (seasonEnd >= deductionStart);
                                if (hasOverlap && state.pointDeductionsEnabled) {
                                    teamPoints -= deduction.points;
                                }
                            }
                        });
                    }
                    
                    return {
                        team,
                        ...stats,
                        goalDifference: stats.goalsFor - stats.goalsAgainst,
                        points: teamPoints
                    };
                });
                
                // Sort table by points, goal difference, goals for
                seasonTable.sort((a, b) => {
                    if (b.points !== a.points) return b.points - a.points;
                    if (b.goalDifference !== a.goalDifference) return b.goalDifference - a.goalDifference;
                    return b.goalsFor - a.goalsFor;
                });
                
                // Apply ranking overrides
                const overriddenTable = applyRankingOverrides(seasonTable, league, seasonFilter);
                
                // Extract all teams at the requested position (handle shared positions)
                if (overriddenTable.length >= selectedPos) {
                    // Find all teams that share the same position or have sharedPosition property
                    const teamsAtPosition = [];
                    
                    // First, check if there are teams with sharedPosition matching our target
                    overriddenTable.forEach((team, index) => {
                        if (team.sharedPosition === selectedPos) {
                            teamsAtPosition.push(team);
                        }
                    });
                    
                    // If no shared positions found, get the team at the array index
                    if (teamsAtPosition.length === 0) {
                        const teamAtIndex = overriddenTable[selectedPos - 1];
                        if (teamAtIndex) {
                            teamsAtPosition.push(teamAtIndex);
                            
                            // Check for other teams with the same points/stats (tied positions)
                            overriddenTable.forEach((team, index) => {
                                if (index !== selectedPos - 1 && 
                                    team.points === teamAtIndex.points && 
                                    team.goalDifference === teamAtIndex.goalDifference &&
                                    team.goalsFor === teamAtIndex.goalsFor) {
                                    // Check if this tied team would be in the same position range
                                    const teamActualPosition = index + 1;
                                    if (Math.abs(teamActualPosition - selectedPos) < teamsAtPosition.length) {
                                        teamsAtPosition.push(team);
                                    }
                                }
                            });
                        }
                    }
                    
                    // Process each team at this position
                    teamsAtPosition.forEach(teamAtPosition => {
                        // Check if this season should be included (34+ games or historical incomplete season)
                        const shouldInclude = teamAtPosition.played >= 34 || seasonFilter !== '2025-26';
                        
                        // Check for stripped champions (position-only filtering, no team filter)
                        const isStripped = isStrippedChampion(teamAtPosition.team, divCode, seasonFilter, selectedPos, false, true);
                        
                        if (shouldInclude && !isStripped) {
                            allPositionData.push({
                                season: seasonFilter,
                                team: teamAtPosition.team,
                                position: selectedPos,
                                played: teamAtPosition.played,
                                won: teamAtPosition.won,
                                drawn: teamAtPosition.drawn,
                                lost: teamAtPosition.lost,
                                goalsFor: teamAtPosition.goalsFor,
                                goalsAgainst: teamAtPosition.goalsAgainst,
                                goalDifference: teamAtPosition.goalDifference,
                                points: teamAtPosition.points
                            });
                        }
                    });
                }
            });
            
            // Sort by season (most recent first), then by team name
            allPositionData.sort((a, b) => {
                const yearA = parseInt(a.season.split('-')[0]);
                const yearB = parseInt(b.season.split('-')[0]);
                if (yearB !== yearA) return yearB - yearA;
                return a.team.localeCompare(b.team);
            });
            
            // Add count column - count chronologically from oldest to most recent
            const teamCounts = {};
            // First sort by oldest to count chronologically
            const chronologicalData = [...allPositionData].sort((a, b) => {
                const yearA = parseInt(a.season.split('-')[0]);
                const yearB = parseInt(b.season.split('-')[0]);
                return yearA - yearB; // oldest first for counting
            });
            
            // Assign count numbers chronologically
            chronologicalData.forEach(season => {
                if (!teamCounts[season.team]) {
                    teamCounts[season.team] = 0;
                }
                teamCounts[season.team]++;
                season.count = teamCounts[season.team];
            });
            
            // Update position info
            const ordinalPosition = getOrdinal(selectedPos);
            const totalCount = allPositionData.length;
            const countText = totalCount === 1 ? 'time' : 'times';
            elements.teamSeasonsPositionInfo.textContent = `${totalCount} teams finished ${ordinalPosition} a total of ${totalCount} ${countText}`;
            
            // Display the results
            displayAllTeamsAtPosition(allPositionData, selectedPos, league);
        }

        // Show all teams that reached a specific progression level
        function showAllTeamsAtProgression(progression, league) {
            const leagueMapping = {
                'champions-league': 'C1',
                'europa-league': 'E1',
                'conference-league': 'C2'
            };
            
            const divCode = leagueMapping[league];
            if (!divCode) return;
            
            const availableSeasons = getAvailableSeasons(league);
            const allProgressionData = [];
            
            // Process each season to find teams that reached this progression
            availableSeasons.forEach(seasonFilter => {
                // Skip special seasons
                if (seasonFilter.includes('all-') || seasonFilter.includes('-era-')) {
                    return;
                }
                
                // Get season date range
                const originalSelectedLeague = state.selectedLeague;
                state.selectedLeague = league;
                const seasonDates = getSeasonDateRange(seasonFilter);
                state.selectedLeague = originalSelectedLeague;
                
                if (!seasonDates) return;
                
                // Filter data for this season
                const seasonStart = new Date(seasonDates.start);
                seasonStart.setUTCHours(0, 0, 0, 0);
                const seasonEnd = new Date(seasonDates.end);
                seasonEnd.setUTCHours(23, 59, 59, 999);
                
                const seasonData = state.data.filter(match => 
                    match.Div === divCode &&
                    match.dateObj >= seasonStart &&
                    match.dateObj <= seasonEnd
                );
                
                if (seasonData.length === 0) return;
                
                // Get all teams in this season
                const teams = [...new Set([
                    ...seasonData.map(row => row.HomeTeam),
                    ...seasonData.map(row => row.AwayTeam)
                ])].filter(team => team && team.length > 1);
                
                // For each team, calculate their progression
                teams.forEach(teamName => {
                    const teamMatches = seasonData.filter(match => 
                        match.HomeTeam === teamName || match.AwayTeam === teamName
                    );
                    
                    if (teamMatches.length === 0) return;
                    
                    const teamProgression = calculateTournamentProgression(teamName, teamMatches);
                    
                    // Only include teams that reached the selected progression
                    if (teamProgression === progression) {
                        // Calculate team stats for this season
                        let played = 0, won = 0, drawn = 0, lost = 0;
                        let goalsFor = 0, goalsAgainst = 0;
                        
                        teamMatches.forEach(match => {
                            played++;
                            const homeGoals = parseInt(match.FTHG) || 0;
                            const awayGoals = parseInt(match.FTAG) || 0;
                            
                            if (match.HomeTeam === teamName) {
                                goalsFor += homeGoals;
                                goalsAgainst += awayGoals;
                                if (homeGoals > awayGoals) won++;
                                else if (homeGoals === awayGoals) drawn++;
                                else lost++;
                            } else {
                                goalsFor += awayGoals;
                                goalsAgainst += homeGoals;
                                if (awayGoals > homeGoals) won++;
                                else if (awayGoals === homeGoals) drawn++;
                                else lost++;
                            }
                        });
                        
                        const goalDifference = goalsFor - goalsAgainst;
                        const winPoints = 3; // Standard 3 points for win
                        const points = won * winPoints + drawn;
                        
                        allProgressionData.push({
                            season: seasonFilter,
                            team: teamName,
                            played,
                            won,
                            drawn,
                            lost,
                            goalsFor,
                            goalsAgainst,
                            goalDifference,
                            points,
                            position: '-', // Position not relevant for progression view
                            tournamentProgression: teamProgression
                        });
                    }
                });
            });
            
            // Sort by season (most recent first), then by team name
            allProgressionData.sort((a, b) => {
                const yearA = parseInt(a.season.split('-')[0]);
                const yearB = parseInt(b.season.split('-')[0]);
                if (yearB !== yearA) return yearB - yearA;
                return a.team.localeCompare(b.team);
            });
            
            // Add count column - count chronologically from oldest to most recent
            const teamCounts = {};
            // First sort by oldest to count chronologically
            const chronologicalData = [...allProgressionData].sort((a, b) => {
                const yearA = parseInt(a.season.split('-')[0]);
                const yearB = parseInt(b.season.split('-')[0]);
                return yearA - yearB; // oldest first for counting
            });
            
            // Assign count numbers chronologically
            chronologicalData.forEach(season => {
                if (!teamCounts[season.team]) {
                    teamCounts[season.team] = 0;
                }
                teamCounts[season.team]++;
                season.count = teamCounts[season.team];
            });
            
            // Update progression info
            const totalCount = allProgressionData.length;
            if (totalCount === 0) {
                elements.teamSeasonsPositionInfo.textContent = `No teams found that reached ${progression}`;
            } else {
                const countText = totalCount === 1 ? 'time' : 'times';
                elements.teamSeasonsPositionInfo.textContent = `${totalCount} teams reached ${progression} a total of ${totalCount} ${countText}`;
            }
            
            // Display the results
            displayAllTeamsAtProgression(allProgressionData, progression, league);
        }

        // Display progression-only table
        function displayAllTeamsAtProgression(allProgressionData, progression, league) {
            if (!allProgressionData || allProgressionData.length === 0) {
                // Show table with "no results" message instead of hiding
                elements.teamHistoryTable.classList.remove('hidden');
                elements.teamHistoryTitle.innerHTML = `All teams (Progression: <span style="color: #374151; font-weight: bold;">${progression}</span>)`;
                elements.teamHistoryHeader.innerHTML = '';
                elements.teamHistoryBody.innerHTML = `
                    <tr>
                        <td colspan="12" class="px-6 py-8 text-center text-gray-500">
                            <div class="flex flex-col items-center">
                                <span class="text-lg font-medium mb-2">No Results Found</span>
                                <span class="text-sm">No teams found that reached ${progression} in the available data.</span>
                            </div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Show table
            elements.teamHistoryTable.classList.remove('hidden');
            
            // Update title for progression-only view
            const progressionStyle = progression === 'Champions' ? 'color: #d97706; font-weight: bold;' : 'color: #374151; font-weight: bold;';
            elements.teamHistoryTitle.innerHTML = `All teams (Progression: <span style="${progressionStyle}">${progression}</span>)`;
            
            // Store data globally for sorting
            window.currentTeamHistoryData = [...allProgressionData];
            window.currentTeamHistoryName = `All teams (Progression: ${progression})`;
            
            // Generate table headers using the same format as team history
            const headers = [
                { key: 'season', label: 'Season' },
                { key: 'count', label: 'Count' },
                { key: 'team', label: 'Team' },
                { key: 'played', label: 'P' },
                { key: 'won', label: 'W' },
                { key: 'drawn', label: 'D' },
                { key: 'lost', label: 'L' },
                { key: 'goalsFor', label: 'GF' },
                { key: 'goalsAgainst', label: 'GA' },
                { key: 'goalDifference', label: 'GD' },
                { key: 'points', label: 'Pts' },
                { key: 'tournamentProgression', label: 'Progression' }
            ];
            
            // Generate headers with same styling as team history
            elements.teamHistoryHeader.innerHTML = headers.map(header => `
                <th class="px-3 py-4 text-center font-bold text-sm cursor-pointer hover:bg-gray-600" 
                    onclick="handleTeamHistorySort('${header.key}')"
                    style="text-align: ${(header.key === 'season' || header.key === 'team') ? 'left' : 'center'}">
                    ${header.label}${getTeamHistorySortIndicator(header.key)}
                </th>
            `).join('');
            
            // Generate table body with exact same styling as team history
            elements.teamHistoryBody.innerHTML = allProgressionData.map((season, index) => {
                const rowBackgroundClass = allProgressionData.length >= 3 && index % 2 === 1 ? 'bg-gray-50' : 'bg-white';
                const logoUrl = getTeamLogoUrl(season.team, league);
                
                return `
                    <tr class="border-b hover:bg-gray-50 ${rowBackgroundClass}">
                        <td class="px-3 py-4 font-semibold text-left">${season.season}</td>
                        <td class="px-3 py-4 text-center font-semibold">${season.count}</td>
                        <td class="px-4 py-4 font-semibold text-gray-900">
                            <div class="flex items-center cursor-pointer hover:underline" onclick="showTeamHistory('${season.team}', '${league}')">
                                ${logoUrl ? `<img src="${logoUrl}" alt="${season.team} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                <span style="color: #000000">${season.team}</span>
                            </div>
                        </td>
                        <td class="px-3 py-4 text-center">${season.played}</td>
                        <td class="px-3 py-4 text-center">${season.won}</td>
                        <td class="px-3 py-4 text-center">${season.drawn}</td>
                        <td class="px-3 py-4 text-center">${season.lost}</td>
                        <td class="px-3 py-4 text-center">${season.goalsFor}</td>
                        <td class="px-3 py-4 text-center">${season.goalsAgainst}</td>
                        <td class="px-3 py-4 text-center">
                            <span class="font-bold ${season.goalDifference > 0 ? 'text-green-700' : season.goalDifference < 0 ? 'text-red-600' : 'text-black'}">
                                ${season.goalDifference > 0 ? '+' : ''}${season.goalDifference}
                            </span>
                        </td>
                        <td class="px-3 py-4 text-center">
                            <span class="points-badge">
                                ${season.points}
                            </span>
                        </td>
                        <td class="px-3 py-4 text-center font-bold" style="${
                            season.tournamentProgression === 'Champions' ? 'color: #d97706; background-color: #fef3c7;' :
                            season.tournamentProgression === 'Final' ? 'color: #374151; background-color: #e5e7eb;' :
                            season.tournamentProgression === 'Semi-Finals' ? 'color: #b45309; background-color: #fef7ed;' :
                            season.tournamentProgression === 'Quarter-Finals' ? 'color: #059669; background-color: #d1fae5;' :
                            season.tournamentProgression === 'Round Of 16' ? 'color: #2563eb; background-color: #dbeafe;' :
                            'color: #6b7280; background-color: #f9fafb;'
                        }">${season.tournamentProgression}</td>
                    </tr>
                `;
            }).join('');
        }

        // Render progression-only table without recalculating data (for sorting)
        function renderProgressionOnlyTable(allProgressionData, progression, league) {
            if (!allProgressionData || allProgressionData.length === 0) {
                // Show table with "no results" message
                elements.teamHistoryTable.classList.remove('hidden');
                elements.teamHistoryTitle.innerHTML = `All teams (Progression: <span style="color: #374151; font-weight: bold;">${progression}</span>)`;
                elements.teamHistoryHeader.innerHTML = '';
                elements.teamHistoryBody.innerHTML = `
                    <tr>
                        <td colspan="12" class="px-6 py-8 text-center text-gray-500">
                            <div class="flex flex-col items-center">
                                <span class="text-lg font-medium mb-2">No Results Found</span>
                                <span class="text-sm">No teams found that reached ${progression} in the available data.</span>
                            </div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Show table
            elements.teamHistoryTable.classList.remove('hidden');
            
            // Update title for progression-only view
            const progressionStyle = progression === 'Champions' ? 'color: #d97706; font-weight: bold;' : 'color: #374151; font-weight: bold;';
            elements.teamHistoryTitle.innerHTML = `All teams (Progression: <span style="${progressionStyle}">${progression}</span>)`;
            
            // Store data globally for sorting
            window.currentTeamHistoryData = [...allProgressionData];
            window.currentTeamHistoryName = `All teams (Progression: ${progression})`;
            
            // Generate table headers
            const headers = [
                { key: 'season', label: 'Season' },
                { key: 'count', label: 'Count' },
                { key: 'team', label: 'Team' },
                { key: 'played', label: 'P' },
                { key: 'won', label: 'W' },
                { key: 'drawn', label: 'D' },
                { key: 'lost', label: 'L' },
                { key: 'goalsFor', label: 'GF' },
                { key: 'goalsAgainst', label: 'GA' },
                { key: 'goalDifference', label: 'GD' },
                { key: 'points', label: 'Pts' },
                { key: 'tournamentProgression', label: 'Progression' }
            ];
            
            // Generate headers
            elements.teamHistoryHeader.innerHTML = headers.map(header => `
                <th class="px-3 py-4 text-center font-bold text-sm cursor-pointer hover:bg-gray-600" 
                    onclick="handleTeamHistorySort('${header.key}')"
                    style="text-align: ${(header.key === 'season' || header.key === 'team') ? 'left' : 'center'}">
                    ${header.label}${getTeamHistorySortIndicator(header.key)}
                </th>
            `).join('');
            
            // Generate table body
            elements.teamHistoryBody.innerHTML = allProgressionData.map((season, index) => {
                const rowBackgroundClass = allProgressionData.length >= 3 && index % 2 === 1 ? 'bg-gray-50' : 'bg-white';
                const logoUrl = getTeamLogoUrl(season.team, league);
                
                return `
                    <tr class="border-b hover:bg-gray-50 ${rowBackgroundClass}">
                        <td class="px-3 py-4 font-semibold text-left">${season.season}</td>
                        <td class="px-3 py-4 text-center font-semibold">${season.count}</td>
                        <td class="px-4 py-4 font-semibold text-gray-900">
                            <div class="flex items-center cursor-pointer hover:underline" onclick="showTeamHistory('${season.team}', '${league}')">
                                ${logoUrl ? `<img src="${logoUrl}" alt="${season.team} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                <span style="color: #000000">${season.team}</span>
                            </div>
                        </td>
                        <td class="px-3 py-4 text-center">${season.played}</td>
                        <td class="px-3 py-4 text-center">${season.won}</td>
                        <td class="px-3 py-4 text-center">${season.drawn}</td>
                        <td class="px-3 py-4 text-center">${season.lost}</td>
                        <td class="px-3 py-4 text-center">${season.goalsFor}</td>
                        <td class="px-3 py-4 text-center">${season.goalsAgainst}</td>
                        <td class="px-3 py-4 text-center">
                            <span class="font-bold ${season.goalDifference > 0 ? 'text-green-700' : season.goalDifference < 0 ? 'text-red-600' : 'text-black'}">
                                ${season.goalDifference > 0 ? '+' : ''}${season.goalDifference}
                            </span>
                        </td>
                        <td class="px-3 py-4 text-center">
                            <span class="points-badge">
                                ${season.points}
                            </span>
                        </td>
                        <td class="px-3 py-4 text-center font-bold" style="${
                            season.tournamentProgression === 'Champions' ? 'color: #d97706; background-color: #fef3c7;' :
                            season.tournamentProgression === 'Final' ? 'color: #374151; background-color: #e5e7eb;' :
                            season.tournamentProgression === 'Semi-Finals' ? 'color: #b45309; background-color: #fef7ed;' :
                            season.tournamentProgression === 'Quarter-Finals' ? 'color: #059669; background-color: #d1fae5;' :
                            season.tournamentProgression === 'Round Of 16' ? 'color: #2563eb; background-color: #dbeafe;' :
                            'color: #6b7280; background-color: #f9fafb;'
                        }">${season.tournamentProgression}</td>
                    </tr>
                `;
            }).join('');
        }

        // Render position-only table without recalculating data (for sorting)
        function renderPositionOnlyTable(allPositionData, selectedPos, league) {
            if (!allPositionData || allPositionData.length === 0) {
                elements.teamHistoryTable.classList.add('hidden');
                return;
            }
            
            // Show table
            elements.teamHistoryTable.classList.remove('hidden');
            
            // Update title for position-only view with medal styling
            const ordinalPosition = getOrdinal(selectedPos);
            const medalStyle = selectedPos === 1 ? 'color: #d97706; font-weight: bold;' : selectedPos === 2 ? 'color: #374151; font-weight: bold;' : selectedPos === 3 ? 'color: #b45309; font-weight: bold;' : 'color: #374151; font-weight: bold;';
            elements.teamHistoryTitle.innerHTML = `All teams (Position <span style="${medalStyle}">${selectedPos}</span>) - ${ordinalPosition} Place Finishes`;
            
            // Update headers for multi-team view
            const headers = [
                { key: 'season', label: 'Season' },
                { key: 'count', label: 'Count' },
                { key: 'team', label: 'Team' },
                { key: 'played', label: 'P' },
                { key: 'won', label: 'W' },
                { key: 'drawn', label: 'D' },
                { key: 'lost', label: 'L' },
                { key: 'goalsFor', label: 'GF' },
                { key: 'goalsAgainst', label: 'GA' },
                { key: 'goalDifference', label: 'GD' },
                { key: 'points', label: 'Pts' }
            ];
            
            // In position-only mode, make ALL columns sortable (including team)
            elements.teamHistoryHeader.innerHTML = headers.map(header => `
                <th class="px-3 py-4 text-center font-bold text-sm cursor-pointer hover:bg-gray-600" 
                    onclick="handleTeamHistorySort('${header.key}')"
                    style="text-align: ${(header.key === 'season' || header.key === 'team') ? 'left' : 'center'}">
                    ${header.label}${getTeamHistorySortIndicator(header.key)}
                </th>
            `).join('');
            
            // Create table rows
            elements.teamHistoryBody.innerHTML = allPositionData.map((season, index) => {
                const rowBackgroundClass = index % 2 === 1 ? 'bg-gray-50' : 'bg-white';
                const logoUrl = getTeamLogoUrl(season.team, league);
                
                return `
                    <tr class="border-b hover:bg-gray-50 ${rowBackgroundClass}">
                        <td class="px-3 py-4 font-semibold text-left">${season.season}</td>
                        <td class="px-3 py-4 text-center font-semibold">${season.count}</td>
                        <td class="px-4 py-4 font-semibold text-gray-900">
                            <div class="flex items-center">
                                ${logoUrl ? `<img src="${logoUrl}" alt="${season.team} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                <span class="cursor-pointer hover:text-blue-600" onclick="handleTeamClick('${season.team}')">${season.team}</span>
                            </div>
                        </td>
                        <td class="px-3 py-4 text-center">${season.played}</td>
                        <td class="px-3 py-4 text-center">${season.won}</td>
                        <td class="px-3 py-4 text-center">${season.drawn}</td>
                        <td class="px-3 py-4 text-center">${season.lost}</td>
                        <td class="px-3 py-4 text-center">${season.goalsFor}</td>
                        <td class="px-3 py-4 text-center">${season.goalsAgainst}</td>
                        <td class="px-3 py-4 text-center ${season.goalDifference >= 0 ? 'text-green-600' : 'text-red-600'}">${season.goalDifference > 0 ? '+' : ''}${season.goalDifference}</td>
                        <td class="px-3 py-4 text-center">
                            <span class="points-badge">
                                ${season.points}
                            </span>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        // Display all teams at specific position
        function displayAllTeamsAtPosition(allPositionData, selectedPos, league) {
            // Clear any previous team-specific data first
            window.currentTeamHistoryData = null;
            window.currentTeamHistoryName = null;
            
            // Just call the render function
            renderPositionOnlyTable(allPositionData, selectedPos, league);
            
            // Store data for potential sorting
            window.currentTeamHistoryData = allPositionData;
            window.currentTeamHistoryName = `All teams (Position ${selectedPos})`;
        }

        // Handle team seasons team selection
        function handleTeamSeasonsTeamChange(selectedTeam) {
            // handleTeamSeasonsTeamChange called
            state.teamSeasonsSelectedTeam = selectedTeam;
            state.teamSeasonsSelectedPosition = ''; // Reset position filter
            state.includeBetterResults = false;
            
            if (selectedTeam) {
                // Reset position dropdown UI when team is selected
                elements.teamSeasonsPositionSelect.value = '';
                elements.includeBetterResultsCheckbox.className = 'checkbox';

                // Team selected but no position = hide checkbox
                elements.includeBetterResultsContainer.classList.add('hidden');

                showTeamHistory(selectedTeam, state.teamSeasonsSelectedLeague);
            } else {
                // Team unselected - clear everything
                elements.teamHistoryTable.classList.add('hidden');
                elements.teamSeasonsPositionInfo.textContent = '';
                elements.teamHistoryTitle.textContent = '';
                elements.includeBetterResultsContainer.classList.add('hidden');
                
                // Clear stored team history data and name to prevent contamination
                window.currentTeamHistoryData = null;
                window.currentTeamHistoryName = null;
            }
        }

        // Switch tabs
        function switchTab(tabName) {
            // Store the current league before switching
            let preservedLeague = state.selectedLeague;
            
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            if (tabName === 'league-filters') {
                document.getElementById('leagueFiltersTab').classList.add('active');
                document.getElementById('leagueFiltersContent').classList.add('active');

                // Preserve league selection
                state.selectedLeague = preservedLeague;

                // Reset Team Seasons state when switching away
                state.teamSeasonsSelectedTeam = '';
                state.teamSeasonsSelectedSeason = '';
                state.teamSeasonsSelectedPosition = '';
                state.includeBetterResults = false;

                // Reset Last Time When state
                state.lastTimeTeam1 = '';
                state.lastTimeTeam2 = '';
                state.lastTimeDayOfWeek = '';
                state.lastTimeLocation = '';
                state.lastTimeStage = '';
                elements.lastTimeTeam1Select.value = '';
                elements.lastTimeTeam2Select.value = '';
                elements.lastTimeDayOfWeekSelect.value = '';
                elements.lastTimeLocationSelect.value = '';
                elements.lastTimeStageSelect.value = '';
                elements.lastTimeResults.classList.add('hidden');
                
                // Show league table and related sections
                elements.tableContainer.classList.remove('hidden');
                elements.h2hSection.classList.remove('hidden');
                
                // Update league buttons and table
                createLeagueButtons();
                updateTable();
                
            } else if (tabName === 'team-seasons') {
                document.getElementById('teamSeasonsTab').classList.add('active');
                document.getElementById('teamSeasonsContent').classList.add('active');

                // Preserve league selection for Team Seasons
                state.teamSeasonsSelectedLeague = preservedLeague;

                // Reset both other tab states
                state.selectedTeam1 = '';
                state.selectedTeam2 = '';
                state.selectedSeason = '';
                state.competitionStage = '';
                state.selectedDayOfWeek = '';
                state.lastTimeTeam1 = '';
                state.lastTimeTeam2 = '';
                state.lastTimeDayOfWeek = '';
                elements.team1Select.value = '';
                elements.team2Select.value = '';
                elements.seasonSelect.value = '';
                elements.competitionStageSelect.value = '';
                elements.dayOfWeekSelect.value = '';
                elements.lastTimeTeam1Select.value = '';
                elements.lastTimeTeam2Select.value = '';
                elements.lastTimeDayOfWeekSelect.value = '';
                elements.lastTimeLocationSelect.value = '';
                elements.lastTimeStageSelect.value = '';

                // Hide other tab sections
                elements.tableContainer.classList.add('hidden');
                elements.matchHistorySection.classList.add('hidden');
                elements.h2hSection.classList.add('hidden');
                elements.h2hMatchesTable.classList.add('hidden');
                elements.tableInfo.classList.add('hidden');
                elements.lastTimeResults.classList.add('hidden');

                // Ensure checkbox is hidden when switching TO Team Seasons tab
                if (elements.includeBetterResultsContainer) {
                    elements.includeBetterResultsContainer.classList.add('hidden');
                    elements.includeBetterResultsContainer.style.display = 'none';
                }
                const containerById = document.getElementById('includeBetterResultsContainer');
                if (containerById) {
                    containerById.classList.add('hidden');
                    containerById.style.display = 'none';
                }

                // Clear Team Seasons visual elements to match cleared state
                elements.teamHistoryTable.classList.add('hidden');
                elements.teamSeasonsPositionInfo.textContent = '';
                elements.teamSeasonsTeamSelect.value = '';
                elements.teamSeasonsSeasonSelect.value = '';
                elements.teamSeasonsPositionSelect.value = '';
                elements.includeBetterResultsCheckbox.className = 'checkbox';
                elements.includeBetterResultsContainer.classList.add('hidden');

                // Initialize Team Seasons controls with preserved league
                createTeamSeasonsLeagueButtons();
                updateTeamSeasonsTeamSelect();
                updateTeamSeasonsProgressionSelect();
                
            } else if (tabName === 'last-time-when') {
                document.getElementById('lastTimeWhenTab').classList.add('active');
                document.getElementById('lastTimeWhenContent').classList.add('active');

                // Simple approach: just set the league and update
                state.selectedLeague = preservedLeague;

                // Reset Team Seasons state when switching away
                state.teamSeasonsSelectedTeam = '';
                state.teamSeasonsSelectedSeason = '';
                state.teamSeasonsSelectedPosition = '';
                state.includeBetterResults = false;

                // Reset League Filters state
                state.selectedTeam1 = '';
                state.selectedTeam2 = '';
                state.selectedSeason = '';
                state.selectedDayOfWeek = '';
                elements.team1Select.value = '';
                elements.team2Select.value = '';
                elements.seasonSelect.value = '';
                elements.dayOfWeekSelect.value = '';
                
                // Hide league table and related sections
                elements.tableContainer.classList.add('hidden');
                elements.matchHistorySection.classList.add('hidden');
                elements.h2hSection.classList.add('hidden');
                elements.h2hMatchesTable.classList.add('hidden');
                elements.tableInfo.classList.add('hidden');
                
                // Update league buttons and team selects for Last Time When
                createLeagueButtons(); // This will update the league buttons with correct selection
                updateTeamSelects();
                
            } else if (tabName === 'team-streaks') {
                document.getElementById('teamStreaksTab').classList.add('active');
                document.getElementById('teamStreaksContent').classList.add('active');

                // Simple approach: just set the league and update
                state.selectedLeague = preservedLeague;

                // Reset Team Seasons state when switching away
                state.teamSeasonsSelectedTeam = '';
                state.teamSeasonsSelectedSeason = '';
                state.teamSeasonsSelectedPosition = '';
                state.includeBetterResults = false;

                // Reset other tab states
                state.selectedTeam1 = '';
                state.selectedTeam2 = '';
                state.selectedSeason = '';
                state.competitionStage = '';
                state.selectedDayOfWeek = '';
                state.lastTimeTeam1 = '';
                state.lastTimeTeam2 = '';
                state.lastTimeDayOfWeek = '';
                elements.team1Select.value = '';
                elements.team2Select.value = '';
                elements.seasonSelect.value = '';
                elements.competitionStageSelect.value = '';
                elements.dayOfWeekSelect.value = '';
                elements.lastTimeTeam1Select.value = '';
                elements.lastTimeTeam2Select.value = '';
                elements.lastTimeDayOfWeekSelect.value = '';
                elements.lastTimeLocationSelect.value = '';
                elements.lastTimeStageSelect.value = '';
                
                // Hide other tab sections
                elements.tableContainer.classList.add('hidden');
                elements.matchHistorySection.classList.add('hidden');
                elements.h2hSection.classList.add('hidden');
                elements.h2hMatchesTable.classList.add('hidden');
                elements.tableInfo.classList.add('hidden');
                elements.lastTimeResults.classList.add('hidden');

                // Clear Team Streaks visual elements to match cleared state
                elements.teamStreaksResults.classList.add('hidden');
                elements.teamStreaksStageSelect.value = '';
                elements.teamStreaksStatusSelect.value = 'active'; // Reset to default
                elements.teamStreaksLocationSelect.value = 'both'; // Reset to default
                elements.teamStreaksTypeSelect.value = 'winning'; // Reset to default
                elements.teamStreaksTeam1Select.value = '';
                elements.teamStreaksTeam2Select.value = '';

                // Initialize Team Streaks controls with correct league selected
                createTeamStreaksLeagueButtons();
                updateTeamStreaksSelects();
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Tab switching
            document.getElementById('leagueFiltersTab').addEventListener('click', () => switchTab('league-filters'));
            document.getElementById('teamSeasonsTab').addEventListener('click', () => switchTab('team-seasons'));
            document.getElementById('lastTimeWhenTab').addEventListener('click', () => switchTab('last-time-when'));
            document.getElementById('teamStreaksTab').addEventListener('click', () => switchTab('team-streaks'));
            
            // Gist loading
            elements.reloadGistsBtn.addEventListener('click', loadGistData);
            
            // League selection
            elements.leagueButtons.addEventListener('click', (e) => {
                const button = e.target.closest('.league-button');
                if (button) {
                    handleLeagueChange(button.dataset.league);
                }
            });
            
            // Last Time When league selection
            elements.lastTimeLeagueButtons.addEventListener('click', (e) => {
                const button = e.target.closest('.league-button');
                if (button) {
                    handleLeagueChange(button.dataset.league);
                }
            });

            // Filter controls
            elements.seasonSelect.addEventListener('change', (e) => handleSeasonChange(e.target.value));
            elements.competitionStageSelect.addEventListener('change', (e) => { 
                state.competitionStage = e.target.value; 
                updateTable(); 
            });
            elements.dateFrom.addEventListener('change', (e) => {
                state.dateFrom = e.target.value;
                // Reset season selection when custom date range is applied
                state.selectedSeason = '';
                elements.seasonSelect.value = '';
                // Set 3-point system to ON for custom date ranges
                state.threePointSystem = true;
                elements.threePointCheckbox.className = 'checkbox checked';
                // Disable point deductions for custom date ranges
                state.pointDeductionsEnabled = false;
                elements.deductionsCheckbox.className = 'checkbox';
                // When manually changing dates, we're in custom date range mode
                updateCompetitionStageOptions();
                updateTable();
            });
            elements.dateTo.addEventListener('change', (e) => {
                state.dateTo = e.target.value;
                // Reset season selection when custom date range is applied
                state.selectedSeason = '';
                elements.seasonSelect.value = '';
                // Set 3-point system to ON for custom date ranges
                state.threePointSystem = true;
                elements.threePointCheckbox.className = 'checkbox checked';
                // Disable point deductions for custom date ranges
                state.pointDeductionsEnabled = false;
                elements.deductionsCheckbox.className = 'checkbox';
                // When manually changing dates, we're in custom date range mode
                updateCompetitionStageOptions();
                updateTable();
            });
            elements.dayOfWeekSelect.addEventListener('change', (e) => { state.selectedDayOfWeek = e.target.value; updateTable(); });
            elements.team1Select.addEventListener('change', (e) => { 
                state.selectedTeam1 = e.target.value; 
                checkAndDisablePointDeductions();
                updateTable(); 
            });
            elements.team2Select.addEventListener('change', (e) => { 
                state.selectedTeam2 = e.target.value; 
                checkAndDisablePointDeductions();
                updateTable(); 
            });
            
            // Checkboxes
            elements.homeCheckbox.addEventListener('click', () => {
                state.homeFilter = !state.homeFilter;
                state.matchHistoryHomeFilter = state.homeFilter; // Sync with match history

                // Update all home checkboxes
                elements.homeCheckbox.className = `checkbox ${state.homeFilter ? 'checked' : ''}`;
                elements.matchHistoryHomeCheckbox.className = `checkbox ${state.matchHistoryHomeFilter ? 'checked' : ''} cursor-pointer flex items-center gap-1`;
                elements.h2hHomeCheckbox.className = `checkbox ${state.homeFilter ? 'checked' : ''}`;
                updateTable();
            });

            elements.awayCheckbox.addEventListener('click', () => {
                state.awayFilter = !state.awayFilter;
                state.matchHistoryAwayFilter = state.awayFilter; // Sync with match history

                // Update all away checkboxes
                elements.awayCheckbox.className = `checkbox ${state.awayFilter ? 'checked' : ''}`;
                elements.matchHistoryAwayCheckbox.className = `checkbox ${state.matchHistoryAwayFilter ? 'checked' : ''} cursor-pointer flex items-center gap-1`;
                elements.h2hAwayCheckbox.className = `checkbox ${state.awayFilter ? 'checked' : ''}`;
                updateTable();
            });
            
            elements.deductionsCheckbox.addEventListener('click', () => {
                state.pointDeductionsEnabled = !state.pointDeductionsEnabled;
                elements.deductionsCheckbox.className = `checkbox ${state.pointDeductionsEnabled ? 'checked' : ''}`;
                updateTable();
                
                // Also refresh Team Seasons data if currently displayed
                if (state.teamSeasonsSelectedTeam) {
                    // Refresh single team view
                    showTeamHistory(state.teamSeasonsSelectedTeam, state.teamSeasonsSelectedLeague);
                } else if (state.teamSeasonsSelectedPosition) {
                    // Refresh position-only view
                    showAllTeamsAtPosition(state.teamSeasonsSelectedPosition, state.teamSeasonsSelectedLeague);
                }
            });
            
            elements.threePointCheckbox.addEventListener('click', () => {
                state.threePointSystem = !state.threePointSystem;
                elements.threePointCheckbox.className = `checkbox ${state.threePointSystem ? 'checked' : ''}`;
                updateTable();
            });
            
            elements.excludeQualifiersCheckbox.addEventListener('click', () => {
                state.excludeQualifiers = !state.excludeQualifiers;
                elements.excludeQualifiersCheckbox.className = `checkbox ${state.excludeQualifiers ? 'checked' : ''}`;
                updateTable();
                
                // Also refresh other tabs if they have data displayed
                if (state.selectedTeam1 || state.selectedTeam2) {
                    updateH2HTable();
                }
                if (state.lastTimeTeam1) {
                    calculateLastTimeWhen();
                }
                if (state.teamStreaksTeam1) {
                    calculateActiveStreaks();
                }
                if (state.teamSeasonsSelectedTeam) {
                    showTeamHistory(state.teamSeasonsSelectedTeam, state.teamSeasonsSelectedLeague);
                } else if (state.teamSeasonsSelectedPosition) {
                    showAllTeamsAtPosition(state.teamSeasonsSelectedPosition, state.teamSeasonsSelectedLeague);
                }
            });
            
            elements.excludeMainStageCheckbox.addEventListener('click', () => {
                state.excludeMainStage = !state.excludeMainStage;
                elements.excludeMainStageCheckbox.className = `checkbox ${state.excludeMainStage ? 'checked' : ''}`;
                updateTable();
                
                // Also refresh other tabs if they have data displayed
                if (state.selectedTeam1 || state.selectedTeam2) {
                    updateH2HTable();
                }
                if (state.lastTimeTeam1) {
                    calculateLastTimeWhen();
                }
                if (state.teamStreaksTeam1) {
                    calculateActiveStreaks();
                }
                if (state.teamSeasonsSelectedTeam) {
                    showTeamHistory(state.teamSeasonsSelectedTeam, state.teamSeasonsSelectedLeague);
                } else if (state.teamSeasonsSelectedPosition) {
                    showAllTeamsAtPosition(state.teamSeasonsSelectedPosition, state.teamSeasonsSelectedLeague);
                }
            });

            // Buttons
            elements.resetBtn.addEventListener('click', clearFilters);
            
            // Last Time When controls
            elements.lastTimeTeam1Select.addEventListener('change', (e) => {
                state.lastTimeTeam1 = e.target.value;
                calculateLastTimeWhen();
            });
            
            elements.lastTimeTeam2Select.addEventListener('change', (e) => {
                state.lastTimeTeam2 = e.target.value;
                calculateLastTimeWhen();
            });
            
            elements.lastTimeDayOfWeekSelect.addEventListener('change', (e) => {
                state.lastTimeDayOfWeek = e.target.value;
                calculateLastTimeWhen();
            });
            
            elements.lastTimeLocationSelect.addEventListener('change', (e) => {
                // Location dropdown changed
                state.lastTimeLocation = e.target.value;
                // State updated
                calculateLastTimeWhen();
            });
            
            elements.lastTimeStageSelect.addEventListener('change', (e) => {
                state.lastTimeStage = e.target.value;
                calculateLastTimeWhen();
            });
            elements.retryBtn.addEventListener('click', () => {
                state.error = '';
                loadGistData();
            });

            // H2H controls
            elements.h2hStageSelect.addEventListener('change', (e) => {
                console.log('H2H Stage dropdown changed to:', e.target.value);
                state.h2hStage = e.target.value;
                console.log('state.h2hStage set to:', state.h2hStage);
                // Reset H2H table sort when stage filter changes
                state.h2hSortConfig = { key: 'date', direction: 'desc' };
                updateTable();
            });
            
            elements.recentH2HSelect.addEventListener('input', (e) => {
                let value = e.target.value.trim();
                if (value === '') {
                    return; // Allow empty, don't update yet
                }

                if (value.toLowerCase() === 'all') {
                    state.recentH2HCount = 'All';
                    e.target.value = 'All';
                } else {
                    const num = parseInt(value);
                    if (!isNaN(num) && num > 0) {
                        state.recentH2HCount = num;
                        e.target.value = num.toString();
                    } else {
                        e.target.value = state.recentH2HCount === 'All' ? 'All' : state.recentH2HCount.toString();
                        return;
                    }
                }
                updateTable();
            });

            elements.recentH2HSelect.addEventListener('blur', (e) => {
                let value = e.target.value.trim();
                if (value === '') {
                    state.recentH2HCount = 'All';
                    e.target.value = 'All';
                    updateTable();
                }
            });

            // Most Recent Matches input handler
            elements.recentMatchesSelect.addEventListener('input', (e) => {
                let value = e.target.value.trim();
                console.log('Most Recent Matches input changed to:', value);
                if (value === '') {
                    return; // Allow empty, don't update yet
                }

                if (value.toLowerCase() === 'all') {
                    state.recentMatchesCount = 'All';
                    e.target.value = 'All';
                    console.log('Set recentMatchesCount to: All');
                } else {
                    const num = parseInt(value);
                    if (!isNaN(num) && num > 0) {
                        state.recentMatchesCount = num;
                        e.target.value = num.toString();
                        console.log('Set recentMatchesCount to:', num);
                    } else {
                        e.target.value = state.recentMatchesCount === 'All' ? 'All' : state.recentMatchesCount.toString();
                        return;
                    }
                }
                updateTable();
            });

            elements.recentMatchesSelect.addEventListener('blur', (e) => {
                let value = e.target.value.trim();
                if (value === '') {
                    state.recentMatchesCount = 'All';
                    e.target.value = 'All';
                    updateTable();
                }
            });

            // Match History controls with synchronization
            elements.matchHistoryHomeCheckbox.addEventListener('click', () => {
                state.matchHistoryHomeFilter = !state.matchHistoryHomeFilter;
                state.homeFilter = state.matchHistoryHomeFilter; // Sync with main home filter

                // Update all home checkboxes
                elements.matchHistoryHomeCheckbox.className = `checkbox ${state.matchHistoryHomeFilter ? 'checked' : ''} cursor-pointer flex items-center gap-1`;
                elements.h2hHomeCheckbox.className = `checkbox ${state.homeFilter ? 'checked' : ''}`;
                updateTable();
            });

            elements.matchHistoryAwayCheckbox.addEventListener('click', () => {
                state.matchHistoryAwayFilter = !state.matchHistoryAwayFilter;
                state.awayFilter = state.matchHistoryAwayFilter; // Sync with main away filter

                // Update all away checkboxes
                elements.matchHistoryAwayCheckbox.className = `checkbox ${state.matchHistoryAwayFilter ? 'checked' : ''} cursor-pointer flex items-center gap-1`;
                elements.h2hAwayCheckbox.className = `checkbox ${state.awayFilter ? 'checked' : ''}`;
                updateTable();
            });

            // H2H controls with synchronization
            elements.h2hHomeCheckbox.addEventListener('click', () => {
                state.homeFilter = !state.homeFilter;
                state.matchHistoryHomeFilter = state.homeFilter; // Sync with match history

                // Update all home checkboxes
                elements.h2hHomeCheckbox.className = `checkbox ${state.homeFilter ? 'checked' : ''}`;
                elements.matchHistoryHomeCheckbox.className = `checkbox ${state.matchHistoryHomeFilter ? 'checked' : ''} cursor-pointer flex items-center gap-1`;
                updateTable();
            });

            elements.h2hAwayCheckbox.addEventListener('click', () => {
                state.awayFilter = !state.awayFilter;
                state.matchHistoryAwayFilter = state.awayFilter; // Sync with match history

                // Update all away checkboxes
                elements.h2hAwayCheckbox.className = `checkbox ${state.awayFilter ? 'checked' : ''}`;
                elements.matchHistoryAwayCheckbox.className = `checkbox ${state.matchHistoryAwayFilter ? 'checked' : ''} cursor-pointer flex items-center gap-1`;
                updateTable();
            });
            
            elements.matchHistoryPenaltyCheckbox.addEventListener('click', () => {
                state.matchHistoryPenaltyFilter = !state.matchHistoryPenaltyFilter;
                elements.matchHistoryPenaltyCheckbox.className = `checkbox ${state.matchHistoryPenaltyFilter ? 'checked' : ''}`;

                // Update both the table and match history stats
                updateTable();

                // If single team is selected, recalculate match history stats with penalty filter
                if (state.selectedTeam1 && !state.selectedTeam2) {
                    const matchHistoryResult = calculateMatchHistory();
                    updateMatchHistoryDisplay(matchHistoryResult);
                }
            });

            elements.h2hPenaltyCheckbox.addEventListener('click', () => {
                state.h2hPenaltyFilter = !state.h2hPenaltyFilter;
                elements.h2hPenaltyCheckbox.className = `checkbox ${state.h2hPenaltyFilter ? 'checked' : ''}`;

                // Update both the table and head-to-head stats
                updateTable();

                // If both teams are selected, recalculate H2H stats with penalty filter
                if (state.selectedTeam1 && state.selectedTeam2) {
                    const h2hResult = calculateHeadToHead();
                    updateHeadToHeadDisplay(h2hResult);
                    updateH2HMatchesTable(h2hResult);
                }
            });
            
            elements.matchHistoryStageSelect.addEventListener('change', (e) => {
                console.log('Match History Stage dropdown changed to:', e.target.value);
                state.matchHistoryStage = e.target.value;
                console.log('state.matchHistoryStage set to:', state.matchHistoryStage);
                updateTable();
            });
            
            // Team Seasons controls
            elements.teamSeasonsLeagueButtons.addEventListener('click', (e) => {
                const button = e.target.closest('.league-button');
                if (button) {
                    handleTeamSeasonsLeagueChange(button.dataset.league);
                }
            });
            
            elements.teamSeasonsTeamSelect.addEventListener('change', (e) => {
                handleTeamSeasonsTeamChange(e.target.value);
            });
            
            elements.teamSeasonsSeasonSelect.addEventListener('change', (e) => {
                handleTeamSeasonsSeasonChange(e.target.value);
            });
            
            elements.teamSeasonsPositionSelect.addEventListener('change', (e) => {
                handleTeamSeasonsPositionChange(e.target.value);
            });
            
            elements.includeBetterResultsCheckbox.addEventListener('click', () => {
                state.includeBetterResults = !state.includeBetterResults;
                elements.includeBetterResultsCheckbox.className = `checkbox ${state.includeBetterResults ? 'checked' : ''}`;

                // Refresh the current view
                if (state.teamSeasonsSelectedTeam) {
                    showTeamHistory(state.teamSeasonsSelectedTeam, state.teamSeasonsSelectedLeague);

                    // Re-show checkbox after showTeamHistory runs (only if both team and position selected)
                    setTimeout(() => {
                        if (state.teamSeasonsSelectedPosition) {
                            elements.includeBetterResultsContainer.classList.remove('hidden');
                            elements.includeBetterResultsContainer.style.display = 'flex';

                            // Apply proper checkbox styling
                            if (state.includeBetterResults) {
                                elements.includeBetterResultsCheckbox.style.backgroundColor = '#059669';
                                elements.includeBetterResultsCheckbox.style.borderColor = '#059669';
                                elements.includeBetterResultsCheckbox.style.border = '2px solid #059669';
                                elements.includeBetterResultsCheckbox.innerHTML = '<div style="width: 0.5rem; height: 0.75rem; border: solid white; border-width: 0 2px 2px 0; transform: rotate(45deg); margin-top: -1px;"></div>';
                            } else {
                                elements.includeBetterResultsCheckbox.style.backgroundColor = '';
                                elements.includeBetterResultsCheckbox.style.borderColor = '#d1d5db';
                                elements.includeBetterResultsCheckbox.style.border = '2px solid #d1d5db';
                                elements.includeBetterResultsCheckbox.innerHTML = '';
                            }
                        }
                    }, 100);
                }
            });

            // Collapse controls toggle event listener
            elements.collapseControlsBtn.addEventListener('click', toggleControlsCollapse);

            // Team Streaks controls
            elements.teamStreaksLeagueButtons.addEventListener('click', (e) => {
                const button = e.target.closest('.league-button');
                if (button) {
                    handleTeamStreaksLeagueChange(button.dataset.league);
                }
            });
            
            elements.teamStreaksStageSelect.addEventListener('change', (e) => {
                state.teamStreaksStage = e.target.value;
                handleTeamStreaksChange();
            });
            
            elements.teamStreaksStatusSelect.addEventListener('change', (e) => {
                handleTeamStreaksStatusChange(e.target.value);
            });
            
            elements.teamStreaksLocationSelect.addEventListener('change', (e) => {
                handleTeamStreaksLocationChange(e.target.value);
            });
            
            elements.teamStreaksTypeSelect.addEventListener('change', (e) => {
                handleTeamStreaksTypeChange(e.target.value);
            });
            
            elements.teamStreaksTeam1Select.addEventListener('change', (e) => {
                handleTeamStreaksTeam1Change(e.target.value);
            });
            
            elements.teamStreaksTeam2Select.addEventListener('change', (e) => {
                handleTeamStreaksTeam2Change(e.target.value);
            });
        }

        // Intelligent point deductions logic based on team selection
        function checkAndDisablePointDeductions() {
            if (state.selectedTeam1 || state.selectedTeam2) {
                // 1 or 2 teams selected - disable point deductions
                state.pointDeductionsEnabled = false;
                elements.deductionsCheckbox.className = 'checkbox';
            } else {
                // No teams selected - enable point deductions by default
                state.pointDeductionsEnabled = true;
                elements.deductionsCheckbox.className = 'checkbox checked';
            }
        }

        // Handle league change
        async function handleLeagueChange(newLeague) {
            state.selectedLeague = newLeague;
            state.selectedTeam1 = '';
            state.selectedTeam2 = '';
            state.selectedSeason = '';
            
            // Load league data if not already loaded
            if (!state.loadedLeagues || !state.loadedLeagues.has(newLeague)) {
                await loadLeagueDataForDevice(newLeague);
            } else {
                // If already loaded, just filter/update UI
                filterDataForCurrentLeague(newLeague);
            }
            
            // Reset Last Time When state
            state.lastTimeTeam1 = '';
            state.lastTimeTeam2 = '';
            state.lastTimeDayOfWeek = '';
            state.lastTimeLocation = '';
            
            // Reset Last Time When UI elements
            if (elements.lastTimeTeam1Select) elements.lastTimeTeam1Select.value = '';
            if (elements.lastTimeTeam2Select) elements.lastTimeTeam2Select.value = '';
            if (elements.lastTimeDayOfWeekSelect) elements.lastTimeDayOfWeekSelect.value = '';
            if (elements.lastTimeLocationSelect) elements.lastTimeLocationSelect.value = '';
            
            // Hide Last Time When results
            if (elements.lastTimeResults) elements.lastTimeResults.classList.add('hidden');
            hideAllLastTimeSections();
            
            createLeagueButtons();
            updateTeamSelects();
            updateTeamSeasonsTeamSelect();
            updateSeasonOptions();
            
            const leagueMapping = {
                'premier-league': 'E0',
                'la-liga': 'SP1', 
                'serie-a': 'I1',
                'bundesliga': 'D1',
                'ligue-1': 'F1'
            };
            
            // Set default date ranges for specific leagues
            if (newLeague === 'premier-league') {
                state.dateFrom = '1992-08-01';
                state.dateTo = '2026-06-30';
            } else if (newLeague === 'ligue-1') {
                state.dateFrom = '2002-07-01';
                state.dateTo = '2026-06-30';
            } else {
                // For other leagues, use the full data range
                const leagueData = state.data.filter(row => row.Div === leagueMapping[newLeague]);
                if (leagueData.length > 0) {
                    const dates = leagueData.map(row => row.dateObj);
                    const minDate = new Date(Math.min(...dates));
                    const maxDate = new Date(Math.max(...dates));
                    state.dateFrom = minDate.toISOString().split('T')[0];
                    state.dateTo = maxDate.toISOString().split('T')[0];
                }
            }
            
            elements.dateFrom.value = state.dateFrom;
            elements.dateTo.value = state.dateTo;
            
            updateTable();
        }

        // Update competition stage dropdown options based on current context
        function updateCompetitionStageOptions() {
            const isEraFilter = state.selectedSeason === 'all-european-cup-seasons-1955-2025' || 
                               state.selectedSeason === 'european-cup-era-1955-1992' || 
                               state.selectedSeason === 'champions-league-era-1992-2025';
            const isCustomDateRange = !state.selectedSeason || state.selectedSeason === '';
            
            // Show "All" option only for era filters or custom date ranges
            const showAllOption = isEraFilter || isCustomDateRange;
            
            if (showAllOption) {
                // Include "All" option
                elements.competitionStageSelect.innerHTML = `
                    <option value="">All</option>
                    <option value="group-stage">League/Group Stage</option>
                    <option value="knockout-stage">Knock-Out Stage</option>
                    <option value="Final">Final</option>
                    <option value="Semi-Finals">Semi-Finals</option>
                    <option value="Quarter-Finals">Quarter-Finals</option>
                    <option value="Round of 16">Round of 16</option>
                    <option value="Play-Offs">Play-Offs</option>
                    <option value="2. Round">2. Round</option>
                    <option value="1. Round">1. Round</option>
                `;
            } else {
                // Exclude "All" option for individual seasons
                elements.competitionStageSelect.innerHTML = `
                    <option value="group-stage">League/Group Stage</option>
                    <option value="knockout-stage">Knock-Out Stage</option>
                    <option value="Final">Final</option>
                    <option value="Semi-Finals">Semi-Finals</option>
                    <option value="Quarter-Finals">Quarter-Finals</option>
                    <option value="Round of 16">Round of 16</option>
                    <option value="Play-Offs">Play-Offs</option>
                    <option value="2. Round">2. Round</option>
                    <option value="1. Round">1. Round</option>
                `;
                // If currently set to "All", change to default for individual seasons
                if (state.competitionStage === '') {
                    state.competitionStage = 'group-stage';
                    elements.competitionStageSelect.value = 'group-stage';
                }
            }
            
            // Restore current selection if it exists in the new options
            if (state.competitionStage) {
                elements.competitionStageSelect.value = state.competitionStage;
            }
        }

        // Handle season change
        function handleSeasonChange(seasonKey) {
            state.selectedSeason = seasonKey;

            // Automatically set 3-point system based on season type
            if (seasonKey === '' || !seasonKey) {
                // No season selected (custom date range) - keep 3-point system ON
                state.threePointSystem = true;
            } else if (seasonKey.includes('-era-') || seasonKey.includes('all-')) {
                // Era filters - keep 3-point system ON
                state.threePointSystem = true;
            } else {
                // Individual season - turn 3-point system OFF (use historical)
                state.threePointSystem = false;
            }

            // Update checkbox UI
            elements.threePointCheckbox.className = `checkbox ${state.threePointSystem ? 'checked' : ''}`;

            // Set point deductions based on season type
            if (seasonKey === '' || !seasonKey) {
                // No season selected (custom date range) - disable point deductions
                state.pointDeductionsEnabled = false;
                elements.deductionsCheckbox.className = 'checkbox';
            } else {
                // Season or era filter selected - enable point deductions by default
                state.pointDeductionsEnabled = true;
                elements.deductionsCheckbox.className = 'checkbox checked';
            }

            // Update competition stage dropdown options based on season selection
            updateCompetitionStageOptions();

            // Set default competition stage if not already set
            if (!state.competitionStage) {
                state.competitionStage = '';
                elements.competitionStageSelect.value = '';
            }

            const seasonData = getSeasonDateRange(seasonKey);
            if (seasonData) {
                state.dateFrom = seasonData.start;
                state.dateTo = seasonData.end;
                elements.dateFrom.value = state.dateFrom;
                elements.dateTo.value = state.dateTo;
                updateTable();
            }
        }

        // Get season date range
        function getSeasonDateRange(seasonKey) {
            if (seasonKey === 'champions-league-era-1992-2025') {
                return { start: '1992-09-01', end: '2026-06-30' };
            }
            if (seasonKey === 'european-cup-era-1955-1992') {
                return { start: '1955-09-01', end: '1992-06-30' };
            }
            if (seasonKey === 'all-european-cup-seasons-1955-2025') {
                return { start: '1955-09-01', end: '2026-06-30' };
            }
            if (seasonKey === 'english-first-division-era-1888-1992') {
                return { start: '1888-09-08', end: '1992-05-25' };
            }
            if (seasonKey === 'all-english-seasons-1888-2025') {
                return { start: '1888-09-08', end: '2026-06-30' };
            }
            if (seasonKey === 'all-spanish-seasons-1928-2025') {
                return { start: '1929-01-01', end: '2026-06-30' };
            }
            if (seasonKey === 'all-italian-seasons-1929-2025') {
                return { start: '1929-07-01', end: '2026-06-30' };
            }
            if (seasonKey === 'all-german-seasons-1963-2025') {
                return { start: '1963-07-01', end: '2026-06-30' };
            }
            
            if (seasons[state.selectedLeague] && seasons[state.selectedLeague][seasonKey]) {
                return seasons[state.selectedLeague][seasonKey];
            }
            return null;
        }

        // Combobox functionality
        class Combobox {
            constructor(containerId, inputId, dropdownId, placeholder, onSelect) {
                this.container = document.getElementById(containerId);
                this.input = document.getElementById(inputId);
                this.dropdown = document.getElementById(dropdownId);
                this.placeholder = placeholder;
                this.onSelect = onSelect;
                this.options = [];
                this.filteredOptions = [];
                this.selectedIndex = -1;
                this.isOpen = false;

                this.init();
            }

            init() {
                // Input events
                this.input.addEventListener('focus', () => this.open());
                this.input.addEventListener('blur', () => {
                    // Delay close to allow for option click
                    setTimeout(() => this.close(), 150);
                });
                this.input.addEventListener('input', (e) => this.filterOptions(e.target.value));
                this.input.addEventListener('keydown', (e) => this.handleKeyDown(e));

                // Click arrow to toggle
                this.container.querySelector('.combobox-arrow').addEventListener('click', () => {
                    if (this.isOpen) {
                        this.close();
                    } else {
                        this.input.focus();
                        this.open();
                    }
                });

                // Click outside to close
                document.addEventListener('click', (e) => {
                    if (!this.container.contains(e.target)) {
                        this.close();
                    }
                });
            }

            setOptions(options) {
                this.options = options;
                this.filteredOptions = [...options];
                this.renderOptions();
            }

            filterOptions(query) {
                const lowerQuery = query.toLowerCase();
                this.filteredOptions = this.options.filter(option =>
                    option.text.toLowerCase().includes(lowerQuery)
                );
                this.selectedIndex = -1;
                this.renderOptions();

                // If user empties the field, select the empty option
                if (query === '') {
                    const emptyOption = this.options.find(opt => opt.value === '');
                    if (emptyOption && this.onSelect) {
                        this.onSelect(emptyOption.value, emptyOption.text);
                    }
                }

                if (!this.isOpen) {
                    this.open();
                }
            }

            renderOptions() {
                if (this.filteredOptions.length === 0) {
                    this.dropdown.innerHTML = '<div class="combobox-no-results">No teams found</div>';
                    return;
                }

                this.dropdown.innerHTML = this.filteredOptions.map((option, index) => {
                    // Get team logo if this is a team option (not empty option)
                    const logoHtml = option.value && option.value !== '' ? (() => {
                        const logoUrl = getTeamLogoUrl(option.value, state.selectedLeague);
                        return logoUrl ? `<img src="${logoUrl}" alt="${option.value} logo" class="combobox-team-logo" onerror="this.style.display='none'">` : '';
                    })() : '';

                    return `<div class="combobox-option ${index === this.selectedIndex ? 'highlighted' : ''}"
                              data-value="${option.value}" data-index="${index}">
                            ${logoHtml}
                            <span class="combobox-option-text">${option.text}</span>
                         </div>`;
                }).join('');

                // Add click events to options
                this.dropdown.querySelectorAll('.combobox-option').forEach(option => {
                    option.addEventListener('click', () => {
                        this.selectOption(option.dataset.value, option.querySelector('.combobox-option-text').textContent.trim());
                    });
                });
            }

            handleKeyDown(e) {
                if (!this.isOpen) return;

                switch(e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        this.selectedIndex = Math.min(this.selectedIndex + 1, this.filteredOptions.length - 1);
                        this.updateHighlight();
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        this.selectedIndex = Math.max(this.selectedIndex - 1, -1);
                        this.updateHighlight();
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (this.selectedIndex >= 0) {
                            const option = this.filteredOptions[this.selectedIndex];
                            this.selectOption(option.value, option.text);
                        }
                        break;
                    case 'Escape':
                        e.preventDefault();
                        this.close();
                        break;
                }
            }

            updateHighlight() {
                this.dropdown.querySelectorAll('.combobox-option').forEach((option, index) => {
                    option.classList.toggle('highlighted', index === this.selectedIndex);
                });
            }

            selectOption(value, text) {
                this.input.value = text;
                this.close();
                if (this.onSelect) {
                    this.onSelect(value, text);
                }
            }

            open() {
                this.isOpen = true;
                this.container.classList.add('open');
                this.renderOptions();
            }

            close() {
                this.isOpen = false;
                this.container.classList.remove('open');
                this.selectedIndex = -1;
            }

            setValue(value, text) {
                this.input.value = text || this.placeholder;
            }
        }

        // Initialize comboboxes
        let team1Combobox, team2Combobox, teamSeasonsCombobox, lastTimeTeam1Combobox, lastTimeTeam2Combobox, teamStreaksTeam1Combobox, teamStreaksTeam2Combobox;

        // Update team selects
        function updateTeamSelects() {
            const leagueTeams = getLeagueTeams();

            const team1Options = '<option value="">All Teams</option>' +
                leagueTeams.map(team => `<option value="${team}">${team}</option>`).join('');
            const team2Options = '<option value="">No Team</option>' +
                leagueTeams.map(team => `<option value="${team}">${team}</option>`).join('');

            elements.team1Select.innerHTML = team1Options;
            elements.team2Select.innerHTML = team2Options;

            // Initialize comboboxes if they don't exist
            if (!team1Combobox) {
                team1Combobox = new Combobox(
                    'team1ComboboxContainer',
                    'team1ComboboxInput',
                    'team1ComboboxDropdown',
                    'All Teams',
                    (value, text) => {
                        state.selectedTeam1 = value;
                        elements.team1Select.value = value;
                        console.log('Team 1 selected:', value);
                        // Trigger same logic as original dropdown
                        updateTable();
                    }
                );
            }

            if (!team2Combobox) {
                team2Combobox = new Combobox(
                    'team2ComboboxContainer',
                    'team2ComboboxInput',
                    'team2ComboboxDropdown',
                    'No Team',
                    (value, text) => {
                        state.selectedTeam2 = value;
                        elements.team2Select.value = value;
                        console.log('Team 2 selected:', value);
                        // Trigger same logic as original dropdown
                        updateTable();
                    }
                );
            }

            // Initialize Team Seasons combobox
            if (!teamSeasonsCombobox) {
                teamSeasonsCombobox = new Combobox(
                    'teamSeasonsComboboxContainer',
                    'teamSeasonsComboboxInput',
                    'teamSeasonsComboboxDropdown',
                    'Choose a team...',
                    (value, text) => {
                        console.log('Team Seasons team selected:', value);
                        handleTeamSeasonsTeamChange(value);
                    }
                );
            }

            // Initialize Last Time When comboboxes
            if (!lastTimeTeam1Combobox) {
                lastTimeTeam1Combobox = new Combobox(
                    'lastTimeTeam1ComboboxContainer',
                    'lastTimeTeam1ComboboxInput',
                    'lastTimeTeam1ComboboxDropdown',
                    'Select Team 1',
                    (value, text) => {
                        console.log('Last Time Team 1 selected:', value);
                        elements.lastTimeTeam1Select.value = value;
                        elements.lastTimeTeam1Select.dispatchEvent(new Event('change'));
                    }
                );
            }

            if (!lastTimeTeam2Combobox) {
                lastTimeTeam2Combobox = new Combobox(
                    'lastTimeTeam2ComboboxContainer',
                    'lastTimeTeam2ComboboxInput',
                    'lastTimeTeam2ComboboxDropdown',
                    'Select Team 2',
                    (value, text) => {
                        console.log('Last Time Team 2 selected:', value);
                        elements.lastTimeTeam2Select.value = value;
                        elements.lastTimeTeam2Select.dispatchEvent(new Event('change'));
                    }
                );
            }

            // Initialize Team Streaks comboboxes
            if (!teamStreaksTeam1Combobox) {
                teamStreaksTeam1Combobox = new Combobox(
                    'teamStreaksTeam1ComboboxContainer',
                    'teamStreaksTeam1ComboboxInput',
                    'teamStreaksTeam1ComboboxDropdown',
                    'Select Team 1',
                    (value, text) => {
                        console.log('Team Streaks Team 1 selected:', value);
                        elements.teamStreaksTeam1Select.value = value;
                        elements.teamStreaksTeam1Select.dispatchEvent(new Event('change'));
                    }
                );
            }

            if (!teamStreaksTeam2Combobox) {
                teamStreaksTeam2Combobox = new Combobox(
                    'teamStreaksTeam2ComboboxContainer',
                    'teamStreaksTeam2ComboboxInput',
                    'teamStreaksTeam2ComboboxDropdown',
                    'Select Team 2',
                    (value, text) => {
                        console.log('Team Streaks Team 2 selected:', value);
                        elements.teamStreaksTeam2Select.value = value;
                        elements.teamStreaksTeam2Select.dispatchEvent(new Event('change'));
                    }
                );
            }

            // Populate all combobox options
            const team1ComboOptions = [
                { value: '', text: 'All Teams' },
                ...leagueTeams.map(team => ({ value: team, text: team }))
            ];
            const team2ComboOptions = [
                { value: '', text: 'No Team' },
                ...leagueTeams.map(team => ({ value: team, text: team }))
            ];
            const teamComboOptions = [
                { value: '', text: 'Choose a team...' },
                ...leagueTeams.map(team => ({ value: team, text: team }))
            ];
            const lastTimeTeam1ComboOptions = [
                { value: '', text: 'Select Team 1' },
                ...leagueTeams.map(team => ({ value: team, text: team }))
            ];
            const lastTimeTeam2ComboOptions = [
                { value: '', text: 'Select Team 2' },
                ...leagueTeams.map(team => ({ value: team, text: team }))
            ];
            const teamStreaksTeam1ComboOptions = [
                { value: '', text: 'Select Team 1' },
                ...leagueTeams.map(team => ({ value: team, text: team }))
            ];
            const teamStreaksTeam2ComboOptions = [
                { value: '', text: 'Select Team 2' },
                ...leagueTeams.map(team => ({ value: team, text: team }))
            ];

            team1Combobox.setOptions(team1ComboOptions);
            team2Combobox.setOptions(team2ComboOptions);
            teamSeasonsCombobox.setOptions(teamComboOptions);
            lastTimeTeam1Combobox.setOptions(lastTimeTeam1ComboOptions);
            lastTimeTeam2Combobox.setOptions(lastTimeTeam2ComboOptions);
            teamStreaksTeam1Combobox.setOptions(teamStreaksTeam1ComboOptions);
            teamStreaksTeam2Combobox.setOptions(teamStreaksTeam2ComboOptions);

            // Also populate Last Time When team selects (for backward compatibility)
            const lastTimeTeam1Options = '<option value="">Select Team 1</option>' +
                leagueTeams.map(team => `<option value="${team}">${team}</option>`).join('');
            const lastTimeTeam2Options = '<option value="">Select Team 2</option>' +
                leagueTeams.map(team => `<option value="${team}">${team}</option>`).join('');

            elements.lastTimeTeam1Select.innerHTML = lastTimeTeam1Options;
            elements.lastTimeTeam2Select.innerHTML = lastTimeTeam2Options;

            elements.team1Select.value = state.selectedTeam1;
            elements.team2Select.value = state.selectedTeam2;

            // Update combobox values
            const team1Text = state.selectedTeam1 || 'All Teams';
            const team2Text = state.selectedTeam2 || 'No Team';
            team1Combobox.setValue(state.selectedTeam1, team1Text);
            team2Combobox.setValue(state.selectedTeam2, team2Text);

            // Update other combobox values
            const teamSeasonsText = state.teamSeasonsSelectedTeam || 'Choose a team...';
            teamSeasonsCombobox.setValue(state.teamSeasonsSelectedTeam, teamSeasonsText);

            // Set default values for Last Time When and Team Streaks comboboxes
            lastTimeTeam1Combobox.setValue('', 'Select Team 1');
            lastTimeTeam2Combobox.setValue('', 'Select Team 2');
            teamStreaksTeam1Combobox.setValue('', 'Select Team 1');
            teamStreaksTeam2Combobox.setValue('', 'Select Team 2');
        }

        // Helper function to hide all Last Time sections
        function hideAllLastTimeSections() {
            elements.team1HomeWinSection.classList.add('hidden');
            elements.team1AwayWinSection.classList.add('hidden');
            elements.team1HomeDrawSection.classList.add('hidden');
            elements.team1AwayDrawSection.classList.add('hidden');
            elements.team1HomeLossSection.classList.add('hidden');
            elements.team1AwayLossSection.classList.add('hidden');
        }

        // Helper function to create match table row (matching Head-to-Head format)
        function createMatchTableRow(match) {
            const homeTeamColor = getTeamColor(match.HomeTeam, state.selectedLeague);
            const awayTeamColor = getTeamColor(match.AwayTeam, state.selectedLeague);
            
            const homeScore = parseInt(match.FTHG) || 0;
            const awayScore = parseInt(match.FTAG) || 0;
            
            // Determine winner and apply highlighting like Head-to-Head tables
            let homeScoreClass = '';
            let awayScoreClass = '';
            let resultStyle = '';
            let winnerTeam = '';
            
            if (homeScore > awayScore) {
                // Home team wins
                winnerTeam = match.HomeTeam;
                homeScoreClass = 'font-bold win-score';
                awayScoreClass = 'text-red-600 font-bold';
                resultStyle = homeTeamColor ? 
                    `color: ${homeTeamColor} !important; font-weight: bold;` : 
                    'color: #059669 !important; font-weight: bold;';
            } else if (awayScore > homeScore) {
                // Away team wins
                winnerTeam = match.AwayTeam;
                homeScoreClass = 'text-red-600 font-bold';
                awayScoreClass = 'font-bold win-score';
                resultStyle = awayTeamColor ? 
                    `color: ${awayTeamColor} !important; font-weight: bold;` : 
                    'color: #059669 !important; font-weight: bold;';
            } else {
                // Draw
                winnerTeam = 'Draw';
                homeScoreClass = 'text-gray-400 font-bold draw-score';
                awayScoreClass = 'text-gray-400 font-bold draw-score';
                resultStyle = 'color: #9ca3af !important; font-weight: bold;';
            }

            // Add team highlights - Team 1 green, Team 2 blue (like Head-to-Head)
            const isHomeTeam1 = match.HomeTeam === state.lastTimeTeam1;
            const isHomeTeam2 = match.HomeTeam === state.lastTimeTeam2;
            const isAwayTeam1 = match.AwayTeam === state.lastTimeTeam1;
            const isAwayTeam2 = match.AwayTeam === state.lastTimeTeam2;
            
            const homeTeamClass = isHomeTeam1 ? 'team1-highlight' : 
                                isHomeTeam2 ? 'team2-highlight' : '';
            const awayTeamClass = isAwayTeam1 ? 'team1-highlight' : 
                                isAwayTeam2 ? 'team2-highlight' : '';

            // Team styling (matching Head-to-Head format)
            const homeTeamStyle = homeTeamColor ? `color: ${homeTeamColor} !important; font-weight: bold;` : 'font-weight: bold;';
            const awayTeamStyle = awayTeamColor ? `color: ${awayTeamColor} !important; font-weight: bold;` : 'font-weight: bold;';
            
            // Result highlighting for winner
            let resultClass = '';
            if (winnerTeam !== 'Draw') {
                if (winnerTeam === state.lastTimeTeam1) {
                    resultClass = 'team1-highlight';
                } else if (winnerTeam === state.lastTimeTeam2) {
                    resultClass = 'team2-highlight';
                }
            }
            
            // Get team logos
            const homeLogoUrl = getTeamLogoUrl(match.HomeTeam, state.selectedLeague);
            const awayLogoUrl = getTeamLogoUrl(match.AwayTeam, state.selectedLeague);
            
            // Get winner logo for result column (if not a draw)
            const winnerLogoUrl = winnerTeam !== 'Draw' ? getTeamLogoUrl(winnerTeam, state.selectedLeague) : null;
            
            return `
                <tr class="border-b hover:bg-gray-50">
                    <td class="text-center text-sm">${match.dateObj.toLocaleDateString()}</td>
                    <td class="text-center">
                        <div class="flex items-center justify-center">
                            ${homeLogoUrl ? `<img src="${homeLogoUrl}" alt="${match.HomeTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                            <span class="${homeTeamClass}" style="${homeTeamStyle}">${match.HomeTeam}</span>
                        </div>
                    </td>
                    <td class="text-center text-lg ${homeScoreClass}" >${homeScore}</td>
                    <td class="text-center">
                        <div class="flex items-center justify-center">
                            ${awayLogoUrl ? `<img src="${awayLogoUrl}" alt="${match.AwayTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                            <span class="${awayTeamClass}" style="${awayTeamStyle}">${match.AwayTeam}</span>
                        </div>
                    </td>
                    <td class="text-center text-lg ${awayScoreClass}" >${awayScore}</td>
                    <td class="text-center">
                        <div class="flex items-center justify-center">
                            ${winnerLogoUrl ? `<img src="${winnerLogoUrl}" alt="${winnerTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                            <span class="${resultClass}" style="${resultStyle}">${winnerTeam}</span>
                        </div>
                    </td>
                </tr>
            `;
        }

        // Helper function to populate a result section
        function populateResultSection(sectionElement, bodyElement, daysElement, titleElement, result, team1Name, team2Name, resultType, isHome) {
            if (result) {
                sectionElement.classList.remove('hidden');
                bodyElement.innerHTML = createMatchTableRow(result);
                
                const daysSince = Math.floor((new Date() - result.dateObj) / (1000 * 60 * 60 * 24));
                daysElement.textContent = `${daysSince} days ago`;
                
                const location = isHome ? 'at Home' : 'Away';
                const color = resultType === 'Won' ? 'text-green-700' : resultType === 'Drew' ? 'text-gray-600' : 'text-red-600';
                titleElement.className = `text-lg font-semibold ${color} mb-3`;
                
                // Get team colors
                const team1Color = getTeamColor(team1Name, state.selectedLeague);
                const team2Color = team2Name ? getTeamColor(team2Name, state.selectedLeague) : null;
                
                // Use different title format for single-team vs two-team mode
                if (team2Name && team2Name !== team1Name) {
                    // Two-team mode: Last [Result] [Location] vs [Team2]
                    const resultWord = resultType === 'Won' ? 'Win' : resultType === 'Drew' ? 'Draw' : 'Loss';
                    titleElement.innerHTML = `<span style="color: ${team1Color || '#374151'}; font-weight: bold;">${team1Name}</span> Last ${resultWord} ${location} vs <span style="color: ${team2Color || '#374151'}; font-weight: bold;">${team2Name}</span>`;
                } else {
                    // Single-team mode: simple format
                    const resultWord = resultType === 'Won' ? 'Win' : resultType === 'Drew' ? 'Draw' : 'Loss';
                    titleElement.innerHTML = `<span style="color: ${team1Color || '#374151'}; font-weight: bold;">${team1Name}</span> Last ${resultWord} ${location}`;
                }
            }
        }

        // Calculate last time when results
        function calculateLastTimeWhen() {
            if (!state.lastTimeTeam1) {
                elements.lastTimeResults.classList.add('hidden');
                return;
            }
            
            // Handle single team scenario (Team 1 only selected)
            if (!state.lastTimeTeam2) {
                calculateSingleTeamResults();
                return;
            }
            
            if (state.lastTimeTeam1 === state.lastTimeTeam2) {
                elements.lastTimeResults.classList.add('hidden');
                return;
            }
            
            // Hide all sections initially
            hideAllLastTimeSections();
            
            // Filter matches for the two selected teams (no domestic league filtering for Champions League data)
            let matches = state.data.filter(row => 
                ((row.HomeTeam === state.lastTimeTeam1 && row.AwayTeam === state.lastTimeTeam2) ||
                 (row.HomeTeam === state.lastTimeTeam2 && row.AwayTeam === state.lastTimeTeam1))
            );
            
            // Apply qualifier exclusion filter if enabled
            if (state.excludeQualifiers) {
                matches = matches.filter(row => !row.isQualifier);
            }
            
            // Apply main stage exclusion filter if enabled
            if (state.excludeMainStage) {
                matches = matches.filter(row => row.isQualifier);
            }
            
            // Apply day of week filter if selected
            if (state.lastTimeDayOfWeek !== '') {
                matches = matches.filter(row => {
                    const dayOfWeek = row.dateObj.getDay();
                    return dayOfWeek.toString() === state.lastTimeDayOfWeek;
                });
            }
            
            // Apply location filter if selected
            // Location filter state
            // Matches before location filter
            if (state.lastTimeLocation !== '') {
                matches = matches.filter(row => {
                    if (state.lastTimeLocation === 'home') {
                        // Only show matches where Team 1 was playing at home
                        // Filtering for home matches
                        return row.HomeTeam === state.lastTimeTeam1;
                    } else if (state.lastTimeLocation === 'away') {
                        // Only show matches where Team 1 was playing away
                        // Filtering for away matches
                        return row.AwayTeam === state.lastTimeTeam1;
                    }
                    // If 'Both Home and Away' or empty, show all matches (no filtering)
                    return true;
                });
                // Matches after location filter
            }
            
            // Apply stage filter if selected
            if (state.lastTimeStage !== '') {
                matches = matches.filter(row => {
                    return matchesStageCategory(row.CompetitionPhase, state.lastTimeStage);
                });
            }
            
            // Sort matches by date (most recent first)
            matches.sort((a, b) => b.dateObj - a.dateObj);
            
            // Find last occurrence of each result type
            const results = {
                team1HomeWin: null,    // Team 1 won at home
                team1AwayWin: null,    // Team 1 won away
                team1HomeDraw: null,   // Team 1 drew at home
                team1AwayDraw: null,   // Team 1 drew away
                team1HomeLoss: null,   // Team 1 lost at home
                team1AwayLoss: null    // Team 1 lost away
            };
            
            matches.forEach(match => {
                const homeScore = parseInt(match.FTHG) || 0;
                const awayScore = parseInt(match.FTAG) || 0;
                
                if (match.HomeTeam === state.lastTimeTeam1 && match.AwayTeam === state.lastTimeTeam2) {
                    // Team 1 is home, Team 2 is away
                    if (homeScore > awayScore && !results.team1HomeWin) {
                        results.team1HomeWin = match;
                    } else if (homeScore === awayScore && !results.team1HomeDraw) {
                        results.team1HomeDraw = match;
                    } else if (homeScore < awayScore && !results.team1HomeLoss) {
                        results.team1HomeLoss = match;
                    }
                } else if (match.HomeTeam === state.lastTimeTeam2 && match.AwayTeam === state.lastTimeTeam1) {
                    // Team 1 is away, Team 2 is home
                    if (awayScore > homeScore && !results.team1AwayWin) {
                        results.team1AwayWin = match;
                    } else if (homeScore === awayScore && !results.team1AwayDraw) {
                        results.team1AwayDraw = match;
                    } else if (homeScore > awayScore && !results.team1AwayLoss) {
                        results.team1AwayLoss = match;
                    }
                }
            });
            
            // Populate the 6 result sections
            populateResultSection(
                elements.team1HomeWinSection, elements.team1HomeWinBody, elements.team1HomeWinDays,
                elements.team1HomeWinTitle, results.team1HomeWin, state.lastTimeTeam1, state.lastTimeTeam2, 'Won', true
            );
            
            populateResultSection(
                elements.team1AwayWinSection, elements.team1AwayWinBody, elements.team1AwayWinDays,
                elements.team1AwayWinTitle, results.team1AwayWin, state.lastTimeTeam1, state.lastTimeTeam2, 'Won', false
            );
            
            populateResultSection(
                elements.team1HomeDrawSection, elements.team1HomeDrawBody, elements.team1HomeDrawDays,
                elements.team1HomeDrawTitle, results.team1HomeDraw, state.lastTimeTeam1, state.lastTimeTeam2, 'Drew', true
            );
            
            populateResultSection(
                elements.team1AwayDrawSection, elements.team1AwayDrawBody, elements.team1AwayDrawDays,
                elements.team1AwayDrawTitle, results.team1AwayDraw, state.lastTimeTeam1, state.lastTimeTeam2, 'Drew', false
            );
            
            populateResultSection(
                elements.team1HomeLossSection, elements.team1HomeLossBody, elements.team1HomeLossDays,
                elements.team1HomeLossTitle, results.team1HomeLoss, state.lastTimeTeam1, state.lastTimeTeam2, 'Lost', true
            );
            
            populateResultSection(
                elements.team1AwayLossSection, elements.team1AwayLossBody, elements.team1AwayLossDays,
                elements.team1AwayLossTitle, results.team1AwayLoss, state.lastTimeTeam1, state.lastTimeTeam2, 'Lost', false
            );
            
            // Show results
            elements.lastTimeResults.classList.remove('hidden');
        }

        // Calculate single team results (Team 1 vs all opponents)
        function calculateSingleTeamResults() {
            // Hide all sections initially
            hideAllLastTimeSections();
            // Filter matches for the selected team (no domestic league filtering for Champions League data)
            let matches = state.data.filter(row => 
                (row.HomeTeam === state.lastTimeTeam1 || row.AwayTeam === state.lastTimeTeam1)
            );
            
            // Apply qualifier exclusion filter if enabled
            if (state.excludeQualifiers) {
                matches = matches.filter(row => !row.isQualifier);
            }
            
            // Apply main stage exclusion filter if enabled
            if (state.excludeMainStage) {
                matches = matches.filter(row => row.isQualifier);
            }
            
            // Apply day of week filter if selected
            if (state.lastTimeDayOfWeek !== '') {
                matches = matches.filter(row => {
                    const dayOfWeek = row.dateObj.getDay();
                    return dayOfWeek.toString() === state.lastTimeDayOfWeek;
                });
            }
            
            // Apply location filter if selected
            // Single team - Location filter state
            // Single team - Matches before location filter
            if (state.lastTimeLocation !== '') {
                matches = matches.filter(row => {
                    if (state.lastTimeLocation === 'home') {
                        // Only show matches where Team 1 was playing at home
                        // Single team - Filtering for home matches
                        return row.HomeTeam === state.lastTimeTeam1;
                    } else if (state.lastTimeLocation === 'away') {
                        // Only show matches where Team 1 was playing away
                        // Single team - Filtering for away matches
                        return row.AwayTeam === state.lastTimeTeam1;
                    }
                    // If 'Both Home and Away' or empty, show all matches (no filtering)
                    return true;
                });
                // Single team - Matches after location filter
            }
            
            // Apply stage filter if selected
            if (state.lastTimeStage !== '') {
                matches = matches.filter(row => {
                    return matchesStageCategory(row.CompetitionPhase, state.lastTimeStage);
                });
            }
            
            // Sort matches by date (most recent first)
            matches.sort((a, b) => b.dateObj - a.dateObj);
            
            const today = new Date();
            
            // Find last occurrence of each result type
            const results = {
                team1HomeWin: null,
                team1HomeDraw: null,
                team1HomeLoss: null,
                team1AwayWin: null,
                team1AwayDraw: null,
                team1AwayLoss: null
            };
            
            matches.forEach(match => {
                const homeScore = parseInt(match.FTHG) || 0;
                const awayScore = parseInt(match.FTAG) || 0;
                
                if (match.HomeTeam === state.lastTimeTeam1) {
                    // Team 1 is home
                    if (homeScore > awayScore && !results.team1HomeWin) {
                        results.team1HomeWin = match;
                    } else if (homeScore === awayScore && !results.team1HomeDraw) {
                        results.team1HomeDraw = match;
                    } else if (homeScore < awayScore && !results.team1HomeLoss) {
                        results.team1HomeLoss = match;
                    }
                } else if (match.AwayTeam === state.lastTimeTeam1) {
                    // Team 1 is away
                    if (awayScore > homeScore && !results.team1AwayWin) {
                        results.team1AwayWin = match;
                    } else if (homeScore === awayScore && !results.team1AwayDraw) {
                        results.team1AwayDraw = match;
                    } else if (homeScore > awayScore && !results.team1AwayLoss) {
                        results.team1AwayLoss = match;
                    }
                }
            });
            
            // For single team, we get opponent team names from the matches
            function getSingleTeamOpponentName(match) {
                return match.HomeTeam === state.lastTimeTeam1 ? match.AwayTeam : match.HomeTeam;
            }
            
            // Populate the 6 result sections for single team
            if (results.team1HomeWin) {
                populateResultSection(
                    elements.team1HomeWinSection, elements.team1HomeWinBody, elements.team1HomeWinDays,
                    elements.team1HomeWinTitle, results.team1HomeWin, state.lastTimeTeam1, 
                    null, 'Won', true
                );
            }
            
            if (results.team1AwayWin) {
                populateResultSection(
                    elements.team1AwayWinSection, elements.team1AwayWinBody, elements.team1AwayWinDays,
                    elements.team1AwayWinTitle, results.team1AwayWin, state.lastTimeTeam1, 
                    null, 'Won', false
                );
            }
            
            if (results.team1HomeDraw) {
                populateResultSection(
                    elements.team1HomeDrawSection, elements.team1HomeDrawBody, elements.team1HomeDrawDays,
                    elements.team1HomeDrawTitle, results.team1HomeDraw, state.lastTimeTeam1, 
                    null, 'Drew', true
                );
            }
            
            if (results.team1AwayDraw) {
                populateResultSection(
                    elements.team1AwayDrawSection, elements.team1AwayDrawBody, elements.team1AwayDrawDays,
                    elements.team1AwayDrawTitle, results.team1AwayDraw, state.lastTimeTeam1, 
                    null, 'Drew', false
                );
            }
            
            if (results.team1HomeLoss) {
                populateResultSection(
                    elements.team1HomeLossSection, elements.team1HomeLossBody, elements.team1HomeLossDays,
                    elements.team1HomeLossTitle, results.team1HomeLoss, state.lastTimeTeam1, 
                    null, 'Lost', true
                );
            }
            
            if (results.team1AwayLoss) {
                populateResultSection(
                    elements.team1AwayLossSection, elements.team1AwayLossBody, elements.team1AwayLossDays,
                    elements.team1AwayLossTitle, results.team1AwayLoss, state.lastTimeTeam1, 
                    null, 'Lost', false
                );
            }
            
            // Show results
            elements.lastTimeResults.classList.remove('hidden');
        }

        // Helper function to check if a competition phase matches a stage category
        function matchesStageCategory(competitionPhase, stageCategory) {
            if (!competitionPhase || !stageCategory) return false;
            
            const phase = competitionPhase.toLowerCase();
            
            switch (stageCategory) {
                case 'League/Group Stage':
                    return phase.includes('league phase') ||
                           phase.includes('group') ||
                           phase.includes('preliminary') ||
                           phase.includes('intermediate') ||
                           /group [a-z]/i.test(competitionPhase) ||
                           /preliminary gr\. [a-z]/i.test(competitionPhase) ||
                           /intermediate gr\. [a-z]/i.test(competitionPhase);
                           
                case 'Knock-Out Stage':
                    return phase.includes('final') ||
                           phase.includes('semi-final') ||
                           phase.includes('quarter-final') ||
                           phase.includes('round of 16') ||
                           phase.includes('play-off') ||
                           phase.includes('2. round') ||
                           phase.includes('1. round');
                           
                case 'Final':
                    return phase === 'final';
                    
                case 'Semi-Finals':
                    return phase === 'semi-finals';
                    
                case 'Quarter-Finals':
                    return phase === 'quarter-finals';
                    
                case 'Round Of 16':
                case 'Round of 16':
                    return phase === 'round of 16';
                    
                case 'Play-Offs':
                    return phase === 'play-offs';
                    
                case '2. Round':
                    return phase === '2. round';
                    
                case '1. Round':
                    return phase === '1. round';
                    
                default:
                    return false;
            }
        }

        // Get teams for selected league
        function getLeagueTeams(league = null) {
            const leagueMapping = {
                'champions-league': 'C1',
                'europa-league': 'E1',
                'conference-league': 'C2'
            };
            
            const selectedDiv = leagueMapping[league || state.selectedLeague];
            const leagueData = state.data.filter(row => row.Div === selectedDiv);
            const leagueTeams = [...new Set([
                ...leagueData.map(row => row.HomeTeam), 
                ...leagueData.map(row => row.AwayTeam)
            ])]
                .filter(team => team && team.length > 1)
                .sort();
            
            return leagueTeams;
        }

        // Update season options
        function updateSeasonOptions() {
            const availableSeasons = getAvailableSeasons();
            const options = '<option value="">Select Season</option>' + 
                availableSeasons.map(season => {
                    let label = season;
                    if (season === 'champions-league-era-1992-2025') label = 'Champions League Era (1992-2025)';
                    if (season === 'european-cup-era-1955-1992') label = 'European Cup Era (1955-1992)';
                    if (season === 'all-european-cup-seasons-1955-2025') label = 'All European Cup Seasons (1955-2025)';
                    return `<option value="${season}">${label}</option>`;
                }).join('');
            
            elements.seasonSelect.innerHTML = options;
            elements.seasonSelect.value = state.selectedSeason;
        }

        // Get available seasons
        function getAvailableSeasons(league = null) {
            const leagueToUse = league || state.selectedLeague;
            if (!seasons[leagueToUse]) return [];

            const seasonsList = Object.keys(seasons[leagueToUse]).sort().reverse();

            // Filter out seasons that only contain qualifier matches
            const filteredSeasons = seasonsList.filter(season => {
                if (!state.data || state.data.length === 0) return true; // If no data loaded, show all seasons

                const leagueMapping = {
                    'champions-league': 'C1',
                    'europa-league': 'E1',
                    'conference-league': 'C3'
                };

                const divCode = leagueMapping[leagueToUse];
                if (!divCode) return true;

                // Get season date range
                const originalSelectedLeague = state.selectedLeague;
                state.selectedLeague = leagueToUse;
                const seasonDates = getSeasonDateRange(season);
                state.selectedLeague = originalSelectedLeague;

                if (!seasonDates) return true;

                const seasonStart = new Date(seasonDates.start);
                const seasonEnd = new Date(seasonDates.end);

                // Find matches in this season for this league
                const seasonMatches = state.data.filter(match =>
                    match.Div === divCode &&
                    match.dateObj >= seasonStart &&
                    match.dateObj <= seasonEnd
                );

                // Check if season has any non-qualifier matches
                const hasNonQualifierMatches = seasonMatches.some(match => !match.isQualifier);

                return hasNonQualifierMatches;
            });

            if (leagueToUse === 'champions-league') {
                return ['champions-league-era-1992-2025', 'european-cup-era-1955-1992', 'all-european-cup-seasons-1955-2025', ...filteredSeasons];
            }

            // For Europa League and Conference League, just return filtered seasons
            return filteredSeasons;
        }

        // Apply point deductions
        function applyPointDeductions(tableArray, filteredMatches, selectedLeagueDiv) {
            if (pointDeductions.length === 0 || !state.pointDeductionsEnabled) return tableArray;
            
            if (filteredMatches.length === 0) return tableArray;
            
            const matchDates = filteredMatches.map(match => match.dateObj);
            const filterStartDate = new Date(Math.min(...matchDates));
            const filterEndDate = new Date(Math.max(...matchDates));
            
            return tableArray.map(team => {
                let adjustedPoints = team.points;
                
                pointDeductions.forEach(deduction => {
                    if (deduction.team === team.team && deduction.league === selectedLeagueDiv) {
                        const deductionStart = new Date(deduction.startDate);
                        const deductionEnd = new Date(deduction.endDate);
                        
                        const hasOverlap = (filterStartDate <= deductionEnd) && (filterEndDate >= deductionStart);
                        
                        if (hasOverlap) {
                            adjustedPoints -= deduction.points;
                        }
                    }
                });
                
                return {
                    ...team,
                    points: Math.max(0, adjustedPoints),
                    originalPoints: team.points
                };
            });
        }

        // Calculate table (abbreviated - same logic as original)
        function calculateTable() {
            // Use all Champions League data (no division filtering needed)
            let filtered = [...state.data];

            // Check if we should group by CompetitionPhase (exclude when no season selected OR one of the three specific era filters)
            const isEraFilter = state.selectedSeason === 'all-european-cup-seasons-1955-2025' ||
                               state.selectedSeason === 'european-cup-era-1955-1992' ||
                               state.selectedSeason === 'champions-league-era-1992-2025';
            const isSpecificSeason = state.selectedSeason && state.selectedSeason !== '' && !isEraFilter;
            const shouldGroupByPhase = isSpecificSeason;

            // Auto-exclude qualifiers for specific season filters (not era filters)
            if (isSpecificSeason) {
                filtered = filtered.filter(row => !row.isQualifier);
            } else {
                // Apply manual qualifier exclusion filter for era filters and no season
                if (state.excludeQualifiers) {
                    filtered = filtered.filter(row => !row.isQualifier);
                }
            }

            // Apply main stage exclusion filter if enabled
            if (state.excludeMainStage) {
                filtered = filtered.filter(row => row.isQualifier);
            }
            
            // Filter by competition stage (always applies when stage is selected)
            if (state.competitionStage && state.competitionStage !== '') {
                const knockoutPhases = [
                    'Round Of 16', 'Round of 16', 'Quarter-Finals', 'Semi-Finals', 'Final', 
                    'Play-Offs', '1. Round', '2. Round'
                ];
                
                if (state.competitionStage === 'group-stage') {
                    // Show only non-knockout stages (League/Group Stage)
                    filtered = filtered.filter(row => {
                        const phase = row.CompetitionPhase || '';
                        return !knockoutPhases.includes(phase);
                    });
                } else if (state.competitionStage === 'knockout-stage') {
                    // Show only knockout stages
                    filtered = filtered.filter(row => {
                        const phase = row.CompetitionPhase || '';
                        return knockoutPhases.includes(phase);
                    });
                } else {
                    // Handle specific stage filtering
                    // If it's a knockout stage and we have a season selected, we want knockout grouping behavior
                    const isSpecificKnockoutStage = knockoutPhases.includes(state.competitionStage);
                    
                    if (isSpecificKnockoutStage && shouldGroupByPhase) {
                        // For specific knockout stages with season selected: 
                        // 1. First filter to show all knockout stages (for grouping)
                        // 2. Then the specific stage filter will be applied in the grouping function
                        filtered = filtered.filter(row => {
                            const phase = row.CompetitionPhase || '';
                            return knockoutPhases.includes(phase);
                        });
                    } else {
                        // For non-knockout stages or when no season selected, use exact matching
                        filtered = filtered.filter(row => {
                            return matchesStageCategory(row.CompetitionPhase, state.competitionStage);
                        });
                    }
                }
            }
            
            // Date filters
            if (state.dateFrom) {
                filtered = filtered.filter(row => {
                    const matchDateStr = new Date(row.dateObj).toISOString().split('T')[0];
                    return matchDateStr >= state.dateFrom;
                });
            }
            
            if (state.dateTo) {
                filtered = filtered.filter(row => {
                    const matchDateStr = new Date(row.dateObj).toISOString().split('T')[0];
                    return matchDateStr <= state.dateTo;
                });
            }
            
            // Day of week filter
            if (state.selectedDayOfWeek !== '') {
                filtered = filtered.filter(row => {
                    const dayOfWeek = row.dateObj.getDay();
                    return dayOfWeek.toString() === state.selectedDayOfWeek;
                });
            }
            
            if (state.selectedTeam1 && state.selectedTeam2) {
                // First filter for H2H matches
                filtered = filtered.filter(row => 
                    (row.HomeTeam === state.selectedTeam1 && row.AwayTeam === state.selectedTeam2) ||
                    (row.HomeTeam === state.selectedTeam2 && row.AwayTeam === state.selectedTeam1)
                );
                
                // Apply home/away filtering based on state (same logic as calculateHeadToHead)
                if (state.homeFilter && !state.awayFilter) {
                    // Show only matches where Team 1 is home
                    filtered = filtered.filter(row => row.HomeTeam === state.selectedTeam1);
                } else if (state.awayFilter && !state.homeFilter) {
                    // Show only matches where Team 1 is away
                    filtered = filtered.filter(row => row.AwayTeam === state.selectedTeam1);
                }
                // If both are checked or both unchecked, show all H2H matches
                
                // Apply H2H stage filter if selected
                if (state.h2hStage !== '') {
                    filtered = filtered.filter(row => {
                        return matchesStageCategory(row.CompetitionPhase, state.h2hStage);
                    });
                }

                // Apply H2H penalty shootouts filter if selected
                if (state.h2hPenaltyFilter) {
                    filtered = filtered.filter(row =>
                        row.AdditionalInfo &&
                        row.AdditionalInfo.toLowerCase().includes('pso')
                    );
                }

                // Apply recent H2H filter if specified
                if (state.recentH2HCount !== 'All') {
                    // Sort by date (most recent first) and take the specified number
                    filtered = filtered
                        .sort((a, b) => new Date(b.dateObj) - new Date(a.dateObj))
                        .slice(0, parseInt(state.recentH2HCount));
                }
            } else if (state.selectedTeam1) {
                // For single team selection: filter to show only matches involving the selected team
                filtered = filtered.filter(row => row.HomeTeam === state.selectedTeam1 || row.AwayTeam === state.selectedTeam1);

                // Apply stage filter if selected (H2H stage or Match History stage)
                const stageFilter = state.h2hStage || state.matchHistoryStage;
                if (stageFilter && stageFilter !== '') {
                    const beforeFilter = filtered.length;
                    filtered = filtered.filter(row => {
                        return matchesStageCategory(row.CompetitionPhase, stageFilter);
                    });
                    const afterFilter = filtered.length;
                    // Debug: This should show the filtering is working
                    console.log(`Stage Filter (${state.h2hStage ? 'H2H' : 'Match History'}): ${stageFilter}, Before: ${beforeFilter}, After: ${afterFilter}`);
                }

                // Apply Match History penalty shootouts filter if active (for single team)
                if (state.matchHistoryPenaltyFilter) {
                    filtered = filtered.filter(row =>
                        row.AdditionalInfo &&
                        row.AdditionalInfo.toLowerCase().includes('pso')
                    );
                }

                // Apply recent matches count limit (same as match history)
                if (state.recentMatchesCount !== 'All') {
                    const limit = parseInt(state.recentMatchesCount) || 0;
                    if (limit > 0) {
                        const beforeLimit = filtered.length;
                        // Sort by date (most recent first) before applying limit
                        filtered = filtered.sort((a, b) => new Date(b.dateObj) - new Date(a.dateObj));
                        filtered = filtered.slice(0, limit);
                        console.log(`Table Recent Matches Filter: Limit ${limit}, Before: ${beforeLimit}, After: ${filtered.length}`);
                    }
                }
            }
            
            // Determine teams to show
            let teamsToShow;
            if (state.selectedTeam1 && state.selectedTeam2) {
                // H2H mode: only show the two selected teams
                teamsToShow = [state.selectedTeam1, state.selectedTeam2];
            } else if (state.selectedTeam1) {
                // Single team mode: only show the selected team
                teamsToShow = [state.selectedTeam1];
            } else {
                // No team selected: show all teams from filtered dataset
                teamsToShow = [...new Set([
                    ...filtered.map(row => row.HomeTeam),
                    ...filtered.map(row => row.AwayTeam)
                ])];
            }
            
            const table = {};
            teamsToShow.forEach(team => {
                table[team] = {
                    team: team,
                    played: 0,
                    won: 0,
                    drawn: 0,
                    lost: 0,
                    goalsFor: 0,
                    goalsAgainst: 0,
                    goalDifference: 0,
                    points: 0
                };
            });
            
            // Process matches with historical point systems
            filtered.forEach(match => {
                const homeTeam = table[match.HomeTeam];
                const awayTeam = table[match.AwayTeam];
                
                const homeGoals = parseInt(match.FTHG) || 0;
                const awayGoals = parseInt(match.FTAG) || 0;
                
                // Determine points system based on league and date
                let winPoints = 3;
                
                // If 3-point system is enabled, always use 3 points for wins
                if (state.threePointSystem) {
                    winPoints = 3;
                } else {
                    // Use historical point system based on getHistoricalPointSystem function
                    const leagueMap = {
                        'E0': 'premier-league',
                        'SP1': 'la-liga', 
                        'I1': 'serie-a',
                        'D1': 'bundesliga',
                        'F1': 'ligue-1',
                        'C1': 'champions-league',
                        'E1': 'europa-league',
                        'C2': 'conference-league'
                    };
                    
                    const leagueName = leagueMap[match.Div];
                    if (leagueName) {
                        // Extract season from date for getHistoricalPointSystem
                        const year = match.dateObj.getFullYear();
                        const month = match.dateObj.getMonth();
                        const seasonYear = month >= 6 ? year : year - 1; // July-June season
                        const season = `${seasonYear}-${(seasonYear + 1).toString().slice(-2)}`;
                        
                        winPoints = getHistoricalPointSystem(season, leagueName);
                    }
                }
                
                // Home team stats
                if (homeTeam && (state.homeFilter || (state.selectedTeam1 && state.selectedTeam2))) {
                    homeTeam.played++;
                    homeTeam.goalsFor += homeGoals;
                    homeTeam.goalsAgainst += awayGoals;
                    
                    if (homeGoals > awayGoals) {
                        homeTeam.won++;
                        homeTeam.points += winPoints;
                    } else if (homeGoals < awayGoals) {
                        homeTeam.lost++;
                    } else {
                        homeTeam.drawn++;
                        homeTeam.points += 1;
                    }
                }
                
                // Away team stats
                if (awayTeam && (state.awayFilter || (state.selectedTeam1 && state.selectedTeam2))) {
                    awayTeam.played++;
                    awayTeam.goalsFor += awayGoals;
                    awayTeam.goalsAgainst += homeGoals;
                    
                    if (awayGoals > homeGoals) {
                        awayTeam.won++;
                        awayTeam.points += winPoints;
                    } else if (awayGoals < homeGoals) {
                        awayTeam.lost++;
                    } else {
                        awayTeam.drawn++;
                        awayTeam.points += 1;
                    }
                }
            });
            
            let tableArray = Object.values(table)
                .filter(team => team.played > 0)
                .map(team => ({
                    ...team,
                    goalDifference: team.goalsFor - team.goalsAgainst
                }));
            
            // For Champions League data, use 'C1' as the division identifier
            const selectedDiv = 'C1';
            tableArray = applyPointDeductions(tableArray, filtered, selectedDiv);
            
            // First, sort by points to establish the base ranking
            let pointsSortedArray = [...tableArray].sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                if (b.goalDifference !== a.goalDifference) return b.goalDifference - a.goalDifference;
                return b.goalsFor - a.goalsFor;
            });
            
            // Apply ranking overrides for historic seasons to the points-sorted array
            if (!state.sortConfig.key) {
                pointsSortedArray = applyRankingOverrides(pointsSortedArray, state.selectedLeague, state.selectedSeason);
            } else {
                // Apply custom sorting if requested - work with pointsSortedArray to preserve position logic
                pointsSortedArray.sort((a, b) => {
                    let aVal = a[state.sortConfig.key];
                    let bVal = b[state.sortConfig.key];
                    
                    if (typeof aVal === 'string') {
                        return state.sortConfig.direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    }
                    
                    return state.sortConfig.direction === 'asc' ? aVal - bVal : bVal - aVal;
                });
            }
            
            // Only apply position assignment logic when not using custom sorting
            if (!state.sortConfig.key) {
                // Add original position based on the final points/override ranking
                // Calculate positions properly handling ties and gaps
                
                // Step 1: Find all override positions and calculate blocked positions
                const overridePositions = [];
                const blockedPositions = new Set();
                
                pointsSortedArray.forEach(team => {
                    if (team.sharedPosition) {
                        overridePositions.push(team.sharedPosition);
                    }
                });
                
                // Group override positions and calculate blocked ranges
                const positionCounts = {};
                overridePositions.forEach(pos => {
                    positionCounts[pos] = (positionCounts[pos] || 0) + 1;
                });
                
                // Block positions based on ties (e.g., two 4s block positions 4 and 5)
                Object.keys(positionCounts).forEach(pos => {
                    const position = parseInt(pos);
                    const count = positionCounts[pos];
                    
                    // Block 'count' positions starting from 'position'
                    for (let i = 0; i < count; i++) {
                        blockedPositions.add(position + i);
                    }
                });
                
                // Step 2: Assign positions to regular teams (skip blocked positions)
                let currentPosition = 1;
                const regularTeams = pointsSortedArray.filter(team => !team.sharedPosition);
                
                regularTeams.forEach(team => {
                    // Find next available position (skip blocked ones)
                    while (blockedPositions.has(currentPosition)) {
                        currentPosition++;
                    }
                    
                    team.originalPosition = currentPosition;
                    currentPosition++;
                });
                
                // Step 3: Set override positions
                pointsSortedArray.forEach(team => {
                    if (team.sharedPosition) {
                        team.originalPosition = team.sharedPosition;
                    }
                });
                
                // Step 4: Sort teams by their final position for proper display order
                pointsSortedArray.sort((a, b) => {
                    if (a.originalPosition !== b.originalPosition) {
                        return a.originalPosition - b.originalPosition;
                    }
                    // If positions are equal, maintain original order (sub-order for tied teams)
                    return 0;
                });
            } else {
                // For custom sorting, just assign sequential positions based on current order
                pointsSortedArray.forEach((team, index) => {
                    team.originalPosition = index + 1;
                });
            }
            
            // Use the properly sorted array for display
            tableArray = pointsSortedArray;
            
            // Group by CompetitionPhase if season is selected (excluding the three specific era filters)
            if (shouldGroupByPhase) {
                return groupTablesByCompetitionPhase(filtered, tableArray);
            }
            
            return { tableData: tableArray, matchCount: filtered.length };
        }

        // Group tables by CompetitionPhase for season filtering
        function groupTablesByCompetitionPhase(filteredMatches, allTeamsTable) {
            // Get unique competition phases from filtered matches
            let competitionPhases = [...new Set(filteredMatches.map(match => match.CompetitionPhase || 'Unknown'))]
                .filter(phase => phase && phase.trim() !== '');
            
            // If a specific knockout stage is selected, filter to only show that stage
            const knockoutPhases = [
                'Round Of 16', 'Round of 16', 'Quarter-Finals', 'Semi-Finals', 'Final', 
                'Play-Offs', '1. Round', '2. Round'
            ];
            
            if (state.competitionStage && state.competitionStage !== 'knockout-stage' && state.competitionStage !== 'group-stage') {
                // Filter to only show the specific stage
                competitionPhases = competitionPhases.filter(phase => {
                    return matchesStageCategory(phase, state.competitionStage);
                });
            }
            
            // Sort phases - for knockout stages, sort by earliest match date (chronologically)
            const isKnockoutStageFilter = state.competitionStage === 'knockout-stage' || 
                                        (knockoutPhases.includes(state.competitionStage));
            
            if (isKnockoutStageFilter) {
                // Sort knockout phases by earliest match date
                competitionPhases.sort((a, b) => {
                    const aMatches = filteredMatches.filter(match => match.CompetitionPhase === a);
                    const bMatches = filteredMatches.filter(match => match.CompetitionPhase === b);
                    
                    if (aMatches.length === 0) return 1;
                    if (bMatches.length === 0) return -1;
                    
                    // Get earliest date for each phase
                    const aEarliestDate = Math.min(...aMatches.map(match => match.dateObj.getTime()));
                    const bEarliestDate = Math.min(...bMatches.map(match => match.dateObj.getTime()));
                    
                    return aEarliestDate - bEarliestDate; // Sort by earliest date ascending
                });
            } else {
                // For group stages, sort alphabetically
                competitionPhases.sort();
            }
            
            const phasesTables = {};
            let totalMatchCount = 0;
            
            competitionPhases.forEach(phase => {
                // Filter matches for this specific phase
                const phaseMatches = filteredMatches.filter(match => (match.CompetitionPhase || 'Unknown') === phase);
                totalMatchCount += phaseMatches.length;
                
                // Get teams that participated in this phase
                const phaseTeams = [...new Set([
                    ...phaseMatches.map(match => match.HomeTeam),
                    ...phaseMatches.map(match => match.AwayTeam)
                ])];
                
                // Create table for this phase
                const phaseTable = {};
                phaseTeams.forEach(team => {
                    phaseTable[team] = {
                        team: team,
                        played: 0,
                        won: 0,
                        drawn: 0,
                        lost: 0,
                        goalsFor: 0,
                        goalsAgainst: 0,
                        goalDifference: 0,
                        points: 0
                    };
                });
                
                // Process matches for this phase
                phaseMatches.forEach(match => {
                    const homeTeam = phaseTable[match.HomeTeam];
                    const awayTeam = phaseTable[match.AwayTeam];
                    
                    const homeGoals = parseInt(match.FTHG) || 0;
                    const awayGoals = parseInt(match.FTAG) || 0;
                    
                    // Determine points system based on league and date
                    let winPoints = 3;
                    if (state.threePointSystem) {
                        winPoints = 3;
                    } else {
                        // Use historical point system for Champions League
                        // Champions League used 2 points for wins in 1994-95 and earlier seasons
                        const matchYear = match.dateObj.getFullYear();
                        const matchMonth = match.dateObj.getMonth(); // 0-based
                        
                        // If match is before July 1995, use 2 points
                        if (match.Div === 'C1' && (matchYear < 1995 || (matchYear === 1995 && matchMonth < 6))) {
                            winPoints = 2;
                        }
                    }
                    
                    if (homeTeam && awayTeam) {
                        homeTeam.played++;
                        awayTeam.played++;
                        homeTeam.goalsFor += homeGoals;
                        homeTeam.goalsAgainst += awayGoals;
                        awayTeam.goalsFor += awayGoals;
                        awayTeam.goalsAgainst += homeGoals;
                        
                        if (homeGoals > awayGoals) {
                            homeTeam.won++;
                            awayTeam.lost++;
                            homeTeam.points += winPoints;
                        } else if (homeGoals < awayGoals) {
                            awayTeam.won++;
                            homeTeam.lost++;
                            awayTeam.points += winPoints;
                        } else {
                            homeTeam.drawn++;
                            awayTeam.drawn++;
                            homeTeam.points += 1;
                            awayTeam.points += 1;
                        }
                        
                        homeTeam.goalDifference = homeTeam.goalsFor - homeTeam.goalsAgainst;
                        awayTeam.goalDifference = awayTeam.goalsFor - awayTeam.goalsAgainst;
                    }
                });
                
                // Convert to array and sort
                const phaseTableArray = sortPhaseTableData(Object.values(phaseTable), phase);
                
                // Add positions
                phaseTableArray.forEach((team, index) => {
                    team.originalPosition = index + 1;
                });
                
                phasesTables[phase] = {
                    phase: phase,
                    tableData: phaseTableArray,
                    matchCount: phaseMatches.length,
                    matches: phaseMatches
                };
            });
            
            return {
                isGroupedByPhase: true,
                phases: phasesTables,
                totalMatchCount: totalMatchCount,
                phaseNames: competitionPhases
            };
        }

        // Calculate head-to-head stats (abbreviated - same logic as original)
        function calculateHeadToHead() {
            if (!state.selectedTeam1 || !state.selectedTeam2) return null;
            
            // Use all Champions League data (no division filtering needed)
            let filtered = [...state.data];
            
            // Apply qualifier exclusion filter if enabled
            if (state.excludeQualifiers) {
                filtered = filtered.filter(row => !row.isQualifier);
            }
            
            // Apply main stage exclusion filter if enabled
            if (state.excludeMainStage) {
                filtered = filtered.filter(row => row.isQualifier);
            }
            
            // Apply date filters
            if (state.dateFrom) {
                filtered = filtered.filter(row => {
                    const matchDateStr = new Date(row.dateObj).toISOString().split('T')[0];
                    return matchDateStr >= state.dateFrom;
                });
            }
            
            if (state.dateTo) {
                filtered = filtered.filter(row => {
                    const matchDateStr = new Date(row.dateObj).toISOString().split('T')[0];
                    return matchDateStr <= state.dateTo;
                });
            }
            
            // Day of week filter
            if (state.selectedDayOfWeek !== '') {
                filtered = filtered.filter(row => {
                    const dayOfWeek = row.dateObj.getDay();
                    return dayOfWeek.toString() === state.selectedDayOfWeek;
                });
            }
            
            // Apply stage filter if selected
            if (state.h2hStage !== '') {
                filtered = filtered.filter(row => {
                    return matchesStageCategory(row.CompetitionPhase, state.h2hStage);
                });
            }

            // Apply penalty shootouts filter if selected
            if (state.h2hPenaltyFilter) {
                filtered = filtered.filter(row =>
                    row.AdditionalInfo &&
                    row.AdditionalInfo.toLowerCase().includes('pso')
                );
            }

            // Filter for head-to-head matches
            let h2hMatches = filtered.filter(row => 
                (row.HomeTeam === state.selectedTeam1 && row.AwayTeam === state.selectedTeam2) ||
                (row.HomeTeam === state.selectedTeam2 && row.AwayTeam === state.selectedTeam1)
            ).sort((a, b) => new Date(b.dateObj) - new Date(a.dateObj));
            
            // Apply home/away filtering first (same logic as in updateH2HMatchesTable)
            if (state.homeFilter && !state.awayFilter) {
                // Only include matches where Team 1 is home
                h2hMatches = h2hMatches.filter(match => match.HomeTeam === state.selectedTeam1);
            } else if (state.awayFilter && !state.homeFilter) {
                // Only include matches where Team 1 is away  
                h2hMatches = h2hMatches.filter(match => match.AwayTeam === state.selectedTeam1);
            }
            // If both are selected, show all matches (no additional filtering)
            
            // Then apply recent match count limit to the already filtered matches
            if (state.recentH2HCount !== 'All') {
                const limit = parseInt(state.recentH2HCount) || 0;
                h2hMatches = h2hMatches.slice(0, limit);
            }
            
            // Calculate stats (abbreviated logic)
            const team1Home = h2hMatches.filter(match => match.HomeTeam === state.selectedTeam1);
            const team1HomeStats = { wins: 0, draws: 0, losses: 0, total: team1Home.length };
            
            team1Home.forEach(match => {
                const homeGoals = parseInt(match.FTHG) || 0;
                const awayGoals = parseInt(match.FTAG) || 0;
                if (homeGoals > awayGoals) team1HomeStats.wins++;
                else if (homeGoals < awayGoals) team1HomeStats.losses++;
                else team1HomeStats.draws++;
            });
            
            const team2Home = h2hMatches.filter(match => match.HomeTeam === state.selectedTeam2);
            const team2HomeStats = { wins: 0, draws: 0, losses: 0, total: team2Home.length };
            
            team2Home.forEach(match => {
                const homeGoals = parseInt(match.FTHG) || 0;
                const awayGoals = parseInt(match.FTAG) || 0;
                if (homeGoals > awayGoals) team2HomeStats.wins++;
                else if (homeGoals < awayGoals) team2HomeStats.losses++;
                else team2HomeStats.draws++;
            });
            
            console.log('calculateHeadToHead - Filtered H2H matches:', h2hMatches.length);
            console.log('calculateHeadToHead - Sample matches:', h2hMatches.slice(0, 3).map(m => `${m.HomeTeam} vs ${m.AwayTeam}`));

            return {
                team1HomeStats,
                team2HomeStats,
                totalMatches: h2hMatches.length,
                matches: h2hMatches,
                overallStats: {
                    team1Wins: team1HomeStats.wins + team2HomeStats.losses,
                    draws: team1HomeStats.draws + team2HomeStats.draws,
                    team2Wins: team1HomeStats.losses + team2HomeStats.wins,
                    total: h2hMatches.length
                }
            };
        }

        // Calculate single team match history
        function calculateMatchHistory() {
            if (!state.selectedTeam1 || state.selectedTeam2) return null;
            
            // Use all Champions League data (no division filtering needed)
            let filtered = [...state.data];
            
            // Apply qualifier exclusion filter if enabled
            if (state.excludeQualifiers) {
                filtered = filtered.filter(row => !row.isQualifier);
            }
            
            // Apply main stage exclusion filter if enabled
            if (state.excludeMainStage) {
                filtered = filtered.filter(row => row.isQualifier);
            }
            
            // Apply date filters
            if (state.dateFrom) {
                filtered = filtered.filter(row => {
                    const matchDateStr = new Date(row.dateObj).toISOString().split('T')[0];
                    return matchDateStr >= state.dateFrom;
                });
            }
            
            if (state.dateTo) {
                filtered = filtered.filter(row => {
                    const matchDateStr = new Date(row.dateObj).toISOString().split('T')[0];
                    return matchDateStr <= state.dateTo;
                });
            }
            
            // Day of week filter
            if (state.selectedDayOfWeek !== '') {
                filtered = filtered.filter(row => {
                    const dayOfWeek = row.dateObj.getDay();
                    return dayOfWeek.toString() === state.selectedDayOfWeek;
                });
            }
            
            // Apply match history stage filter if selected
            if (state.matchHistoryStage !== '') {
                filtered = filtered.filter(row => {
                    return matchesStageCategory(row.CompetitionPhase, state.matchHistoryStage);
                });
            }
            
            // Filter for selected team matches
            let teamMatches = filtered.filter(row => 
                row.HomeTeam === state.selectedTeam1 || row.AwayTeam === state.selectedTeam1
            ).sort((a, b) => new Date(b.dateObj) - new Date(a.dateObj));
            
            // Apply match history filtering
            // First apply penalty shootouts filter if active
            if (state.matchHistoryPenaltyFilter) {
                teamMatches = teamMatches.filter(match => 
                    match.AdditionalInfo && 
                    match.AdditionalInfo.toLowerCase().includes('pso')
                );
            }
            
            // Then apply home/away filtering
            if (state.matchHistoryHomeFilter && !state.matchHistoryAwayFilter) {
                // Only include matches where Team 1 is home
                teamMatches = teamMatches.filter(match => match.HomeTeam === state.selectedTeam1);
            } else if (state.matchHistoryAwayFilter && !state.matchHistoryHomeFilter) {
                // Only include matches where Team 1 is away
                teamMatches = teamMatches.filter(match => match.AwayTeam === state.selectedTeam1);
            } else if (!state.matchHistoryHomeFilter && !state.matchHistoryAwayFilter) {
                // If both home/away are unchecked, show no matches unless penalty filter is active
                if (!state.matchHistoryPenaltyFilter) {
                    teamMatches = [];
                }
            }
            // If both home/away are checked, show all matches (no additional home/away filtering needed)

            // Apply recent matches count limit
            if (state.recentMatchesCount !== 'All') {
                const limit = parseInt(state.recentMatchesCount) || 0;
                if (limit > 0) {
                    const beforeLimit = teamMatches.length;
                    teamMatches = teamMatches.slice(0, limit);
                    console.log(`Recent Matches Filter: Limit ${limit}, Before: ${beforeLimit}, After: ${teamMatches.length}`);
                }
            }

            return {
                matches: teamMatches,
                totalMatches: teamMatches.length
            };
        }

        // Update match history display
        // Calculate penalty shootout stats for single team
        function calculateSingleTeamPenaltyStats(matches, teamName) {
            let teamWins = 0, teamLosses = 0;
            let homeWins = 0, homeLosses = 0;
            let awayWins = 0, awayLosses = 0;

            matches.forEach(match => {
                if (match.AdditionalInfo && match.AdditionalInfo.toLowerCase().includes('pso')) {
                    // Parse penalty score from AdditionalInfo like "pso 1:4" or "PSO 1:4"
                    const penaltyMatch = match.AdditionalInfo.match(/pso\s+(\d+):(\d+)/i);
                    if (penaltyMatch) {
                        const homePenalties = parseInt(penaltyMatch[1]);
                        const awayPenalties = parseInt(penaltyMatch[2]);
                        const isHome = match.HomeTeam === teamName;

                        // Determine if this team won or lost the penalty shootout
                        if (homePenalties > awayPenalties) {
                            // Home team won penalty shootout
                            if (isHome) {
                                teamWins++;
                                homeWins++;
                            } else {
                                teamLosses++;
                                awayLosses++;
                            }
                        } else if (awayPenalties > homePenalties) {
                            // Away team won penalty shootout
                            if (isHome) {
                                teamLosses++;
                                homeLosses++;
                            } else {
                                teamWins++;
                                awayWins++;
                            }
                        }
                    }
                }
            });

            const total = teamWins + teamLosses;
            return {
                teamWins,
                teamLosses,
                homeWins,
                homeLosses,
                awayWins,
                awayLosses,
                total
            };
        }

        // Update match history visualizations (Team Record)
        function updateMatchHistoryVisualizations(matches, teamName) {
            if (!matches || matches.length === 0) {
                elements.matchHistoryVisualizations.innerHTML = '';
                return;
            }

            // Use the pre-filtered matches passed in (no additional filtering needed)
            const recentMatches = matches;

            // Calculate team record statistics
            let wins = 0, draws = 0, losses = 0;
            let homeWins = 0, homeDraws = 0, homeLosses = 0;
            let awayWins = 0, awayDraws = 0, awayLosses = 0;

            recentMatches.forEach(match => {
                const homeScore = parseInt(match.FTHG) || 0;
                const awayScore = parseInt(match.FTAG) || 0;
                const isHome = match.HomeTeam === teamName;

                if (homeScore > awayScore) {
                    if (isHome) {
                        wins++;
                        homeWins++;
                    } else {
                        losses++;
                        awayLosses++;
                    }
                } else if (awayScore > homeScore) {
                    if (isHome) {
                        losses++;
                        homeLosses++;
                    } else {
                        wins++;
                        awayWins++;
                    }
                } else {
                    draws++;
                    if (isHome) {
                        homeDraws++;
                    } else {
                        awayDraws++;
                    }
                }
            });

            // Get team color
            const teamColor = getTeamColor(teamName, state.selectedLeague);

            // Generate visualization HTML
            const total = recentMatches.length;
            const teamBgStyle = teamColor ? `background: ${teamColor} !important; color: ${getContrastColor(teamColor)} !important;` : 'background: #059669 !important; color: white !important;';
            let visualizationHTML = '';

            // Check if penalty shootouts filter is active
            if (state.matchHistoryPenaltyFilter) {
                // Special penalty shootout visualization - only wins/losses, no draws
                const penaltyStats = calculateSingleTeamPenaltyStats(recentMatches, teamName);

                if (penaltyStats.total > 0) {
                    // Overall penalty record (show if both home and away are selected)
                    if (state.matchHistoryHomeFilter && state.matchHistoryAwayFilter) {
                        visualizationHTML += `
                            <div class="mb-4">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="text-sm font-semibold">${teamName} - Penalty Shootouts Record</span>
                                    <span class="text-sm text-gray-600">${penaltyStats.teamWins}W - ${penaltyStats.teamLosses}L</span>
                                </div>
                                <div class="h2h-viz-bar">
                                    <div class="h2h-segment h2h-wins" style="width: ${(penaltyStats.teamWins / penaltyStats.total) * 100}%; ${teamBgStyle}">
                                        ${penaltyStats.teamWins > 0 ? penaltyStats.teamWins : ''}
                                    </div>
                                    <div class="h2h-segment h2h-losses" style="width: ${(penaltyStats.teamLosses / penaltyStats.total) * 100}%;">
                                        ${penaltyStats.teamLosses > 0 ? penaltyStats.teamLosses : ''}
                                    </div>
                                </div>
                            </div>`;
                    }

                    // Home penalty record (show if home filter is enabled)
                    if (state.matchHistoryHomeFilter && (penaltyStats.homeWins + penaltyStats.homeLosses) > 0) {
                        const homeTotal = penaltyStats.homeWins + penaltyStats.homeLosses;
                        visualizationHTML += `
                            <div class="mb-4">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="text-sm font-semibold">${teamName} - Penalty Shootouts (Home)</span>
                                    <span class="text-sm text-gray-600">${penaltyStats.homeWins}W - ${penaltyStats.homeLosses}L</span>
                                </div>
                                <div class="h2h-viz-bar">
                                    <div class="h2h-segment h2h-wins" style="width: ${(penaltyStats.homeWins / homeTotal) * 100}%; ${teamBgStyle}">
                                        ${penaltyStats.homeWins > 0 ? penaltyStats.homeWins : ''}
                                    </div>
                                    <div class="h2h-segment h2h-losses" style="width: ${(penaltyStats.homeLosses / homeTotal) * 100}%;">
                                        ${penaltyStats.homeLosses > 0 ? penaltyStats.homeLosses : ''}
                                    </div>
                                </div>
                            </div>`;
                    }

                    // Away penalty record (show if away filter is enabled)
                    if (state.matchHistoryAwayFilter && (penaltyStats.awayWins + penaltyStats.awayLosses) > 0) {
                        const awayTotal = penaltyStats.awayWins + penaltyStats.awayLosses;
                        visualizationHTML += `
                            <div class="mb-4">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="text-sm font-semibold">${teamName} - Penalty Shootouts (Away)</span>
                                    <span class="text-sm text-gray-600">${penaltyStats.awayWins}W - ${penaltyStats.awayLosses}L</span>
                                </div>
                                <div class="h2h-viz-bar">
                                    <div class="h2h-segment h2h-wins" style="width: ${(penaltyStats.awayWins / awayTotal) * 100}%; ${teamBgStyle}">
                                        ${penaltyStats.awayWins > 0 ? penaltyStats.awayWins : ''}
                                    </div>
                                    <div class="h2h-segment h2h-losses" style="width: ${(penaltyStats.awayLosses / awayTotal) * 100}%;">
                                        ${penaltyStats.awayLosses > 0 ? penaltyStats.awayLosses : ''}
                                    </div>
                                </div>
                            </div>`;
                    }
                } else {
                    visualizationHTML += '<div class="text-sm text-gray-500 italic mb-4">No penalty shootout matches found</div>';
                }
            } else {
                // Regular visualization with wins/draws/losses

                // Show overall stats only if both home and away are selected
                if (state.matchHistoryHomeFilter && state.matchHistoryAwayFilter && total > 0) {
                visualizationHTML += `
                    <div class="mb-4">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-semibold">${teamName} - Overall Record</span>
                            <span class="text-sm text-gray-600">${wins}W - ${draws}D - ${losses}L</span>
                        </div>
                        <div class="h2h-viz-bar">
                            <div class="h2h-segment h2h-wins" style="width: ${(wins / total) * 100}%; ${teamBgStyle}">
                                ${wins > 0 ? wins : ''}
                            </div>
                            <div class="h2h-segment h2h-draws" style="width: ${(draws / total) * 100}%;">
                                ${draws > 0 ? draws : ''}
                            </div>
                            <div class="h2h-segment h2h-losses" style="width: ${(losses / total) * 100}%;">
                                ${losses > 0 ? losses : ''}
                            </div>
                        </div>
                    </div>
                `;
            }
            // Home Record (show if home filter is enabled)
            if (state.matchHistoryHomeFilter && (homeWins + homeDraws + homeLosses) > 0) {
                const homeTotal = homeWins + homeDraws + homeLosses;
                visualizationHTML += `
                    <div class="mb-4">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-semibold">${teamName} (Home)</span>
                            <span class="text-sm text-gray-600">${homeWins}W - ${homeDraws}D - ${homeLosses}L</span>
                        </div>
                        <div class="h2h-viz-bar">
                            <div class="h2h-segment h2h-wins" style="width: ${(homeWins / homeTotal) * 100}%; ${teamBgStyle}">
                                ${homeWins > 0 ? homeWins : ''}
                            </div>
                            <div class="h2h-segment h2h-draws" style="width: ${(homeDraws / homeTotal) * 100}%;">
                                ${homeDraws > 0 ? homeDraws : ''}
                            </div>
                            <div class="h2h-segment h2h-losses" style="width: ${(homeLosses / homeTotal) * 100}%;">
                                ${homeLosses > 0 ? homeLosses : ''}
                            </div>
                        </div>
                    </div>
                `;
            }
            // Away Record (show if away filter is enabled)
            if (state.matchHistoryAwayFilter && (awayWins + awayDraws + awayLosses) > 0) {
                const awayTotal = awayWins + awayDraws + awayLosses;
                visualizationHTML += `
                    <div class="mb-4">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-semibold">${teamName} (Away)</span>
                            <span class="text-sm text-gray-600">${awayWins}W - ${awayDraws}D - ${awayLosses}L</span>
                        </div>
                        <div class="h2h-viz-bar">
                            <div class="h2h-segment h2h-wins" style="width: ${(awayWins / awayTotal) * 100}%; ${teamBgStyle}">
                                ${awayWins > 0 ? awayWins : ''}
                            </div>
                            <div class="h2h-segment h2h-draws" style="width: ${(awayDraws / awayTotal) * 100}%;">
                                ${awayDraws > 0 ? awayDraws : ''}
                            </div>
                            <div class="h2h-segment h2h-losses" style="width: ${(awayLosses / awayTotal) * 100}%;">
                                ${awayLosses > 0 ? awayLosses : ''}
                            </div>
                        </div>
                    </div>
                `;
            }
            } // End of else block for regular visualization

            elements.matchHistoryVisualizations.innerHTML = visualizationHTML;
        }

        function updateMatchHistoryDisplay(matchHistoryResult) {
            if (matchHistoryResult && state.selectedTeam1 && !state.selectedTeam2) {
                elements.matchHistorySection.classList.remove('hidden');
                
                // Update table title to show stage filter and match count
                let titleText = `${state.selectedTeam1}`;
                if (state.matchHistoryStage !== '') {
                    titleText += ` - ${state.matchHistoryStage}`;
                }
                titleText += ` (${matchHistoryResult.matches.length} matches)`;
                elements.matchHistoryTableTitle.textContent = titleText;
                
                // Update match count display
                elements.matchHistoryMatchCount.textContent = `(${matchHistoryResult.matches.length} matches)`;
                
                // Update visualizations
                updateMatchHistoryVisualizations(matchHistoryResult.matches, state.selectedTeam1);

                // Update the table
                updateMatchHistoryTable(matchHistoryResult);
            } else {
                elements.matchHistorySection.classList.add('hidden');
            }
        }

        // Update match history table
        function updateMatchHistoryTable(matchHistoryResult) {
            if (!matchHistoryResult || !matchHistoryResult.matches || matchHistoryResult.matches.length === 0) {
                elements.matchHistoryTable.classList.add('hidden');
                return;
            }

            elements.matchHistoryTable.classList.remove('hidden');

            // Create table headers with sort indicators
            const matchHistoryHeaders = [
                { key: 'date', label: 'Date' },
                { key: 'stage', label: 'Stage' },
                { key: 'homeTeam', label: 'Home Team' },
                { key: 'homeScore', label: 'Home Score' },
                { key: 'awayTeam', label: 'Away Team' },
                { key: 'awayScore', label: 'Away Score' },
                { key: 'result', label: 'Result' }
            ];

            elements.matchHistoryTableHeader.innerHTML = matchHistoryHeaders.map(header => `
                <th class="text-center cursor-pointer" onclick="handleMatchHistorySort('${header.key}')">
                    ${header.label}${getMatchHistorySortIndicator(header.key)}
                </th>
            `).join('');

            // Create sorted matches data
            let matchesData = matchHistoryResult.matches.map(match => {
                const homeScore = parseInt(match.FTHG) || 0;
                const awayScore = parseInt(match.FTAG) || 0;
                
                // Determine if selected team is home or away
                const isHome = match.HomeTeam === state.selectedTeam1;
                const opponent = isHome ? match.AwayTeam : match.HomeTeam;
                
                // Get team colors first
                const homeTeamColor = getTeamColor(match.HomeTeam, state.selectedLeague);
                const awayTeamColor = getTeamColor(match.AwayTeam, state.selectedLeague);
                const selectedTeamColor = getTeamColor(state.selectedTeam1, state.selectedLeague);
                
                // Determine winner and result styling based on regulation time only
                let winnerTeam = '';
                let homeScoreClass = '';
                let awayScoreClass = '';
                let resultStyle = '';
                let penaltyInfo = '';
                
                // Always use regulation time score for the Result column
                if (homeScore > awayScore) {
                    winnerTeam = match.HomeTeam;
                    homeScoreClass = 'font-bold win-score';
                    awayScoreClass = 'text-red-600 font-bold';
                    resultStyle = homeTeamColor ?
                        `color: ${homeTeamColor} !important; font-weight: bold;` :
                        'color: #059669 !important; font-weight: bold;';
                } else if (awayScore > homeScore) {
                    winnerTeam = match.AwayTeam;
                    homeScoreClass = 'text-red-600 font-bold';
                    awayScoreClass = 'font-bold win-score';
                    resultStyle = awayTeamColor ?
                        `color: ${awayTeamColor} !important; font-weight: bold;` :
                        'color: #059669 !important; font-weight: bold;';
                } else {
                    winnerTeam = 'Draw';
                    homeScoreClass = 'text-gray-400 font-bold draw-score';
                    awayScoreClass = 'text-gray-400 font-bold draw-score';
                    resultStyle = 'color: #9ca3af !important; font-weight: bold;';
                }
                
                // Check if this is a penalty shootout match and create penalty info
                if (match.AdditionalInfo && match.AdditionalInfo.toLowerCase().includes('pso')) {
                    const penaltyMatch = match.AdditionalInfo.match(/pso\s+(\d+):(\d+)/);
                    if (penaltyMatch) {
                        const penaltyHomeScore = penaltyMatch[1];
                        const penaltyAwayScore = penaltyMatch[2];
                        const penaltyWinner = parseInt(penaltyHomeScore) > parseInt(penaltyAwayScore) ? match.HomeTeam : match.AwayTeam;
                        const penaltyLoser = penaltyWinner === match.HomeTeam ? match.AwayTeam : match.HomeTeam;
                        
                        penaltyInfo = `${penaltyWinner} def. ${penaltyLoser} (Penalty Shootout ${penaltyHomeScore}-${penaltyAwayScore})`;
                    }
                }
                
                // Result highlighting for winner (if it's the selected team)
                let resultClass = '';
                if (winnerTeam !== 'Draw' && winnerTeam === state.selectedTeam1) {
                    resultClass = 'team1-highlight';
                }
                
                return {
                    date: match.dateObj.toLocaleDateString(),
                    dateSort: match.dateObj,
                    homeTeam: match.HomeTeam,
                    homeTeamColor: homeTeamColor,
                    homeScore: homeScore,
                    homeScoreClass: homeScoreClass,
                    awayTeam: match.AwayTeam,
                    awayTeamColor: awayTeamColor,
                    awayScore: awayScore,
                    awayScoreClass: awayScoreClass,
                    result: winnerTeam,
                    resultClass: resultClass,
                    resultStyle: resultStyle,
                    opponent: opponent,
                    stage: match.CompetitionPhase || '',
                    selectedTeamColor: selectedTeamColor,
                    isHome: isHome,
                    penaltyInfo: penaltyInfo,
                    originalMatch: match
                };
            });

            // Apply sorting if configured
            if (state.matchHistorySortConfig.key && state.matchHistorySortConfig.direction) {
                const sortKey = state.matchHistorySortConfig.key;
                const sortDirection = state.matchHistorySortConfig.direction;

                matchesData.sort((a, b) => {
                    let valueA, valueB;

                    switch (sortKey) {
                        case 'date':
                            valueA = a.dateObj;
                            valueB = b.dateObj;
                            break;
                        case 'stage':
                            valueA = a.stage.toLowerCase();
                            valueB = b.stage.toLowerCase();
                            break;
                        case 'homeTeam':
                            valueA = a.homeTeam.toLowerCase();
                            valueB = b.homeTeam.toLowerCase();
                            break;
                        case 'homeScore':
                            valueA = a.homeScore;
                            valueB = b.homeScore;
                            break;
                        case 'awayTeam':
                            valueA = a.awayTeam.toLowerCase();
                            valueB = b.awayTeam.toLowerCase();
                            break;
                        case 'awayScore':
                            valueA = a.awayScore;
                            valueB = b.awayScore;
                            break;
                        case 'result':
                            valueA = a.result.toLowerCase();
                            valueB = b.result.toLowerCase();
                            break;
                        default:
                            return 0;
                    }

                    if (valueA < valueB) return sortDirection === 'asc' ? -1 : 1;
                    if (valueA > valueB) return sortDirection === 'asc' ? 1 : -1;
                    return 0;
                });
            }

            // Create table body
            const tableHTML = matchesData.map((match, index) => {
                // Get team logos
                const homeLogoUrl = getTeamLogoUrl(match.homeTeam, state.selectedLeague);
                const awayLogoUrl = getTeamLogoUrl(match.awayTeam, state.selectedLeague);
                
                // Get winner logo for result column (if not a draw) - same as H2H table
                const winnerLogoUrl = match.result !== 'Draw' ? getTeamLogoUrl(match.result, state.selectedLeague) : null;
                
                // Highlight selected team with green, non-selected team with transparent
                const homeTeamClass = match.homeTeam === state.selectedTeam1 ? 'team1-highlight' : 'team-transparent-highlight';
                const awayTeamClass = match.awayTeam === state.selectedTeam1 ? 'team1-highlight' : 'team-transparent-highlight';

                // Team styling to match H2H table format
                const homeTeamStyle = match.homeTeamColor ? `color: ${match.homeTeamColor} !important; font-weight: bold;` : 'font-weight: bold;';
                const awayTeamStyle = match.awayTeamColor ? `color: ${match.awayTeamColor} !important; font-weight: bold;` : 'font-weight: bold;';

                // Attach styling properties to match object for HTML template
                match.homeTeamClass = homeTeamClass;
                match.homeTeamStyle = homeTeamStyle;
                match.awayTeamClass = awayTeamClass;
                match.awayTeamStyle = awayTeamStyle;

                let rowHTML = `
                    <tr class="">
                        <td class="text-center text-sm">${match.date}</td>
                        <td class="text-center text-sm">${match.stage}</td>
                        <td class="text-center">
                            <div class="flex items-center justify-center">
                                ${homeLogoUrl ? `<img src="${homeLogoUrl}" alt="${match.homeTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                <span class="${match.homeTeamClass}" style="${match.homeTeamStyle}">${match.homeTeam}</span>
                            </div>
                        </td>
                        <td class="text-center text-lg ${match.homeScoreClass}">${match.homeScore}</td>
                        <td class="text-center">
                            <div class="flex items-center justify-center">
                                ${awayLogoUrl ? `<img src="${awayLogoUrl}" alt="${match.awayTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                <span class="${match.awayTeamClass}" style="${match.awayTeamStyle}">${match.awayTeam}</span>
                            </div>
                        </td>
                        <td class="text-center text-lg ${match.awayScoreClass}">${match.awayScore}</td>
                        <td class="text-center">
                            <div class="flex items-center justify-center">
                                ${winnerLogoUrl ? `<img src="${winnerLogoUrl}" alt="${match.result} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                <span class="${match.resultClass}" style="${match.resultStyle}">${match.result}</span>
                            </div>
                        </td>
                    </tr>
                `;
                
                // Add penalty shootout info row if this is a penalty match
                if (match.penaltyInfo) {
                    rowHTML += `
                        <tr class="border-b bg-gray-50">
                            <td colspan="7" class="text-center py-2 font-semibold text-gray-700 text-sm">
                                ${match.penaltyInfo}
                            </td>
                        </tr>
                    `;
                }
                
                return rowHTML;
            }).join('');
            
            elements.matchHistoryTableBody.innerHTML = tableHTML;
        }

        // Handle match history table sorting (placeholder)
        function handleMatchHistorySort(key) {
            let defaultDirection = 'desc';
            if (key === 'homeTeam' || key === 'awayTeam' || key === 'result' || key === 'stage') {
                defaultDirection = 'asc';
            }

            if (state.matchHistorySortConfig.key === key) {
                // Cycle through: current -> opposite -> none
                if (state.matchHistorySortConfig.direction === 'desc') {
                    state.matchHistorySortConfig.direction = 'asc';
                } else if (state.matchHistorySortConfig.direction === 'asc') {
                    // Reset to no sorting
                    state.matchHistorySortConfig.key = null;
                    state.matchHistorySortConfig.direction = null;
                } else {
                    // This shouldn't happen, but fallback
                    state.matchHistorySortConfig.direction = defaultDirection;
                }
            } else {
                // New column selected
                state.matchHistorySortConfig.key = key;
                state.matchHistorySortConfig.direction = defaultDirection;
            }

            updateTable();
        }

        // Update table and all related UI
        function updateTable() {
            if (state.data.length === 0) return;
            
            const tableResult = calculateTable();
            const h2hResult = calculateHeadToHead();
            const matchHistoryResult = calculateMatchHistory();
            
            updateTableDisplay(tableResult);
            updateHeadToHeadDisplay(h2hResult);
            updateMatchHistoryDisplay(matchHistoryResult);
            updateTableInfo(tableResult);
            
            // Handle position colors for dark mode
            setTimeout(handlePositionColors, 50);
        }

        // Update table display
        function updateTableDisplay(tableResult) {
            // Check if we have grouped tables by competition phase
            if (tableResult.isGroupedByPhase) {
                displayGroupedPhasesTables(tableResult);
                return;
            }
            
            // Regular single table display
            displaySingleTable(tableResult);
        }
        
        function displayGroupedPhasesTables(tableResult) {
            // For knockout stages, use match history format instead of league tables
            const knockoutPhases = [
                'Round Of 16', 'Round of 16', 'Quarter-Finals', 'Semi-Finals', 'Final', 
                'Play-Offs', '1. Round', '2. Round'
            ];
            const isKnockoutDisplay = state.competitionStage === 'knockout-stage' || 
                                    knockoutPhases.includes(state.competitionStage);
            
            if (isKnockoutDisplay) {
                displayKnockoutMatchHistory(tableResult);
                return;
            }
            
            // Create multiple tables for each competition phase (Group Stage)
            const tableContainer = elements.tableContainer;
            tableContainer.innerHTML = '';
            
            if (tableResult.phaseNames.length === 0) {
                tableContainer.classList.add('hidden');
                return;
            }
            
            tableResult.phaseNames.forEach(phaseName => {
                const phaseData = tableResult.phases[phaseName];
                
                // Create container for this phase
                const phaseContainer = document.createElement('div');
                phaseContainer.className = 'mb-8';
                
                // Create phase header
                const phaseHeader = document.createElement('h3');
                phaseHeader.className = 'text-xl font-bold text-gray-800 mb-4 text-center bg-blue-50 py-2 px-4 rounded-lg';
                phaseHeader.textContent = `${phaseName} (${phaseData.matchCount} matches)`;
                phaseContainer.appendChild(phaseHeader);
                
                // Create table for this phase with same styling as standard league table
                const phaseTable = document.createElement('div');
                phaseTable.className = 'league-table';
                
                const headers = [
                    { key: 'position', label: 'Pos' },
                    { key: 'team', label: 'Team' },
                    { key: 'played', label: 'P' },
                    { key: 'won', label: 'W' },
                    { key: 'drawn', label: 'D' },
                    { key: 'lost', label: 'L' },
                    { key: 'goalsFor', label: 'GF' },
                    { key: 'goalsAgainst', label: 'GA' },
                    { key: 'goalDifference', label: 'GD' },
                    { key: 'points', label: 'Pts' }
                ];
                
                phaseTable.innerHTML = `
                    <table>
                        <thead>
                            <tr>
                                ${headers.map(header => `
                                    <th class="px-3 py-4 text-center font-bold text-sm cursor-pointer hover:bg-gray-600" 
                                        onclick="handlePhaseSort('${header.key}', '${phaseName}')" 
                                        style="text-align: ${header.key === 'team' ? 'left' : 'center'}">
                                        ${header.label}${getPhaseTableSortIndicator(header.key, phaseName)}
                                    </th>
                                `).join('')}
                            </tr>
                        </thead>
                        <tbody>
                            ${phaseData.tableData.map((team, index) => {
                                const isTeam1 = state.selectedTeam1 === team.team;
                                const isTeam2 = state.selectedTeam2 === team.team;
                                // Only highlight when Team 1 is selected, or when both teams are selected
                                const isHighlighted = state.selectedTeam1 && (isTeam1 || isTeam2);

                                // Determine highlight class: team1-highlight for Team 1, team2-highlight for Team 2
                                const highlightClass = isHighlighted && isTeam1 ? 'team1-highlight' : isHighlighted && isTeam2 ? 'team2-highlight' : '';

                                // Only apply team color when team is highlighted
                                let teamColorStyle = '';
                                if (isHighlighted) {
                                    const teamColor = getTeamColor(team.team, state.selectedLeague);
                                    teamColorStyle = teamColor ? `color: ${teamColor} !important;` : '';
                                }

                                const rowBackgroundClass = phaseData.tableData.length >= 3 && index % 2 === 1 ? 'bg-gray-50' : 'bg-white';

                                return `
                                    <tr class="border-b hover:bg-gray-50 ${rowBackgroundClass}">
                                        <td class="px-3 py-4 text-center font-bold text-gray-600">${team.originalPosition}</td>
                                        <td class="px-4 py-4 font-semibold ${isHighlighted ? 'text-black' : 'text-gray-900'}">
                                            <div class="flex items-center cursor-pointer hover:bg-gray-100 rounded p-2 -m-2 team-clickable" data-team="${team.team}" title="Click to view ${team.team} history">
                                                ${(() => {
                                                    const logoUrl = getTeamLogoUrl(team.team, state.selectedLeague);
                                                    return logoUrl ? `<img src="${logoUrl}" alt="${team.team} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : '';
                                                })()}
                                                <span class="hover:underline team-name-text ${highlightClass}" style="${teamColorStyle}">${team.team}</span>
                                            </div>
                                        </td>
                                        <td class="px-3 py-4 text-center">${team.played}</td>
                                        <td class="px-3 py-4 text-center">${team.won}</td>
                                        <td class="px-3 py-4 text-center">${team.drawn}</td>
                                        <td class="px-3 py-4 text-center">${team.lost}</td>
                                        <td class="px-3 py-4 text-center">${team.goalsFor}</td>
                                        <td class="px-3 py-4 text-center">${team.goalsAgainst}</td>
                                        <td class="px-3 py-4 text-center">
                                            <span class="font-bold ${team.goalDifference > 0 ? 'text-green-700' : team.goalDifference < 0 ? 'text-red-600' : 'text-black'}">
                                                ${team.goalDifference > 0 ? '+' : ''}${team.goalDifference}
                                            </span>
                                        </td>
                                        <td class="px-3 py-4 text-center">
                                            <span class="points-badge">
                                                ${team.points}
                                            </span>
                                        </td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                `;
                
                phaseContainer.appendChild(phaseTable);
                tableContainer.appendChild(phaseContainer);
            });
            
            // Add event delegation for team clicks
            tableContainer.addEventListener('click', handleTeamClick);
            
            // Show table container
            const isLeagueFiltersActive = document.getElementById('leagueFiltersTab').classList.contains('active');
            if (isLeagueFiltersActive) {
                tableContainer.classList.remove('hidden');
            } else {
                tableContainer.classList.add('hidden');
            }
        }
        
        function displayKnockoutMatchHistory(tableResult) {
            // Create knockout match history tables grouped by round and team pairings
            const tableContainer = elements.tableContainer;
            tableContainer.innerHTML = '';
            
            if (tableResult.phaseNames.length === 0) {
                tableContainer.classList.add('hidden');
                return;
            }
            
            // Group by rounds (phases), maintaining chronological order
            tableResult.phaseNames.forEach(phaseName => {
                const phaseData = tableResult.phases[phaseName];
                const phaseMatches = phaseData.matches;
                
                if (phaseMatches.length === 0) return;
                
                // Create round header
                const roundContainer = document.createElement('div');
                roundContainer.className = 'mb-12';
                
                const roundHeader = document.createElement('h2');
                roundHeader.className = 'text-2xl font-bold text-gray-800 mb-6 text-center bg-green-100 py-3 px-6 rounded-lg border-2 border-green-300';
                roundHeader.textContent = phaseName;
                roundContainer.appendChild(roundHeader);
                
                // Group matches by team pairings within this round
                const teamPairings = {};
                phaseMatches.forEach(match => {
                    const team1 = match.HomeTeam;
                    const team2 = match.AwayTeam;
                    // Create consistent pairing key (alphabetical order)
                    const pairingKey = [team1, team2].sort().join(' vs ');
                    
                    if (!teamPairings[pairingKey]) {
                        teamPairings[pairingKey] = [];
                    }
                    teamPairings[pairingKey].push(match);
                });
                
                // Sort pairings by their first match date within this round
                const sortedPairings = Object.entries(teamPairings).sort(([keyA, matchesA], [keyB, matchesB]) => {
                    const firstMatchA = matchesA.reduce((earliest, match) => 
                        match.dateObj < earliest.dateObj ? match : earliest);
                    const firstMatchB = matchesB.reduce((earliest, match) => 
                        match.dateObj < earliest.dateObj ? match : earliest);
                    return firstMatchA.dateObj - firstMatchB.dateObj;
                });
                
                // Create a table for each team pairing in this round
                sortedPairings.forEach(([pairingKey, matches]) => {
                    // Sort matches by date (chronological order)
                    matches.sort((a, b) => a.dateObj - b.dateObj);
                    
                    // Create container for this pairing
                    const pairingContainer = document.createElement('div');
                    pairingContainer.className = 'mb-6';
                    
                    // Create pairing header
                    const pairingHeader = document.createElement('h3');
                    pairingHeader.className = 'text-xl font-bold text-gray-800 mb-4 text-center bg-blue-50 py-2 px-4 rounded-lg';
                    pairingHeader.textContent = `${pairingKey} (${matches.length} match${matches.length > 1 ? 'es' : ''})`;
                    pairingContainer.appendChild(pairingHeader);
                    
                    // Create match history table
                    const matchTable = document.createElement('div');
                    matchTable.className = 'league-table';
                    
                    matchTable.innerHTML = `
                        <table>
                            <thead>
                                <tr>
                                    <th class="px-3 py-4 text-center font-bold text-sm" style="text-align: center">Date</th>
                                    <th class="px-3 py-4 text-center font-bold text-sm" style="text-align: center">Home Team</th>
                                    <th class="px-3 py-4 text-center font-bold text-sm" style="text-align: center">Score</th>
                                    <th class="px-3 py-4 text-center font-bold text-sm" style="text-align: center">Away Team</th>
                                    <th class="px-3 py-4 text-center font-bold text-sm" style="text-align: center">Result</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${matches.map(match => createKnockoutMatchRow(match)).join('')}
                            </tbody>
                        </table>
                    `;
                    
                    pairingContainer.appendChild(matchTable);
                    
                    // Add aggregate score for two-legged ties (except Finals)
                    if (matches.length === 2 && phaseName.toLowerCase() !== 'final') {
                        const aggregateInfo = calculateAggregateScore(matches);
                        if (aggregateInfo) {
                            const aggregateDiv = document.createElement('div');
                            aggregateDiv.className = 'text-center mt-3 mb-2';
                            aggregateDiv.innerHTML = `
                                <p class="text-lg font-bold text-gray-700">
                                    <span style="color: ${aggregateInfo.winnerColor}; font-weight: bold;">
                                        ${aggregateInfo.winner}
                                    </span> 
                                    def. ${aggregateInfo.loser} ${aggregateInfo.totalScore}
                                </p>
                            `;
                            pairingContainer.appendChild(aggregateDiv);
                        }
                    }
                    
                    roundContainer.appendChild(pairingContainer);
                });
                
                tableContainer.appendChild(roundContainer);
            });
            
            // Show table container
            const isLeagueFiltersActive = document.getElementById('leagueFiltersTab').classList.contains('active');
            if (isLeagueFiltersActive) {
                tableContainer.classList.remove('hidden');
            } else {
                tableContainer.classList.add('hidden');
            }
        }
        
        function calculateTournamentProgression(teamName, teamMatches) {
            try {
                if (!teamMatches || teamMatches.length === 0) return 'Group Stage';
                
                // Sort matches by date to find the chronologically last match
                const sortedMatches = [...teamMatches].sort((a, b) => {
                    return new Date(a.dateObj) - new Date(b.dateObj);
                });
                
                // Get the last match this team played
                const lastMatch = sortedMatches[sortedMatches.length - 1];
                const lastPhase = lastMatch.CompetitionPhase || '';
                
                // Map phase names to standardized stage names
                let stageName = 'Group Stage';
                if (lastPhase.includes('Quarter')) {
                    stageName = 'Quarter-Finals';
                } else if (lastPhase.includes('Semi')) {
                    stageName = 'Semi-Finals';
                } else if (lastPhase.includes('Final') && !lastPhase.includes('Semi') && !lastPhase.includes('Quarter')) {
                    // Check if team won the final to determine if they are Champions
                    let teamWonFinal = false;
                    
                    // Check for penalty shootout in AdditionalInfo (format: "pso 3:4")
                    const additionalInfo = lastMatch.AdditionalInfo || '';
                    if (additionalInfo.includes('pso')) {
                        // Extract penalty score (e.g., "pso 3:4" -> "3:4")
                        const penaltyMatch = additionalInfo.match(/pso\s+(\d+):(\d+)/);
                        if (penaltyMatch) {
                            const homePenalties = parseInt(penaltyMatch[1]);
                            const awayPenalties = parseInt(penaltyMatch[2]);
                            
                            // Team won if they scored more penalties
                            teamWonFinal = (lastMatch.HomeTeam === teamName && homePenalties > awayPenalties) ||
                                          (lastMatch.AwayTeam === teamName && awayPenalties > homePenalties);
                        }
                    } else {
                        // Regular final without penalties
                        teamWonFinal = (lastMatch.HomeTeam === teamName && parseInt(lastMatch.FTHG) > parseInt(lastMatch.FTAG)) ||
                                      (lastMatch.AwayTeam === teamName && parseInt(lastMatch.FTAG) > parseInt(lastMatch.FTHG));
                    }
                    
                    stageName = teamWonFinal ? 'Champions' : 'Final';
                } else if (lastPhase.includes('Round Of 16') || lastPhase.includes('16')) {
                    stageName = 'Round Of 16';
                } else if (lastPhase.includes('Play-Off')) {
                    stageName = 'Play-Offs';
                } else if (lastPhase.includes('2. Round')) {
                    stageName = '2. Round';
                } else if (lastPhase.includes('1. Round')) {
                    stageName = '1. Round';
                }
                
                return stageName;
            } catch (error) {
                console.error('Error calculating tournament progression:', error);
                return 'Group Stage';
            }
        }
        
        function calculateAggregateScore(matches) {
            if (matches.length !== 2) return null;
            
            // Sort matches to ensure we have first leg and second leg in order
            const sortedMatches = [...matches].sort((a, b) => a.dateObj - b.dateObj);
            const firstLeg = sortedMatches[0];
            const secondLeg = sortedMatches[1];
            
            // Get team names (using alphabetical order for consistency)
            const teams = [firstLeg.HomeTeam, firstLeg.AwayTeam].sort();
            const team1 = teams[0];
            const team2 = teams[1];
            
            // Calculate total goals for each team across both legs
            let team1Goals = 0;
            let team2Goals = 0;
            
            // First leg
            if (firstLeg.HomeTeam === team1) {
                team1Goals += parseInt(firstLeg.FTHG) || 0;
                team2Goals += parseInt(firstLeg.FTAG) || 0;
            } else {
                team1Goals += parseInt(firstLeg.FTAG) || 0;
                team2Goals += parseInt(firstLeg.FTHG) || 0;
            }
            
            // Second leg
            if (secondLeg.HomeTeam === team1) {
                team1Goals += parseInt(secondLeg.FTHG) || 0;
                team2Goals += parseInt(secondLeg.FTAG) || 0;
            } else {
                team1Goals += parseInt(secondLeg.FTAG) || 0;
                team2Goals += parseInt(secondLeg.FTHG) || 0;
            }
            
            // Check for additional info (aet, pso) from either match
            let additionalInfo = '';
            let penaltyInfo = null;
            
            // Check both legs for additional info
            [firstLeg, secondLeg].forEach(match => {
                if (match.AdditionalInfo) {
                    if (match.AdditionalInfo.includes('aet')) {
                        additionalInfo = ' aet';
                    }
                    if (match.AdditionalInfo.includes('pso')) {
                        // Extract penalty shootout score from "pso 1:4" format
                        const psoMatch = match.AdditionalInfo.match(/pso (\d+):(\d+)/);
                        if (psoMatch) {
                            const homePenalties = parseInt(psoMatch[1]);
                            const awayPenalties = parseInt(psoMatch[2]);
                            penaltyInfo = {
                                homeTeam: match.HomeTeam,
                                awayTeam: match.AwayTeam,
                                homePenalties: homePenalties,
                                awayPenalties: awayPenalties
                            };
                        }
                    }
                }
            });
            
            // Determine winner and loser
            let winner, loser, winnerColor, finalScore;
            
            if (team1Goals > team2Goals) {
                // Team1 wins on aggregate
                winner = team1;
                loser = team2;
                winnerColor = getTeamColor(team1, state.selectedLeague) || '#059669';
                finalScore = `${team1Goals}-${team2Goals}${additionalInfo}`;
            } else if (team2Goals > team1Goals) {
                // Team2 wins on aggregate
                winner = team2;
                loser = team1;
                winnerColor = getTeamColor(team2, state.selectedLeague) || '#059669';
                finalScore = `${team2Goals}-${team1Goals}${additionalInfo}`;
            } else {
                // Aggregate tie - check for penalty shootout
                if (penaltyInfo) {
                    // Determine winner based on penalty shootout
                    if (penaltyInfo.homePenalties > penaltyInfo.awayPenalties) {
                        winner = penaltyInfo.homeTeam;
                        loser = penaltyInfo.awayTeam;
                        winnerColor = getTeamColor(penaltyInfo.homeTeam, state.selectedLeague) || '#059669';
                        finalScore = `${team1Goals}-${team2Goals}${additionalInfo}, (Penalty Shootout ${penaltyInfo.homePenalties}-${penaltyInfo.awayPenalties})`;
                    } else {
                        winner = penaltyInfo.awayTeam;
                        loser = penaltyInfo.homeTeam;
                        winnerColor = getTeamColor(penaltyInfo.awayTeam, state.selectedLeague) || '#059669';
                        finalScore = `${team1Goals}-${team2Goals}${additionalInfo}, (Penalty Shootout ${penaltyInfo.awayPenalties}-${penaltyInfo.homePenalties})`;
                    }
                } else {
                    // True tie with no penalty shootout (shouldn't happen in knockout)
                    return {
                        winner: 'TIE',
                        loser: `${team1} & ${team2}`,
                        totalScore: `${team1Goals}-${team2Goals}${additionalInfo}`,
                        winnerColor: '#9ca3af'
                    };
                }
            }
            
            return {
                winner: winner,
                loser: loser,
                totalScore: finalScore,
                winnerColor: winnerColor
            };
        }
        
        function createKnockoutMatchRow(match) {
            const homeTeamColor = getTeamColor(match.HomeTeam, state.selectedLeague);
            const awayTeamColor = getTeamColor(match.AwayTeam, state.selectedLeague);
            
            const homeScore = parseInt(match.FTHG) || 0;
            const awayScore = parseInt(match.FTAG) || 0;
            
            // Determine winner and apply highlighting
            let homeScoreClass = '';
            let awayScoreClass = '';
            let resultStyle = '';
            let winnerTeam = '';
            
            if (homeScore > awayScore) {
                // Home team wins
                winnerTeam = match.HomeTeam;
                homeScoreClass = 'font-bold win-score';
                awayScoreClass = 'text-red-600 font-bold';
                resultStyle = homeTeamColor ? 
                    `color: ${homeTeamColor} !important; font-weight: bold;` : 
                    'color: #059669 !important; font-weight: bold;';
            } else if (awayScore > homeScore) {
                // Away team wins
                winnerTeam = match.AwayTeam;
                homeScoreClass = 'text-red-600 font-bold';
                awayScoreClass = 'font-bold win-score';
                resultStyle = awayTeamColor ? 
                    `color: ${awayTeamColor} !important; font-weight: bold;` : 
                    'color: #059669 !important; font-weight: bold;';
            } else {
                // Draw
                winnerTeam = 'Draw';
                homeScoreClass = 'text-gray-400 font-bold draw-score';
                awayScoreClass = 'text-gray-400 font-bold draw-score';
                resultStyle = 'color: #9ca3af !important; font-weight: bold;';
            }

            // Team styling
            const homeTeamStyle = homeTeamColor ? `color: ${homeTeamColor} !important; font-weight: bold;` : 'font-weight: bold;';
            const awayTeamStyle = awayTeamColor ? `color: ${awayTeamColor} !important; font-weight: bold;` : 'font-weight: bold;';
            
            // Get team logos
            const homeLogoUrl = getTeamLogoUrl(match.HomeTeam, state.selectedLeague);
            const awayLogoUrl = getTeamLogoUrl(match.AwayTeam, state.selectedLeague);
            
            // Get winner logo for result column (if not a draw)
            const winnerLogoUrl = winnerTeam !== 'Draw' ? getTeamLogoUrl(winnerTeam, state.selectedLeague) : null;
            
            return `
                <tr class="border-b hover:bg-gray-50">
                    <td class="px-3 py-4 text-center text-sm">${match.dateObj.toLocaleDateString()}</td>
                    <td class="px-3 py-4 text-center">
                        <div class="flex items-center justify-center">
                            ${homeLogoUrl ? `<img src="${homeLogoUrl}" alt="${match.HomeTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                            <span style="${homeTeamStyle}">${match.HomeTeam}</span>
                        </div>
                    </td>
                    <td class="px-3 py-4 text-center text-lg ${homeScoreClass}" >${homeScore} - ${awayScore}</td>
                    <td class="px-3 py-4 text-center">
                        <div class="flex items-center justify-center">
                            ${awayLogoUrl ? `<img src="${awayLogoUrl}" alt="${match.AwayTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                            <span style="${awayTeamStyle}">${match.AwayTeam}</span>
                        </div>
                    </td>
                    <td class="px-3 py-4 text-center">
                        <div class="flex items-center justify-center">
                            ${winnerLogoUrl ? `<img src="${winnerLogoUrl}" alt="${winnerTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                            <span style="${resultStyle}">${winnerTeam}</span>
                        </div>
                    </td>
                </tr>
            `;
        }
        
        function displaySingleTable(tableResult) {
            // Restore the standard table structure (in case it was modified by grouped display)
            const tableContainer = elements.tableContainer;
            tableContainer.innerHTML = `
                <div class="league-table">
                    <table>
                        <thead>
                            <tr id="tableHeader">
                            </tr>
                        </thead>
                        <tbody id="tableBody">
                        </tbody>
                    </table>
                </div>
            `;
            
            // Update element references to the newly created elements
            elements.tableHeader = document.getElementById('tableHeader');
            elements.tableBody = document.getElementById('tableBody');
            
            const headers = [
                { key: 'position', label: 'Pos' },
                { key: 'team', label: 'Team' },
                { key: 'played', label: 'P' },
                { key: 'won', label: 'W' },
                { key: 'drawn', label: 'D' },
                { key: 'lost', label: 'L' },
                { key: 'goalsFor', label: 'GF' },
                { key: 'goalsAgainst', label: 'GA' },
                { key: 'goalDifference', label: 'GD' },
                { key: 'points', label: 'Pts' }
            ];
            
            elements.tableHeader.innerHTML = headers.map(header => `
                <th class="px-3 py-4 text-center font-bold text-sm cursor-pointer hover:bg-gray-600" 
                    onclick="handleSort('${header.key}')" 
                    style="text-align: ${header.key === 'team' ? 'left' : 'center'}">
                    ${header.label}${getSortIndicator(header.key)}
                </th>
            `).join('');
            
            // Update table body
            if (tableResult.tableData && tableResult.tableData.length > 0) {
                elements.tableBody.innerHTML = tableResult.tableData.map((team, index) => {
                    const isTeam1 = state.selectedTeam1 === team.team;
                    const isTeam2 = state.selectedTeam2 === team.team;
                    // Only highlight when Team 1 is selected, or when both teams are selected
                    const isHighlighted = state.selectedTeam1 && (isTeam1 || isTeam2);

                    // Determine highlight class: team1-highlight for Team 1, team2-highlight for Team 2
                    const highlightClass = isHighlighted && isTeam1 ? 'team1-highlight' : isHighlighted && isTeam2 ? 'team2-highlight' : '';

                    // Only apply team color when team is highlighted
                    let teamColorStyle = '';
                    if (isHighlighted) {
                        const teamColor = getTeamColor(team.team, state.selectedLeague);
                        teamColorStyle = teamColor ? `color: ${teamColor} !important;` : '';
                    }

                    // Alternating row colors: only if 3+ teams, otherwise all white
                    const rowBackgroundClass = tableResult.tableData.length >= 3 && index % 2 === 1 ? 'bg-gray-50' : 'bg-white';

                    return `
                        <tr class="border-b hover:bg-gray-50 ${rowBackgroundClass}">
                            <td class="px-3 py-4 text-center font-bold text-gray-600">${team.sharedPosition || team.originalPosition}</td>
                            <td class="px-4 py-4 font-semibold ${isHighlighted ? 'text-black' : 'text-gray-900'}">
                                <div class="flex items-center cursor-pointer hover:bg-gray-100 rounded p-2 -m-2 team-clickable" data-team="${team.team}" title="Click to view ${team.team} history">
                                    ${(() => {
                                        const logoUrl = getTeamLogoUrl(team.team, state.selectedLeague);
                                        return logoUrl ? `<img src="${logoUrl}" alt="${team.team} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : '';
                                    })()}
                                    <span class="hover:underline team-name-text ${highlightClass}" style="${teamColorStyle}">${team.team}</span>
                                </div>
                            </td>
                            <td class="px-3 py-4 text-center">${team.played}</td>
                            <td class="px-3 py-4 text-center">${team.won}</td>
                            <td class="px-3 py-4 text-center">${team.drawn}</td>
                            <td class="px-3 py-4 text-center">${team.lost}</td>
                            <td class="px-3 py-4 text-center">${team.goalsFor}</td>
                            <td class="px-3 py-4 text-center">${team.goalsAgainst}</td>
                            <td class="px-3 py-4 text-center">
                                <span class="font-bold ${team.goalDifference > 0 ? 'text-green-700' : team.goalDifference < 0 ? 'text-red-600' : 'text-black'}">
                                    ${team.goalDifference > 0 ? '+' : ''}${team.goalDifference}
                                </span>
                            </td>
                            <td class="px-3 py-4 text-center">
                                <span class="points-badge">
                                    ${team.points}
                                </span>
                            </td>
                        </tr>
                    `;
                }).join('');
                
                // Remove any existing event listeners to avoid duplicates
                elements.tableBody.removeEventListener('click', handleTeamClick);
                
                // Add event delegation for team clicks
                elements.tableBody.addEventListener('click', handleTeamClick);
                
                // Only show table if we're on the League Filters tab
                const isLeagueFiltersActive = document.getElementById('leagueFiltersTab').classList.contains('active');
                if (isLeagueFiltersActive) {
                    elements.tableContainer.classList.remove('hidden');
                } else {
                    elements.tableContainer.classList.add('hidden');
                }
            } else {
                elements.tableContainer.classList.add('hidden');
            }
        }

        // Phase table sorting state
        const phaseTableSortState = {};

        // Handle sorting for phase tables
        function handlePhaseSort(column, phaseName) {
            // Initialize sort state for this phase if it doesn't exist
            if (!phaseTableSortState[phaseName]) {
                phaseTableSortState[phaseName] = { column: 'points', direction: 'desc' };
            }
            
            const currentSort = phaseTableSortState[phaseName];
            
            // Toggle direction if same column, otherwise set to desc
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'desc' ? 'asc' : 'desc';
            } else {
                currentSort.column = column;
                currentSort.direction = column === 'team' ? 'asc' : 'desc';
            }
            
            // Re-calculate and display tables with new sorting
            updateTable();
        }

        // Get sort indicator for phase tables
        function getPhaseTableSortIndicator(column, phaseName) {
            if (!phaseTableSortState[phaseName] || phaseTableSortState[phaseName].column !== column) {
                return '';
            }
            return phaseTableSortState[phaseName].direction === 'asc' ? ' ‚Üë' : ' ‚Üì';
        }

        // Sort phase table data
        function sortPhaseTableData(tableData, phaseName) {
            if (!phaseTableSortState[phaseName]) {
                // Default sort by points desc
                return tableData.sort((a, b) => {
                    if (b.points !== a.points) return b.points - a.points;
                    if (b.goalDifference !== a.goalDifference) return b.goalDifference - a.goalDifference;
                    if (b.goalsFor !== a.goalsFor) return b.goalsFor - a.goalsFor;
                    return a.team.localeCompare(b.team);
                });
            }
            
            const { column, direction } = phaseTableSortState[phaseName];
            const multiplier = direction === 'asc' ? 1 : -1;
            
            return tableData.sort((a, b) => {
                let aVal = a[column];
                let bVal = b[column];
                
                // Handle string columns
                if (column === 'team') {
                    return multiplier * aVal.localeCompare(bVal);
                }
                
                // Handle numeric columns
                if (typeof aVal === 'number' && typeof bVal === 'number') {
                    return multiplier * (aVal - bVal);
                }
                
                return 0;
            });
        }

        // Calculate penalty shootout stats from matches
        function calculatePenaltyShootoutStats(matches, team1Name, team2Name) {
            let team1Wins = 0, team2Wins = 0;

            matches.forEach(match => {
                if (match.AdditionalInfo && match.AdditionalInfo.toLowerCase().includes('pso')) {
                    // Parse penalty score from AdditionalInfo like "pso 1:4" or "PSO 1:4"
                    const penaltyMatch = match.AdditionalInfo.match(/pso\s+(\d+):(\d+)/i);
                    if (penaltyMatch) {
                        const homePenalties = parseInt(penaltyMatch[1]);
                        const awayPenalties = parseInt(penaltyMatch[2]);

                        // Determine winner based on penalty score (not match score)
                        if (homePenalties > awayPenalties) {
                            // Home team won penalty shootout
                            if (match.HomeTeam === team1Name) {
                                team1Wins++;
                            } else {
                                team2Wins++;
                            }
                        } else if (awayPenalties > homePenalties) {
                            // Away team won penalty shootout
                            if (match.AwayTeam === team1Name) {
                                team1Wins++;
                            } else {
                                team2Wins++;
                            }
                        }
                    }
                }
            });

            const total = team1Wins + team2Wins;
            return {
                team1Wins,
                team2Wins,
                total
            };
        }

        // Update head-to-head display with custom team colors
        function updateHeadToHeadDisplay(h2hResult) {
            if (h2hResult && state.selectedTeam1 && state.selectedTeam2) {
                elements.h2hSection.classList.remove('hidden');
                
                // Get team colors
                const team1Color = getTeamColor(state.selectedTeam1, state.selectedLeague);
                const team2Color = getTeamColor(state.selectedTeam2, state.selectedLeague);
                
                // Default colors if no custom color found
                const team1Style = team1Color ? `background: ${team1Color} !important; color: ${getContrastColor(team1Color)} !important;` : '';
                const team2Style = team2Color ? `background: ${team2Color} !important; color: ${getContrastColor(team2Color)} !important;` : '';
                
                // Create H2H visualizations based on penalty filter or home/away filter selection
                let visualizationHTML = '';

                // Check if penalty shootouts filter is active
                if (state.h2hPenaltyFilter) {
                    // Special penalty shootout visualization - only wins/losses, no draws
                    const penaltyStats = calculatePenaltyShootoutStats(h2hResult.matches, state.selectedTeam1, state.selectedTeam2);

                    if (penaltyStats.total > 0) {
                        visualizationHTML += `
                            <div class="mb-4">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="text-sm font-semibold">${state.selectedTeam1} vs ${state.selectedTeam2} (Penalty Shootouts)</span>
                                    <span class="text-sm text-gray-600">${penaltyStats.team1Wins}W - ${penaltyStats.team2Wins}W</span>
                                </div>
                                <div class="h2h-viz-bar">
                                    <div class="h2h-segment h2h-wins" style="width: ${(penaltyStats.team1Wins / penaltyStats.total) * 100}%; ${team1Style}">
                                        ${penaltyStats.team1Wins > 0 ? penaltyStats.team1Wins : ''}
                                    </div>
                                    <div class="h2h-segment h2h-losses" style="width: ${(penaltyStats.team2Wins / penaltyStats.total) * 100}%; ${team2Style}">
                                        ${penaltyStats.team2Wins > 0 ? penaltyStats.team2Wins : ''}
                                    </div>
                                </div>
                            </div>`;
                    } else {
                        visualizationHTML += '<div class="text-sm text-gray-500 italic mb-4">No penalty shootout matches found</div>';
                    }
                } else {
                    // Regular visualization with wins/draws/losses

                    // Show overall stats only if both home and away are selected
                    if (state.homeFilter && state.awayFilter) {
                    visualizationHTML += `
                        <div class="mb-4">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-sm font-semibold">${state.selectedTeam1} vs ${state.selectedTeam2} (Overall)</span>
                                <span class="text-sm text-gray-600">${h2hResult.overallStats.team1Wins}W - ${h2hResult.overallStats.draws}D - ${h2hResult.overallStats.team2Wins}W</span>
                            </div>
                            <div class="h2h-viz-bar">
                                <div class="h2h-segment h2h-wins" style="width: ${(h2hResult.overallStats.team1Wins / h2hResult.overallStats.total) * 100}%; ${team1Style}">
                                    ${h2hResult.overallStats.team1Wins > 0 ? h2hResult.overallStats.team1Wins : ''}
                                </div>
                                <div class="h2h-segment h2h-draws" style="width: ${(h2hResult.overallStats.draws / h2hResult.overallStats.total) * 100}%">
                                    ${h2hResult.overallStats.draws > 0 ? h2hResult.overallStats.draws : ''}
                                </div>
                                <div class="h2h-segment h2h-losses" style="width: ${(h2hResult.overallStats.team2Wins / h2hResult.overallStats.total) * 100}%; ${team2Style}">
                                    ${h2hResult.overallStats.team2Wins > 0 ? h2hResult.overallStats.team2Wins : ''}
                                </div>
                            </div>
                        </div>`;
                }
                
                // Show Team1 Home scenario if home is selected (when HOME button is checked, show Team1 home matches)
                if (state.homeFilter) {
                    visualizationHTML += `
                        <div class="mb-4">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-sm font-semibold">${state.selectedTeam1} (Home) vs ${state.selectedTeam2} (Away)</span>
                                <span class="text-sm text-gray-600">${h2hResult.team1HomeStats.wins}W - ${h2hResult.team1HomeStats.draws}D - ${h2hResult.team1HomeStats.losses}W</span>
                            </div>
                            ${h2hResult.team1HomeStats.total > 0 ? `
                            <div class="h2h-viz-bar">
                                <div class="h2h-segment h2h-wins" style="width: ${(h2hResult.team1HomeStats.wins / h2hResult.team1HomeStats.total) * 100}%; ${team1Style}">
                                    ${h2hResult.team1HomeStats.wins > 0 ? h2hResult.team1HomeStats.wins : ''}
                                </div>
                                <div class="h2h-segment h2h-draws" style="width: ${(h2hResult.team1HomeStats.draws / h2hResult.team1HomeStats.total) * 100}%">
                                    ${h2hResult.team1HomeStats.draws > 0 ? h2hResult.team1HomeStats.draws : ''}
                                </div>
                                <div class="h2h-segment h2h-losses" style="width: ${(h2hResult.team1HomeStats.losses / h2hResult.team1HomeStats.total) * 100}%; ${team2Style}">
                                    ${h2hResult.team1HomeStats.losses > 0 ? h2hResult.team1HomeStats.losses : ''}
                                </div>
                            </div>
                            ` : '<div class="text-sm text-gray-500 italic">No matches found</div>'}
                        </div>`;
                }
                
                // Show Team2 Home scenario if away is selected (when AWAY button is checked, show Team2 home matches)
                if (state.awayFilter) {
                    visualizationHTML += `
                        <div class="mb-4">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-sm font-semibold">${state.selectedTeam2} (Home) vs ${state.selectedTeam1} (Away)</span>
                                <span class="text-sm text-gray-600">${h2hResult.team2HomeStats.wins}W - ${h2hResult.team2HomeStats.draws}D - ${h2hResult.team2HomeStats.losses}W</span>
                            </div>
                            ${h2hResult.team2HomeStats.total > 0 ? `
                            <div class="h2h-viz-bar">
                                <div class="h2h-segment h2h-wins" style="width: ${(h2hResult.team2HomeStats.wins / h2hResult.team2HomeStats.total) * 100}%; ${team2Style}">
                                    ${h2hResult.team2HomeStats.wins > 0 ? h2hResult.team2HomeStats.wins : ''}
                                </div>
                                <div class="h2h-segment h2h-draws" style="width: ${(h2hResult.team2HomeStats.draws / h2hResult.team2HomeStats.total) * 100}%">
                                    ${h2hResult.team2HomeStats.draws > 0 ? h2hResult.team2HomeStats.draws : ''}
                                </div>
                                <div class="h2h-segment h2h-losses" style="width: ${(h2hResult.team2HomeStats.losses / h2hResult.team2HomeStats.total) * 100}%; ${team1Style}">
                                    ${h2hResult.team2HomeStats.losses > 0 ? h2hResult.team2HomeStats.losses : ''}
                                </div>
                            </div>
                            ` : '<div class="text-sm text-gray-500 italic">No matches found</div>'}
                        </div>`;
                }
                } // End of else block for regular visualization

                elements.h2hVisualizations.innerHTML = visualizationHTML;
                
                // Update H2H matches table based on filter state
                updateH2HMatchesTable(h2hResult);
            } else {
                elements.matchHistorySection.classList.add('hidden');
                elements.h2hSection.classList.add('hidden');
                elements.h2hMatchesTable.classList.add('hidden');
            }
        }

        // Update H2H matches table
        function updateH2HMatchesTable(h2hResult) {
            console.log('updateH2HMatchesTable - Received matches:', h2hResult?.matches?.length);
            console.log('updateH2HMatchesTable - Sample matches:', h2hResult?.matches?.slice(0, 3).map(m => `${m.HomeTeam} vs ${m.AwayTeam}`));

            if (!h2hResult || !h2hResult.matches || h2hResult.matches.length === 0) {
                elements.h2hMatchesTable.classList.add('hidden');
                return;
            }

            // Hide the Match History table if both home and away filters are unchecked
            if (!state.homeFilter && !state.awayFilter) {
                elements.h2hMatchesTable.classList.add('hidden');
                return;
            }

            // Apply penalty shootouts filter if active
            let filteredMatches = h2hResult.matches;
            if (state.h2hPenaltyFilter) {
                filteredMatches = h2hResult.matches.filter(match =>
                    match.AdditionalInfo &&
                    match.AdditionalInfo.toLowerCase().includes('pso')
                );

                // If no penalty matches found, hide the table
                if (filteredMatches.length === 0) {
                    elements.h2hMatchesTable.classList.add('hidden');
                    return;
                }
            }

            elements.h2hMatchesTable.classList.remove('hidden');
            
            // Update table title to show stage filter and match count
            let titleText = `${state.selectedTeam1} vs ${state.selectedTeam2}`;
            if (state.h2hStage !== '') {
                titleText += ` - ${state.h2hStage}`;
            }
            if (state.h2hPenaltyFilter) {
                titleText += ' - Penalty Shootouts Only';
            }
            titleText += ` (${filteredMatches.length} matches)`;
            elements.h2hTableTitle.textContent = titleText;

            // Create sorted matches data
            let matchesData = filteredMatches.map(match => {
                const homeScore = parseInt(match.FTHG) || 0;
                const awayScore = parseInt(match.FTAG) || 0;
                
                // Get team colors first
                const homeTeamColor = getTeamColor(match.HomeTeam, state.selectedLeague);
                const awayTeamColor = getTeamColor(match.AwayTeam, state.selectedLeague);
                
                // Determine winner and score colors
                let winnerTeam = '';
                let homeScoreClass = '';
                let awayScoreClass = '';
                let resultStyle = '';
                
                if (homeScore > awayScore) {
                    // Home team wins
                    winnerTeam = match.HomeTeam;
                    homeScoreClass = 'font-bold win-score';
                    awayScoreClass = 'text-red-600 font-bold';
                    resultStyle = homeTeamColor ? 
                        `color: ${homeTeamColor} !important; font-weight: bold;` : 
                        'color: #059669 !important; font-weight: bold;'; // Default green
                } else if (awayScore > homeScore) {
                    // Away team wins
                    winnerTeam = match.AwayTeam;
                    homeScoreClass = 'text-red-600 font-bold';
                    awayScoreClass = 'font-bold win-score';
                    resultStyle = awayTeamColor ? 
                        `color: ${awayTeamColor} !important; font-weight: bold;` : 
                        'color: #059669 !important; font-weight: bold;'; // Default green
                } else {
                    // Draw
                    winnerTeam = 'Draw';
                    homeScoreClass = 'text-gray-400 font-bold draw-score';
                    awayScoreClass = 'text-gray-400 font-bold draw-score';
                    resultStyle = 'color: #9ca3af !important; font-weight: bold;'; // Lighter gray for draws
                }

                // Add team highlights - blue for Team 1, green for Team 2 (subtle like points badge)
                const isHomeTeam1 = match.HomeTeam === state.selectedTeam1;
                const isHomeTeam2 = match.HomeTeam === state.selectedTeam2;
                const isAwayTeam1 = match.AwayTeam === state.selectedTeam1;
                const isAwayTeam2 = match.AwayTeam === state.selectedTeam2;
                
                // Create subtle highlight classes similar to points-badge
                const homeTeamClass = isHomeTeam1 ? 'team1-highlight' : 
                                    isHomeTeam2 ? 'team2-highlight' : '';
                const awayTeamClass = isAwayTeam1 ? 'team1-highlight' : 
                                    isAwayTeam2 ? 'team2-highlight' : '';
                
                // Combine team color with highlight classes for inline styles  
                const homeTeamFinalStyle = homeTeamColor ? `color: ${homeTeamColor} !important; font-weight: bold;` : 'font-weight: bold;';
                const awayTeamFinalStyle = awayTeamColor ? `color: ${awayTeamColor} !important; font-weight: bold;` : 'font-weight: bold;';
                
                // Update result style to include subtle highlight for winner (but not for draws)
                let finalResultStyle = resultStyle;
                let resultClass = '';
                if (winnerTeam !== 'Draw') {
                    if (winnerTeam === state.selectedTeam1) {
                        resultClass = 'team1-highlight';
                    } else if (winnerTeam === state.selectedTeam2) {
                        resultClass = 'team2-highlight';
                    }
                }

                // Check if this is a penalty shootout match and create penalty info
                let penaltyInfo = '';
                if (match.AdditionalInfo && match.AdditionalInfo.toLowerCase().includes('pso')) {
                    const penaltyMatch = match.AdditionalInfo.match(/pso\s+(\d+):(\d+)/);
                    if (penaltyMatch) {
                        const penaltyHomeScore = penaltyMatch[1];
                        const penaltyAwayScore = penaltyMatch[2];
                        const penaltyWinner = parseInt(penaltyHomeScore) > parseInt(penaltyAwayScore) ? match.HomeTeam : match.AwayTeam;
                        const penaltyLoser = penaltyWinner === match.HomeTeam ? match.AwayTeam : match.HomeTeam;

                        penaltyInfo = `${penaltyWinner} def. ${penaltyLoser} (Penalty Shootout ${penaltyHomeScore}-${penaltyAwayScore})`;
                    }
                }

                return {
                    date: match.dateObj.toLocaleDateString(),
                    dateSort: match.dateObj,
                    stage: match.CompetitionPhase || '',
                    homeTeam: match.HomeTeam,
                    homeTeamColor: homeTeamColor,
                    homeTeamStyle: homeTeamFinalStyle,
                    homeTeamClass: homeTeamClass,
                    homeScore: homeScore,
                    homeScoreClass: homeScoreClass,
                    awayTeam: match.AwayTeam,
                    awayTeamColor: awayTeamColor,
                    awayTeamStyle: awayTeamFinalStyle,
                    awayTeamClass: awayTeamClass,
                    awayScore: awayScore,
                    awayScoreClass: awayScoreClass,
                    result: winnerTeam,
                    resultStyle: finalResultStyle,
                    resultClass: resultClass,
                    penaltyInfo: penaltyInfo
                };
            });

            // Note: Filtering and recent match count limiting is now done in calculateHeadToHead()
            // The matches passed here are already filtered and limited

            // Sort by current sort config
            if (state.h2hSortConfig.key) {
                matchesData.sort((a, b) => {
                    const key = state.h2hSortConfig.key;
                    let aVal = key === 'date' ? a.dateSort : a[key];
                    let bVal = key === 'date' ? b.dateSort : b[key];

                    if (key === 'homeScore' || key === 'awayScore') {
                        aVal = parseInt(aVal) || 0;
                        bVal = parseInt(bVal) || 0;
                    } else if (key === 'homeTeam' || key === 'awayTeam' || key === 'result' || key === 'stage') {
                        aVal = (aVal || '').toLowerCase();
                        bVal = (bVal || '').toLowerCase();
                    }

                    if (state.h2hSortConfig.direction === 'asc') {
                        return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                    } else {
                        return aVal < bVal ? 1 : aVal > bVal ? -1 : 0;
                    }
                });
            }

            // Update match count display with filtered count
            elements.h2hMatchCount.textContent = `(${matchesData.length} matches)`;

            // Create table headers
            const headers = [
                { key: 'date', label: 'Date' },
                { key: 'stage', label: 'Competition Stage' },
                { key: 'homeTeam', label: 'Home Team' },
                { key: 'homeScore', label: 'Home Score' },
                { key: 'awayTeam', label: 'Away Team' },
                { key: 'awayScore', label: 'Away Score' },
                { key: 'result', label: 'Result' }
            ];

            elements.h2hTableHeader.innerHTML = headers.map(header => `
                <th class="${header.key.includes('Team') ? 'text-center' : 'text-center'} cursor-pointer" 
                    onclick="handleH2hSort('${header.key}')">
                    ${header.label}${getH2hSortIndicator(header.key)}
                </th>
            `).join('');

            // Update table body
            const tableHTML = matchesData.map((match, index) => {
                const isTeam1Home = match.homeTeam === state.selectedTeam1;
                const isTeam1Away = match.awayTeam === state.selectedTeam1;
                
                // Get team logos
                const homeLogoUrl = getTeamLogoUrl(match.homeTeam, state.selectedLeague);
                const awayLogoUrl = getTeamLogoUrl(match.awayTeam, state.selectedLeague);
                
                // Get winner logo for result column (if not a draw)
                const winnerLogoUrl = match.result !== 'Draw' ? getTeamLogoUrl(match.result, state.selectedLeague) : null;
                
                let rowHTML = `
                    <tr class="">
                        <td class="text-center text-sm">${match.date}</td>
                        <td class="text-center text-sm">${match.stage || ''}</td>
                        <td class="text-center">
                            <div class="flex items-center justify-center">
                                ${homeLogoUrl ? `<img src="${homeLogoUrl}" alt="${match.homeTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                <span class="${match.homeTeamClass}" style="${match.homeTeamStyle}">${match.homeTeam}</span>
                            </div>
                        </td>
                        <td class="text-center text-lg ${match.homeScoreClass}" >${match.homeScore}</td>
                        <td class="text-center">
                            <div class="flex items-center justify-center">
                                ${awayLogoUrl ? `<img src="${awayLogoUrl}" alt="${match.awayTeam} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                <span class="${match.awayTeamClass}" style="${match.awayTeamStyle}">${match.awayTeam}</span>
                            </div>
                        </td>
                        <td class="text-center text-lg ${match.awayScoreClass}" >${match.awayScore}</td>
                        <td class="text-center">
                            <div class="flex items-center justify-center">
                                ${winnerLogoUrl ? `<img src="${winnerLogoUrl}" alt="${match.result} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                <span class="${match.resultClass}" style="${match.resultStyle}">${match.result}</span>
                            </div>
                        </td>
                    </tr>
                `;

                // Add penalty shootout info row if this is a penalty match
                if (match.penaltyInfo) {
                    rowHTML += `
                        <tr class="border-b bg-gray-50">
                            <td colspan="7" class="text-center py-2 font-semibold text-gray-700 text-sm">
                                ${match.penaltyInfo}
                            </td>
                        </tr>
                    `;
                }

                return rowHTML;
            }).join('');
            
            elements.h2hTableBody.innerHTML = tableHTML;
        }

        // Handle H2H table sorting (tri-click: none -> asc -> desc -> none)
        function handleH2hSort(key) {
            let defaultDirection = 'desc';
            if (key === 'homeTeam' || key === 'awayTeam' || key === 'result' || key === 'stage') {
                defaultDirection = 'asc';
            }
            
            if (state.h2hSortConfig.key === key) {
                // Cycle through: current -> opposite -> none
                if (state.h2hSortConfig.direction === 'desc') {
                    state.h2hSortConfig.direction = 'asc';
                } else if (state.h2hSortConfig.direction === 'asc') {
                    // Reset to no sorting
                    state.h2hSortConfig.key = null;
                    state.h2hSortConfig.direction = null;
                } else {
                    // This shouldn't happen, but fallback
                    state.h2hSortConfig.direction = defaultDirection;
                }
            } else {
                // New column selected
                state.h2hSortConfig.key = key;
                state.h2hSortConfig.direction = defaultDirection;
            }
            
            updateTable();
        }

        // Get H2H sort indicator
        function getH2hSortIndicator(key) {
            if (state.h2hSortConfig.key !== key) return ' ‚ÜïÔ∏è';
            return state.h2hSortConfig.direction === 'asc' ? ' ‚Üë' : ' ‚Üì';
        }

        function getMatchHistorySortIndicator(key) {
            if (state.matchHistorySortConfig.key !== key) return ' ‚ÜïÔ∏è';
            return state.matchHistorySortConfig.direction === 'asc' ? ' ‚Üë' : ' ‚Üì';
        }

        // Update last data update based on most recent game
        function updateLastDataUpdate() {
            if (!state.data || state.data.length === 0) {
                elements.lastDataUpdate.textContent = 'Last Data Update: No data available';
                return;
            }

            // Find the most recent game date
            let mostRecentDate = null;

            state.data.forEach(match => {
                if (match.dateObj && match.dateObj instanceof Date && !isNaN(match.dateObj)) {
                    if (!mostRecentDate || match.dateObj > mostRecentDate) {
                        mostRecentDate = match.dateObj;
                    }
                }
            });

            if (mostRecentDate) {
                // Format the date as "Month Day, Year"
                const options = { year: 'numeric', month: 'long', day: 'numeric' };
                const formattedDate = mostRecentDate.toLocaleDateString('en-US', options);
                elements.lastDataUpdate.textContent = `Last Data Update: ${formattedDate}`;
            } else {
                elements.lastDataUpdate.textContent = 'Last Data Update: Unknown';
            }
        }

        // Update table info display
        function updateTableInfo(tableResult) {
            if (state.data.length > 0) {
                const leagueNames = {
                    'champions-league': 'üá™üá∫ Champions League',
                    // 'europa-league': 'üá™üá∫ Europa League',
                    // 'conference-league': 'üá™üá∫ Conference League'
                };
                
                let text = leagueNames[state.selectedLeague];
                
                // Don't show "All Results" text for 2023-24 season
                const hide2023Results = state.selectedSeason === '2023-24';
                
                if (state.homeFilter && state.awayFilter && !hide2023Results) text += ' - All Results';
                else if (state.homeFilter) text += ' - Home Results Only';
                else if (state.awayFilter) text += ' - Away Results Only';
                else text += ' - No Results Selected';
                
                // Handle grouped competition phase display
                if (tableResult.isGroupedByPhase) {
                    text += ` (${tableResult.totalMatchCount} total matches) ‚Ä¢ ${tableResult.phaseNames.length} competition phases`;
                    if (state.selectedSeason) {
                        text += ` ‚Ä¢ ${state.selectedSeason} season`;
                    }
                } else {
                    const teamCount = tableResult.tableData ? tableResult.tableData.length : 0;
                    text += ` (${tableResult.matchCount} matches) ‚Ä¢ ${teamCount} teams`;
                }
                
                // Add competition stage filter info
                if (state.competitionStage) {
                    if (state.competitionStage === 'group-stage') {
                        text += ` ‚Ä¢ League/Group Stage only`;
                    } else if (state.competitionStage === 'knockout-stage') {
                        text += ` ‚Ä¢ Knock-Out Stage only`;
                    } else {
                        // Show the specific stage name
                        text += ` ‚Ä¢ ${state.competitionStage} only`;
                    }
                }
                
                elements.tableInfoText.textContent = text;
                
                // Only show table info if we're on the League Filters tab
                const isLeagueFiltersActive = document.getElementById('leagueFiltersTab').classList.contains('active');
                if (isLeagueFiltersActive) {
                    elements.tableInfo.classList.remove('hidden');
                } else {
                    elements.tableInfo.classList.add('hidden');
                }
            } else {
                elements.tableInfo.classList.add('hidden');
            }
        }

        // Get historical point system based on season and league
        function getHistoricalPointSystem(season, league) {
            // Champions League historical point system
            if (league === 'champions-league') {
                // Extract the starting year from season (e.g., "1994-95" -> 1994)
                const startYear = parseInt(season.split('-')[0]);
                
                // 1994-95 and earlier seasons use 2 points for a win
                if (startYear <= 1994) {
                    return 2;
                }
                // 1995-96 and later seasons use 3 points for a win
                return 3;
            }
            
            // All other European competitions use 3 points for a win (all eras)
            return 3;
        }

        // Handle team click events
        function handleTeamClick(event) {
            // Team click event triggered
            const teamClickable = event.target.closest('.team-clickable');
            // Found team clickable element
            if (teamClickable) {
                event.preventDefault();
                event.stopPropagation();
                const teamName = teamClickable.getAttribute('data-team');
                // Team name found
                if (teamName) {
                    // Calling showTeamHistory
                    showTeamHistory(teamName);
                } else {
                    // No team name found in data-team attribute
                }
            } else {
                // No team-clickable element found
            }
        }

        // Go back to League Tables with restored state
        function goBackToLeagueTables() {
            if (!state.previousLeagueTablesState) return;

            const savedState = state.previousLeagueTablesState;

            // Restore all League Tables state
            state.selectedLeague = savedState.selectedLeague;
            state.selectedTeam1 = savedState.selectedTeam1;
            state.selectedTeam2 = savedState.selectedTeam2;
            state.selectedSeason = savedState.selectedSeason;
            state.competitionStage = savedState.competitionStage;
            state.dateFrom = savedState.dateFrom;
            state.dateTo = savedState.dateTo;
            state.selectedDayOfWeek = savedState.selectedDayOfWeek;
            state.homeFilter = savedState.homeFilter;
            state.awayFilter = savedState.awayFilter;
            state.pointDeductionsEnabled = savedState.pointDeductionsEnabled;
            state.threePointSystem = savedState.threePointSystem;
            state.excludeQualifiers = savedState.excludeQualifiers;
            state.excludeMainStage = savedState.excludeMainStage;
            state.recentH2HCount = savedState.recentH2HCount;
            state.h2hStage = savedState.h2hStage;

            // Restore UI elements
            elements.team1Select.value = savedState.selectedTeam1;
            elements.team2Select.value = savedState.selectedTeam2;

            // Update comboboxes if they exist
            if (team1Combobox) {
                const team1Text = savedState.selectedTeam1 || 'All Teams';
                team1Combobox.setValue(savedState.selectedTeam1, team1Text);
            }
            if (team2Combobox) {
                const team2Text = savedState.selectedTeam2 || 'No Team';
                team2Combobox.setValue(savedState.selectedTeam2, team2Text);
            }
            if (teamSeasonsCombobox) {
                const teamSeasonsText = savedState.teamSeasonsSelectedTeam || 'Choose a team...';
                teamSeasonsCombobox.setValue(savedState.teamSeasonsSelectedTeam, teamSeasonsText);
            }
            if (lastTimeTeam1Combobox) {
                lastTimeTeam1Combobox.setValue('', 'Select Team 1');
            }
            if (lastTimeTeam2Combobox) {
                lastTimeTeam2Combobox.setValue('', 'Select Team 2');
            }
            if (teamStreaksTeam1Combobox) {
                teamStreaksTeam1Combobox.setValue('', 'Select Team 1');
            }
            if (teamStreaksTeam2Combobox) {
                teamStreaksTeam2Combobox.setValue('', 'Select Team 2');
            }
            elements.seasonSelect.value = savedState.selectedSeason;
            elements.competitionStageSelect.value = savedState.competitionStage;
            elements.dayOfWeekSelect.value = savedState.selectedDayOfWeek;
            elements.recentH2HSelect.value = savedState.recentH2HCount;
            elements.h2hStageSelect.value = savedState.h2hStage;

            // Restore checkboxes
            elements.homeCheckbox.className = `checkbox ${savedState.homeFilter ? 'checked' : ''}`;
            elements.awayCheckbox.className = `checkbox ${savedState.awayFilter ? 'checked' : ''}`;
            elements.deductionsCheckbox.className = `checkbox ${savedState.pointDeductionsEnabled ? 'checked' : ''}`;
            elements.threePointCheckbox.className = `checkbox ${savedState.threePointSystem ? 'checked' : ''}`;
            elements.excludeQualifiersCheckbox.className = `checkbox ${savedState.excludeQualifiers ? 'checked' : ''}`;
            elements.excludeMainStageCheckbox.className = `checkbox ${savedState.excludeMainStage ? 'checked' : ''}`;

            // Switch back to League Tables tab
            switchTab('league-filters');

            // Clear the saved state
            state.previousLeagueTablesState = null;
        }

        // Show team history across seasons
        function showTeamHistory(teamName, sourceLeague = null) {
            // showTeamHistory called
            // Current state.data length

            // Determine which league to use based on source
            let leagueToUse;
            if (sourceLeague) {
                // Called from Team Seasons dropdown - use the specified league
                leagueToUse = sourceLeague;
                state.teamSeasonsSelectedLeague = sourceLeague;
                // Hide back arrow when navigating from within Team Seasons
                elements.teamHistoryBackArrow.classList.add('hidden');
            } else {
                // Called from League Filters clicking - save current state and show back arrow
                leagueToUse = state.selectedLeague;
                state.teamSeasonsSelectedLeague = state.selectedLeague;

                // Save current League Tables state for back navigation
                state.previousLeagueTablesState = {
                    selectedLeague: state.selectedLeague,
                    selectedTeam1: state.selectedTeam1,
                    selectedTeam2: state.selectedTeam2,
                    selectedSeason: state.selectedSeason,
                    competitionStage: state.competitionStage,
                    dateFrom: state.dateFrom,
                    dateTo: state.dateTo,
                    selectedDayOfWeek: state.selectedDayOfWeek,
                    homeFilter: state.homeFilter,
                    awayFilter: state.awayFilter,
                    pointDeductionsEnabled: state.pointDeductionsEnabled,
                    threePointSystem: state.threePointSystem,
                    excludeQualifiers: state.excludeQualifiers,
                    excludeMainStage: state.excludeMainStage,
                    recentH2HCount: state.recentH2HCount,
                    h2hStage: state.h2hStage
                };

                // Show back arrow when navigating from League Tables
                elements.teamHistoryBackArrow.classList.remove('hidden');
            }

            state.teamSeasonsSelectedTeam = teamName;
            // Using league
            
            const leagueMapping = {
                'champions-league': 'C1',
                'europa-league': 'E1',
                'conference-league': 'C2'
            };
            
            const divCode = leagueMapping[leagueToUse];
            if (!divCode) return;
            
            // Get all available seasons for this league
            const availableSeasons = getAvailableSeasons(leagueToUse);
            // Available seasons found
            const teamHistoryData = [];
            
            // Filter seasons based on Team Seasons selection (if any)
            let seasonsToProcess = availableSeasons;
            if (sourceLeague && state.teamSeasonsSelectedSeason) {
                // For era seasons, filter individual seasons to only those within the era date range
                if (state.teamSeasonsSelectedSeason.includes('all-') || state.teamSeasonsSelectedSeason.includes('-era-') || state.teamSeasonsSelectedSeason.includes('french-division-1')) {
                    const originalSelectedLeague = state.selectedLeague;
                    state.selectedLeague = leagueToUse;
                    const eraSeasonDates = getSeasonDateRange(state.teamSeasonsSelectedSeason);
                    state.selectedLeague = originalSelectedLeague;
                    
                    if (eraSeasonDates) {
                        const eraStart = new Date(eraSeasonDates.start);
                        const eraEnd = new Date(eraSeasonDates.end);
                        
                        // Filter individual seasons to only those that fall within the era
                        seasonsToProcess = availableSeasons.filter(season => {
                            // Skip era seasons themselves in this filtering
                            if (season.includes('all-') || season.includes('-era-') || season.includes('french-division-1')) {
                                return false;
                            }
                            
                            const originalSelectedLeague2 = state.selectedLeague;
                            state.selectedLeague = leagueToUse;
                            const seasonDates = getSeasonDateRange(season);
                            state.selectedLeague = originalSelectedLeague2;
                            
                            if (!seasonDates) return false;
                            
                            const seasonStart = new Date(seasonDates.start);
                            const seasonEnd = new Date(seasonDates.end);
                            
                            // Include season if it starts on or after era start and ends before or on era end
                            return seasonStart >= eraStart && seasonEnd <= eraEnd;
                        });
                    }
                } else {
                    // For individual seasons (shouldn't happen in Team Seasons but keeping for safety)
                    seasonsToProcess = [state.teamSeasonsSelectedSeason];
                }
            }

            // Check each season for the team's data
            seasonsToProcess.forEach(seasonFilter => {
                // Skip special seasons like "all" seasons, era seasons, and french division 1
                if (seasonFilter.includes('all-') || seasonFilter.includes('-era-') || seasonFilter.includes('french-division-1')) {
                    return;
                }
                
                // Processing season for team
                
                // Get season date range
                const originalSelectedLeague = state.selectedLeague;
                state.selectedLeague = leagueToUse; // Temporarily set for date range lookup
                const seasonDates = getSeasonDateRange(seasonFilter);
                state.selectedLeague = originalSelectedLeague; // Restore original
                if (!seasonDates) {
                    // No season dates found
                    return;
                }
                // Season dates found
                
                // Filter data for this season - use date-only comparisons
                const seasonStart = new Date(seasonDates.start);
                seasonStart.setUTCHours(0, 0, 0, 0); // Start of day UTC
                const seasonEnd = new Date(seasonDates.end);
                seasonEnd.setUTCHours(23, 59, 59, 999); // End of day UTC
                
                // Extract the year from the season (e.g., "2019-20" -> 2019, "2020-21" -> 2020)
                const seasonYear = parseInt(seasonFilter.split('-')[0]);
                
                // Get ALL games for this season (not just for the selected team)
                let allSeasonData = state.data.filter(row => {
                    if (row.Div !== divCode) return false;
                    
                    const matchDate = new Date(row.dateObj);
                    const gameYear = matchDate.getFullYear();
                    
                    // Pre-filter: only consider games from years that could belong to this season
                    // For season "2019-20", only look at games from 2019 and 2020
                    if (gameYear < seasonYear || gameYear > seasonYear + 1) return false;
                    
                    const inRange = matchDate >= seasonStart && matchDate <= seasonEnd;
                    
                    
                    return inRange;
                });
                
                // Apply qualifier exclusion filter if enabled
                if (state.excludeQualifiers) {
                    allSeasonData = allSeasonData.filter(row => !row.isQualifier);
                }
                
                // Apply main stage exclusion filter if enabled
                if (state.excludeMainStage) {
                    allSeasonData = allSeasonData.filter(row => row.isQualifier);
                }
                
                // Get games specifically for this team
                const teamMatches = allSeasonData.filter(row => 
                    row.HomeTeam === teamName || row.AwayTeam === teamName
                );
                
                if (teamMatches.length === 0) return; // Team not present in this season
                
                // Calculate team stats for this season
                let played = 0, won = 0, drawn = 0, lost = 0;
                let goalsFor = 0, goalsAgainst = 0;
                
                teamMatches.forEach(match => {
                    played++;
                    const homeGoals = parseInt(match.FTHG) || 0;
                    const awayGoals = parseInt(match.FTAG) || 0;
                    
                    
                    if (match.HomeTeam === teamName) {
                        goalsFor += homeGoals;
                        goalsAgainst += awayGoals;
                        if (homeGoals > awayGoals) won++;
                        else if (homeGoals === awayGoals) drawn++;
                        else lost++;
                    } else {
                        goalsFor += awayGoals;
                        goalsAgainst += homeGoals;
                        if (awayGoals > homeGoals) won++;
                        else if (awayGoals === homeGoals) drawn++;
                        else lost++;
                    }
                });
                
                const goalDifference = goalsFor - goalsAgainst;
                const winPoints = getHistoricalPointSystem(seasonFilter, leagueToUse);
                let points = won * winPoints + drawn;
                
                // Apply point deductions for this season
                if (seasonDates) {
                    const seasonStart = new Date(seasonDates.start);
                    const seasonEnd = new Date(seasonDates.end);
                    
                    pointDeductions.forEach(deduction => {
                        if (deduction.team === teamName && deduction.league === divCode) {
                            const deductionStart = new Date(deduction.startDate);
                            const deductionEnd = new Date(deduction.endDate);
                            
                            const hasOverlap = (seasonStart <= deductionEnd) && (seasonEnd >= deductionStart);
                            
                            if (hasOverlap && state.pointDeductionsEnabled) {
                                points -= deduction.points;
                            }
                        }
                    });
                }
                
                // Calculate position by building full league table for this season
                const leagueTeams = {};
                allSeasonData.forEach(match => {
                    [match.HomeTeam, match.AwayTeam].forEach(team => {
                        if (!leagueTeams[team]) {
                            leagueTeams[team] = { played: 0, won: 0, drawn: 0, lost: 0, goalsFor: 0, goalsAgainst: 0 };
                        }
                    });
                });
                
                // Calculate stats for all teams
                allSeasonData.forEach(match => {
                    const homeGoals = parseInt(match.FTHG) || 0;
                    const awayGoals = parseInt(match.FTAG) || 0;
                    
                    leagueTeams[match.HomeTeam].played++;
                    leagueTeams[match.AwayTeam].played++;
                    
                    leagueTeams[match.HomeTeam].goalsFor += homeGoals;
                    leagueTeams[match.HomeTeam].goalsAgainst += awayGoals;
                    leagueTeams[match.AwayTeam].goalsFor += awayGoals;
                    leagueTeams[match.AwayTeam].goalsAgainst += homeGoals;
                    
                    if (homeGoals > awayGoals) {
                        leagueTeams[match.HomeTeam].won++;
                        leagueTeams[match.AwayTeam].lost++;
                    } else if (homeGoals === awayGoals) {
                        leagueTeams[match.HomeTeam].drawn++;
                        leagueTeams[match.AwayTeam].drawn++;
                    } else {
                        leagueTeams[match.HomeTeam].lost++;
                        leagueTeams[match.AwayTeam].won++;
                    }
                });
                
                // Convert to array and calculate points
                const winPointsForSeason = getHistoricalPointSystem(seasonFilter, leagueToUse);
                const seasonTable = Object.keys(leagueTeams).map(team => {
                    const stats = leagueTeams[team];
                    let teamPoints = stats.won * winPointsForSeason + stats.drawn;
                    
                    // Apply point deductions for each team
                    if (seasonDates) {
                        const seasonStart = new Date(seasonDates.start);
                        const seasonEnd = new Date(seasonDates.end);
                        
                        pointDeductions.forEach(deduction => {
                            if (deduction.team === team && deduction.league === divCode) {
                                const deductionStart = new Date(deduction.startDate);
                                const deductionEnd = new Date(deduction.endDate);
                                
                                const hasOverlap = (seasonStart <= deductionEnd) && (seasonEnd >= deductionStart);
                                
                                if (hasOverlap && state.pointDeductionsEnabled) {
                                    teamPoints -= deduction.points;
                                }
                            }
                        });
                    }
                    
                    return {
                        team,
                        ...stats,
                        goalDifference: stats.goalsFor - stats.goalsAgainst,
                        points: teamPoints
                    };
                });
                
                // Sort by points, then goal difference, then goals for
                seasonTable.sort((a, b) => {
                    if (b.points !== a.points) return b.points - a.points;
                    if (b.goalDifference !== a.goalDifference) return b.goalDifference - a.goalDifference;
                    return b.goalsFor - a.goalsFor;
                });
                
                // Apply ranking overrides for this season
                const overriddenTable = applyRankingOverrides(seasonTable, leagueToUse, seasonFilter);
                
                // Note: Don't re-sort after overrides as it would undo the override positioning
                
                // Find team position (check for override position first)
                let position;
                const teamInTable = overriddenTable.find(team => team.team === teamName);
                if (teamInTable && teamInTable.sharedPosition) {
                    position = teamInTable.sharedPosition;
                } else {
                    position = overriddenTable.findIndex(team => team.team === teamName) + 1;
                }
                
                // Calculate tournament progression for this season
                const tournamentProgression = calculateTournamentProgression(teamName, teamMatches);
                
                teamHistoryData.push({
                    season: seasonFilter,
                    position,
                    played,
                    won,
                    drawn,
                    lost,
                    goalsFor,
                    goalsAgainst,
                    goalDifference,
                    points,
                    tournamentProgression
                });
            });
            
            // Sort by season (most recent first)
            teamHistoryData.sort((a, b) => {
                // Extract year from season string (e.g., "2023-24" -> 2023)
                const yearA = parseInt(a.season.split('-')[0]);
                const yearB = parseInt(b.season.split('-')[0]);
                return yearB - yearA;
            });
            
            // Team history data found
            // Sample data processed
            
            displayTeamHistory(teamName, teamHistoryData, leagueToUse);
        }

        // Define progression hierarchy (better = lower index)
        function getProgressionRank(progression) {
            const progressionHierarchy = [
                'Champions',
                'Final', 
                'Semi-Finals',
                'Quarter-Finals',
                'Round Of 16',
                'Play-Offs',
                '2. Round',
                '1. Round'
            ];
            
            const rank = progressionHierarchy.indexOf(progression);
            return rank === -1 ? 999 : rank; // Unknown progressions ranked lowest
        }
        
        // Check if actual progression is equal or better than target
        function isProgressionEqualOrBetter(actualProgression, targetProgression) {
            const actualRank = getProgressionRank(actualProgression);
            const targetRank = getProgressionRank(targetProgression);
            return actualRank <= targetRank; // Lower rank = better
        }

        // Display team history table
        function displayTeamHistory(teamName, historyData, leagueToUse) {
            // displayTeamHistory called
            // History data processed
            
            // Filter by progression if selected
            let filteredData = [...historyData];
            let positionInfo = '';
            
            if (state.teamSeasonsSelectedPosition) {
                const selectedProgression = state.teamSeasonsSelectedPosition;
                // Filter by progression
                filteredData = historyData.filter(season => {
                    if (state.includeBetterResults) {
                        return isProgressionEqualOrBetter(season.tournamentProgression, selectedProgression);
                    } else {
                        return season.tournamentProgression === selectedProgression;
                    }
                });
                
                // Calculate years since last occurrence
                if (filteredData.length > 0) {
                    // Sort by season to find most recent season
                    const sortedByYear = [...filteredData].sort((a, b) => {
                        const yearA = parseInt(a.season.split('-')[0]);
                        const yearB = parseInt(b.season.split('-')[0]);
                        return yearB - yearA;
                    });
                    
                    // Most recent season
                    const qualifyingSeason = sortedByYear[0];
                    
                    // Count total times reached this progression
                    const totalCount = filteredData.length;
                    
                    const mostRecentYear = parseInt(qualifyingSeason.season.split('-')[0]);
                    const currentYear = new Date().getFullYear();
                    
                    // Calculate seasons since the qualifying season
                    const seasonsSince = currentYear - mostRecentYear;
                    
                    const seasonText = seasonsSince === 0 ? '0 Seasons Ago (Current Season)' : 
                                     seasonsSince === 1 ? '1 Season Ago' : `${seasonsSince} Seasons Ago`;
                    
                    const countText = totalCount === 1 ? 'Time' : 'Times';
                    const progressionText = state.includeBetterResults ? 
                        `${selectedProgression} or better` : 
                        selectedProgression;
                    positionInfo = `Most Recent: ${qualifyingSeason.season} Season, ${seasonText}. Reached ${progressionText} a total of ${totalCount} ${countText}.`;
                } else {
                    const progressionText = state.includeBetterResults ? 
                        `${selectedProgression} or better` : 
                        selectedProgression;
                    positionInfo = `No seasons found where ${teamName} reached ${progressionText}`;
                }
            }
            
            // Update progression info display and ensure it persists
            elements.teamSeasonsPositionInfo.innerHTML = positionInfo || 'NO POSITION INFO';

            // Apply proper styling for the position info text
            elements.teamSeasonsPositionInfo.style.cssText = 'margin-top: 0.5rem; font-size: 0.875rem; color: #6b7280; line-height: 1.25;';
            elements.teamSeasonsPositionInfo.style.display = 'block';

            // Double-check and force the text to stay after a brief delay
            setTimeout(() => {
                if (positionInfo && positionInfo.trim() && (!elements.teamSeasonsPositionInfo.textContent || elements.teamSeasonsPositionInfo.textContent.trim() === '')) {
                    elements.teamSeasonsPositionInfo.innerHTML = positionInfo;
                }
            }, 100);
            
            // Store data globally for sorting
            window.currentTeamHistoryData = [...filteredData];
            window.currentTeamHistoryName = teamName;
            
            elements.teamHistoryTitle.textContent = `${teamName} - Season History`;
            
            // Apply sorting if active
            let sortedData = [...filteredData];
            if (state.teamHistorySortConfig.key && state.teamHistorySortConfig.direction) {
                const key = state.teamHistorySortConfig.key;
                const direction = state.teamHistorySortConfig.direction;
                
                sortedData.sort((a, b) => {
                    let aVal = a[key];
                    let bVal = b[key];
                    
                    // Handle season sorting specially
                    if (key === 'season') {
                        // Extract year from season string (e.g., "2023-24" -> 2023)
                        aVal = parseInt(aVal.split('-')[0]);
                        bVal = parseInt(bVal.split('-')[0]);
                    }
                    
                    // Convert to numbers for numerical columns
                    if (typeof aVal === 'string' && !isNaN(aVal)) aVal = parseFloat(aVal);
                    if (typeof bVal === 'string' && !isNaN(bVal)) bVal = parseFloat(bVal);
                    
                    if (direction === 'asc') {
                        return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                    } else {
                        return aVal < bVal ? 1 : aVal > bVal ? -1 : 0;
                    }
                });
            }
            
            const headers = [
                { key: 'season', label: 'Season' },
                { key: 'team', label: 'Team' },
                { key: 'played', label: 'P' },
                { key: 'won', label: 'W' },
                { key: 'drawn', label: 'D' },
                { key: 'lost', label: 'L' },
                { key: 'goalsFor', label: 'GF' },
                { key: 'goalsAgainst', label: 'GA' },
                { key: 'goalDifference', label: 'GD' },
                { key: 'points', label: 'Pts' },
                { key: 'position', label: 'Pos' },
                { key: 'tournamentProgression', label: 'Progression' }
            ];
            
            elements.teamHistoryHeader.innerHTML = headers.map(header => `
                <th class="px-3 py-4 text-center font-bold text-sm ${header.key !== 'team' ? 'cursor-pointer hover:bg-gray-600' : ''}" 
                    ${header.key !== 'team' ? `onclick="handleTeamHistorySort('${header.key}')"` : ''}
                    style="text-align: ${(header.key === 'season' || header.key === 'team') ? 'left' : 'center'}">
                    ${header.label}${header.key !== 'team' ? getTeamHistorySortIndicator(header.key) : ''}
                </th>
            `).join('');
            
            elements.teamHistoryBody.innerHTML = sortedData.map((season, index) => {
                const rowBackgroundClass = sortedData.length >= 3 && index % 2 === 1 ? 'bg-gray-50' : 'bg-white';
                const logoUrl = getTeamLogoUrl(teamName, leagueToUse);
                
                return `
                    <tr class="border-b hover:bg-gray-50 ${rowBackgroundClass}">
                        <td class="px-3 py-4 font-semibold text-left">${season.season}</td>
                        <td class="px-4 py-4 font-semibold text-gray-900">
                            <div class="flex items-center">
                                ${logoUrl ? `<img src="${logoUrl}" alt="${teamName} logo" class="w-5 h-5 mr-2 object-contain" onerror="this.style.display='none'">` : ''}
                                <span style="color: #000000">${teamName}</span>
                            </div>
                        </td>
                        <td class="px-3 py-4 text-center">${season.played}</td>
                        <td class="px-3 py-4 text-center">${season.won}</td>
                        <td class="px-3 py-4 text-center">${season.drawn}</td>
                        <td class="px-3 py-4 text-center">${season.lost}</td>
                        <td class="px-3 py-4 text-center">${season.goalsFor}</td>
                        <td class="px-3 py-4 text-center">${season.goalsAgainst}</td>
                        <td class="px-3 py-4 text-center">
                            <span class="font-bold ${season.goalDifference > 0 ? 'text-green-700' : season.goalDifference < 0 ? 'text-red-600' : 'text-black'}">
                                ${season.goalDifference > 0 ? '+' : ''}${season.goalDifference}
                            </span>
                        </td>
                        <td class="px-3 py-4 text-center">
                            <span class="points-badge">
                                ${season.points}
                            </span>
                        </td>
                        <td class="px-3 py-4 text-center font-bold" style="${
                            season.position === 1 ? 'color: #d97706; background-color: #fef3c7;' : 
                            season.position === 2 ? 'color: #374151; background-color: #e5e7eb;' : 
                            season.position === 3 ? 'color: #b45309; background-color: #fef7ed;' : 
                            'color: #6b7280;'
                        }">${season.position}</td>
                        <td class="px-3 py-4 text-center font-bold" style="${
                            (season.tournamentProgression || 'Group Stage') === 'Champions' ? 'color: #d97706; background-color: #fef3c7;' :
                            (season.tournamentProgression || 'Group Stage') === 'Final' ? 'color: #374151; background-color: #e5e7eb;' :
                            (season.tournamentProgression || 'Group Stage') === 'Semi-Finals' ? 'color: #b45309; background-color: #fef7ed;' :
                            (season.tournamentProgression || 'Group Stage') === 'Quarter-Finals' ? 'color: #059669; background-color: #d1fae5;' :
                            (season.tournamentProgression || 'Group Stage') === 'Round Of 16' ? 'color: #2563eb; background-color: #dbeafe;' :
                            'color: #6b7280; background-color: #f9fafb;'
                        }">${season.tournamentProgression || 'Group Stage'}</td>
                    </tr>
                `;
            }).join('');
            
            // Switch to Team Seasons tab and show the table
            switchTab('team-seasons');
            
            // Update Team Seasons controls to reflect current selection
            createTeamSeasonsLeagueButtons();
            updateTeamSeasonsTeamSelect();
            
            // Final teamHistoryData processed
            elements.teamHistoryTable.classList.remove('hidden');
            // Team history table should now be visible
        }

        // Handle sorting
        function handleSort(key) {
            // Determine if this is a numerical column
            const numericalColumns = ['played', 'won', 'drawn', 'lost', 'goalsFor', 'goalsAgainst', 'goalDifference', 'points'];
            const isNumerical = numericalColumns.includes(key);
            
            // Set initial direction based on column type
            let direction = key === 'team' ? 'asc' : 'desc'; // Team: A-Z first, Numbers: high to low first
            
            if (state.sortConfig.key === key) {
                if (isNumerical) {
                    // Numerical columns: desc -> asc -> clear
                    if (state.sortConfig.direction === 'desc') {
                        direction = 'asc';
                    } else if (state.sortConfig.direction === 'asc') {
                        state.sortConfig = { key: null, direction: null };
                        updateTable();
                        return;
                    }
                } else {
                    // Team column: asc -> desc -> clear
                    if (state.sortConfig.direction === 'asc') {
                        direction = 'desc';
                    } else if (state.sortConfig.direction === 'desc') {
                        state.sortConfig = { key: null, direction: null };
                        updateTable();
                        return;
                    }
                }
            }
            
            state.sortConfig = { key, direction };
            updateTable();
        }

        // Handle team history sorting
        function handleTeamHistorySort(key) {
            // Determine if this is a numerical column
            const numericalColumns = ['position', 'count', 'played', 'won', 'drawn', 'lost', 'goalsFor', 'goalsAgainst', 'goalDifference', 'points'];
            const isNumerical = numericalColumns.includes(key);
            
            // Set initial direction based on column type
            let direction = key === 'season' ? 'desc' : 'desc'; // Season: newest first, Numbers: high to low first
            
            if (state.teamHistorySortConfig.key === key) {
                // Already sorting by this key, cycle through directions
                // 3-click cycle for ALL columns: desc -> asc -> null
                if (state.teamHistorySortConfig.direction === 'desc') {
                    direction = 'asc';
                } else if (state.teamHistorySortConfig.direction === 'asc') {
                    direction = null;
                } else {
                    direction = 'desc';
                }
            }
            
            state.teamHistorySortConfig = { key: direction ? key : null, direction };
            
            // Re-display the current team history with new sort
            if (window.currentTeamHistoryData) {
                // Check if we're in position-only mode or progression-only mode (multi-team view)
                if (window.currentTeamHistoryName && window.currentTeamHistoryName.startsWith('All teams (Position ')) {
                    // Extract position from the name like "All teams (Position 1)"
                    const positionMatch = window.currentTeamHistoryName.match(/Position (\d+)/);
                    if (positionMatch) {
                        const selectedPos = parseInt(positionMatch[1]);
                        
                        // Sort the data based on direction, or restore default order if null
                        let sortedData = [...window.currentTeamHistoryData];
                        if (direction && key) {
                            const isNumerical = numericalColumns.includes(key);
                            
                            sortedData.sort((a, b) => {
                                let aVal, bVal;
                                
                                if (key === 'season') {
                                    // For seasons, extract year for comparison
                                    aVal = parseInt(a.season.split('-')[0]);
                                    bVal = parseInt(b.season.split('-')[0]);
                                } else if (isNumerical) {
                                    aVal = a[key];
                                    bVal = b[key];
                                } else {
                                    // For text fields like team name
                                    aVal = a[key];
                                    bVal = b[key];
                                }
                                
                                if (direction === 'asc') {
                                    if (typeof aVal === 'string' && typeof bVal === 'string') {
                                        return aVal.localeCompare(bVal);
                                    }
                                    return aVal - bVal;
                                } else {
                                    if (typeof aVal === 'string' && typeof bVal === 'string') {
                                        return bVal.localeCompare(aVal);
                                    }
                                    return bVal - aVal;
                                }
                            });
                        } else if (!direction) {
                            // Restore default order: most recent season first, then by team name
                            sortedData.sort((a, b) => {
                                const yearA = parseInt(a.season.split('-')[0]);
                                const yearB = parseInt(b.season.split('-')[0]);
                                if (yearB !== yearA) return yearB - yearA;
                                return a.team.localeCompare(b.team);
                            });
                        }
                        
                        // Update the stored data and re-render
                        window.currentTeamHistoryData = sortedData;
                        renderPositionOnlyTable(sortedData, selectedPos, state.teamSeasonsSelectedLeague);
                    }
                } else if (window.currentTeamHistoryName && window.currentTeamHistoryName.startsWith('All teams (Progression: ')) {
                    // Extract progression from the name like "All teams (Progression: Champions)"
                    const progressionMatch = window.currentTeamHistoryName.match(/Progression: ([^)]+)\)/);
                    if (progressionMatch) {
                        const selectedProgression = progressionMatch[1];
                        
                        // Sort the data based on direction, or restore default order if null
                        let sortedData = [...window.currentTeamHistoryData];
                        if (direction && key) {
                            const isNumerical = numericalColumns.includes(key);
                            
                            sortedData.sort((a, b) => {
                                let aVal, bVal;
                                
                                if (key === 'season') {
                                    // For seasons, extract year for comparison
                                    aVal = parseInt(a.season.split('-')[0]);
                                    bVal = parseInt(b.season.split('-')[0]);
                                } else if (isNumerical) {
                                    aVal = a[key];
                                    bVal = b[key];
                                } else {
                                    // For text fields like team name
                                    aVal = a[key];
                                    bVal = b[key];
                                }
                                
                                if (direction === 'asc') {
                                    if (typeof aVal === 'string' && typeof bVal === 'string') {
                                        return aVal.localeCompare(bVal);
                                    }
                                    return aVal - bVal;
                                } else {
                                    if (typeof aVal === 'string' && typeof bVal === 'string') {
                                        return bVal.localeCompare(aVal);
                                    }
                                    return bVal - aVal;
                                }
                            });
                        } else if (!direction) {
                            // Restore default order: most recent season first, then by team name
                            sortedData.sort((a, b) => {
                                const yearA = parseInt(a.season.split('-')[0]);
                                const yearB = parseInt(b.season.split('-')[0]);
                                if (yearB !== yearA) return yearB - yearA;
                                return a.team.localeCompare(b.team);
                            });
                        }
                        
                        // Update the stored data and re-render
                        window.currentTeamHistoryData = sortedData;
                        renderProgressionOnlyTable(sortedData, selectedProgression, state.teamSeasonsSelectedLeague);
                    }
                } else {
                    // Single team mode - use original display function
                    displayTeamHistory(window.currentTeamHistoryName, window.currentTeamHistoryData, state.teamSeasonsSelectedLeague);
                }
            }
        }

        // Get team history sort indicator
        function getTeamHistorySortIndicator(key) {
            if (state.teamHistorySortConfig.key !== key) return ' ‚ÜïÔ∏è';
            
            if (state.teamHistorySortConfig.direction === 'asc') {
                return ' ‚Üë';
            } else if (state.teamHistorySortConfig.direction === 'desc') {
                return ' ‚Üì';
            }
            return ' ‚ÜïÔ∏è';
        }

        // Get sort indicator
        function getSortIndicator(key) {
            if (state.sortConfig.key !== key) return ' ‚ÜïÔ∏è';
            return state.sortConfig.direction === 'asc' ? ' ‚Üë' : ' ‚Üì';
        }

        // Clear filters
        function clearFilters() {
            if (state.data.length > 0) {
                const dates = state.data.map(row => row.dateObj);
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                state.dateFrom = minDate.toISOString().split('T')[0];
                state.dateTo = maxDate.toISOString().split('T')[0];
                elements.dateFrom.value = state.dateFrom;
                elements.dateTo.value = state.dateTo;
            }
            
            state.selectedTeam1 = '';
            state.selectedTeam2 = '';
            state.selectedSeason = '';
            state.selectedDayOfWeek = '';
            state.homeFilter = true;
            state.awayFilter = true;
            state.threePointSystem = true;
            state.pointDeductionsEnabled = true;
            state.excludeQualifiers = false;
            state.excludeMainStage = false;
            state.selectedLeague = 'champions-league';
            state.sortConfig = { key: null, direction: null };
            state.recentH2HCount = 'All';
            state.h2hStage = '';
            state.matchHistoryStage = '';
            state.matchHistoryHomeFilter = true;
            state.matchHistoryAwayFilter = true;
            state.matchHistoryPenaltyFilter = false;
            state.h2hPenaltyFilter = false;

            // Update UI elements
            elements.team1Select.value = '';
            elements.team2Select.value = '';
            elements.seasonSelect.value = '';
            elements.dayOfWeekSelect.value = '';
            elements.h2hStageSelect.value = '';
            elements.matchHistoryStageSelect.value = '';
            elements.matchHistoryHomeCheckbox.className = 'checkbox checked cursor-pointer flex items-center gap-1';
            elements.matchHistoryAwayCheckbox.className = 'checkbox checked cursor-pointer flex items-center gap-1';
            elements.matchHistoryPenaltyCheckbox.className = 'checkbox';
            elements.h2hPenaltyCheckbox.className = 'checkbox';
            elements.homeCheckbox.className = 'checkbox checked';
            elements.awayCheckbox.className = 'checkbox checked';
            elements.deductionsCheckbox.className = 'checkbox checked';
            elements.threePointCheckbox.className = 'checkbox checked';
            elements.excludeQualifiersCheckbox.className = 'checkbox';
            elements.excludeMainStageCheckbox.className = 'checkbox';
            
            createLeagueButtons();
            updateTeamSelects();
            updateTeamSeasonsTeamSelect();
            updateSeasonOptions();
            updateTable();
        }


        // Update UI based on current state
        function updateUI() {
            // UpdateUI called

            if (state.error) {
                elements.controlsSection.classList.add('hidden');
                elements.tableInfo.classList.add('hidden');
                elements.matchHistorySection.classList.add('hidden');
                elements.h2hSection.classList.add('hidden');
                elements.h2hMatchesTable.classList.add('hidden');
                elements.tableContainer.classList.add('hidden');
                elements.errorState.classList.remove('hidden');
                elements.errorMessage.textContent = state.error;
                return;
            }

            elements.errorState.classList.add('hidden');

            if (state.data.length > 0) {
                // Showing controls section
                elements.controlsSection.classList.remove('hidden');
                
                // Only show table-related sections if we're on the League Filters tab
                const isLeagueFiltersActive = document.getElementById('leagueFiltersTab').classList.contains('active');
                if (isLeagueFiltersActive) {
                    elements.tableContainer.classList.remove('hidden');
                    
                    // Only show H2H section when both teams are selected
                    if (state.selectedTeam1 && state.selectedTeam2) {
                        elements.h2hSection.classList.remove('hidden');
                    } else {
                        elements.h2hSection.classList.add('hidden');
                    }
                } else {
                    // Keep table hidden on Last Time When tab
                    elements.tableContainer.classList.add('hidden');
                    elements.h2hSection.classList.add('hidden');
                    elements.tableInfo.classList.add('hidden');
                }
            } else {
                // Data length is 0, keeping controls hidden
            }


            // Update form values
            elements.dateFrom.value = state.dateFrom;
            elements.dateTo.value = state.dateTo;
        }

        // Hamburger Menu Functionality
        function initHamburgerMenu() {
            const hamburgerBtn = document.getElementById('hamburgerBtn');
            const sideMenu = document.getElementById('sideMenu');
            const menuOverlay = document.getElementById('menuOverlay');
            const closeBtn = document.getElementById('closeMenuBtn');
            const continentalFootballLink = document.getElementById('continentalFootballLink');
            
            // Toggle menu function
            function toggleMenu() {
                const isOpen = sideMenu.classList.contains('open');
                
                if (isOpen) {
                    // Close menu
                    sideMenu.classList.remove('open');
                    menuOverlay.classList.remove('active');
                    hamburgerBtn.classList.remove('active');
                    document.body.style.overflow = '';
                } else {
                    // Open menu
                    sideMenu.classList.add('open');
                    menuOverlay.classList.add('active');
                    hamburgerBtn.classList.add('active');
                    document.body.style.overflow = 'hidden';
                }
            }
            
            // Event listeners
            hamburgerBtn.addEventListener('click', toggleMenu);
            closeBtn.addEventListener('click', toggleMenu);
            menuOverlay.addEventListener('click', toggleMenu);
            
            // Handle continental football link click - just close menu since we're already on the page
            continentalFootballLink.addEventListener('click', (e) => {
                e.preventDefault();
                toggleMenu(); // Close the menu
                // Since we're already on the continental football page, no navigation needed
            });
            
            // Prevent menu from closing when clicking inside the menu
            sideMenu.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            
            // Close menu with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && sideMenu.classList.contains('open')) {
                    toggleMenu();
                }
            });
        }

        // Handle responsive tab text
        function updateTabText() {
            const tabButtons = document.querySelectorAll('.tab-button[data-mobile-text]');
            const isMobile = window.innerWidth <= 768;
            
            tabButtons.forEach(button => {
                const mobileText = button.getAttribute('data-mobile-text');
                const originalText = button.textContent.trim();
                
                if (isMobile && mobileText) {
                    if (!button.getAttribute('data-original-text')) {
                        button.setAttribute('data-original-text', originalText);
                    }
                    button.textContent = mobileText;
                } else {
                    const savedOriginalText = button.getAttribute('data-original-text');
                    if (savedOriginalText) {
                        button.textContent = savedOriginalText;
                    }
                }
            });
        }

        // Dark Mode Functionality
        function initDarkMode() {
            const darkModeToggle = document.getElementById('darkModeToggle');
            const body = document.body;
            
            if (!darkModeToggle) {
                return;
            }
            
            // Check for saved dark mode preference
            const savedTheme = localStorage.getItem('theme');
            
            if (savedTheme === 'dark') {
                body.setAttribute('data-theme', 'dark');
                darkModeToggle.checked = true;
                setTimeout(handlePositionColors, 100); // Delay to ensure table is rendered
            }
            
            // Add event listener for toggle
            darkModeToggle.addEventListener('change', function() {
                if (this.checked) {
                    body.setAttribute('data-theme', 'dark');
                    localStorage.setItem('theme', 'dark');
                    handlePositionColors();
                } else {
                    body.removeAttribute('data-theme');
                    localStorage.setItem('theme', 'light');
                    handlePositionColors();
                }
            });
        }
        
        // Handle table colors by specific column headers
        function handlePositionColors() {
            const isDark = document.body.getAttribute('data-theme') === 'dark';
            if (!isDark) {
                // Remove all inline styles in light mode, but preserve win-score and draw-score classes
                document.querySelectorAll('.league-table tbody tr td').forEach(cell => {
                    if (!cell.classList.contains('win-score') && !cell.classList.contains('draw-score')) {
                        cell.style.color = '';
                    }
                });
                return;
            }
            
            const headers = document.querySelectorAll('.league-table thead th');
            const columnRules = {
                'Season': 'white',
                'Team': 'white', 
                'P': 'white',
                'W': 'white',
                'D': 'white',
                'L': 'white',
                'GF': 'white',
                'GA': 'white',
                'GD': 'white',
                'Pts': 'default',
                'Pos': 'special' // Special handling for 1,2,3
            };
            
            headers.forEach((header, columnIndex) => {
                const headerText = header.textContent.trim();
                const rule = columnRules[headerText];
                
                if (rule) {
                    const cells = document.querySelectorAll(`.league-table tbody tr td:nth-child(${columnIndex + 1})`);
                    cells.forEach(cell => {
                        // Don't override win-score or draw-score classes
                        if (cell.classList.contains('win-score') || cell.classList.contains('draw-score')) {
                            return;
                        }

                        if (rule === 'white') {
                            cell.style.color = 'white';
                        } else if (rule === 'default') {
                            cell.style.color = '';
                            cell.style.removeProperty('color');
                        } else if (rule === 'special' && headerText === 'Pos') {
                            const text = cell.textContent.trim();
                            if (text === '1' || text === '2' || text === '3') {
                                cell.style.color = '';
                                cell.style.removeProperty('color');
                            } else {
                                cell.style.color = 'white';
                            }
                        }
                    });
                }
            });
        }

        // Make functions global for onclick handlers
        window.handleSort = handleSort;
        window.handleH2hSort = handleH2hSort;
        window.handleTeamHistorySort = handleTeamHistorySort;

        // Initialize the application
        init();
        initHamburgerMenu();
        
        // Initialize dark mode with small delay to ensure DOM is ready
        setTimeout(initDarkMode, 100);
        
        updateTabText();
        
        // Handle window resize for responsive tabs
        window.addEventListener('resize', updateTabText);
    </script>
</body>
</html>
